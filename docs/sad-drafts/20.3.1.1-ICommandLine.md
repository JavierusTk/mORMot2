### 20.3.1.1. Command-Line Parsing

The `ICommandLine` interface provides a type-safe, interactive command-line parsing framework with support for console redirection and user prompts.

**Unit**: `mormot.app.console`

**Implementation**: `TCommandLine` class

#### Interface Design

`ICommandLine` provides a clean abstraction for command-line argument processing with strong typing:

```pascal
ICommandLine = interface
  ['{77AB427C-1025-488B-8E04-3E62C8100E62}']
  function AsUtf8(const Switch, Default: RawUtf8;
    const Prompt: string): RawUtf8;
  function AsString(const Switch: RawUtf8; const Default: string;
    const Prompt: string): string;
  function AsInt(const Switch: RawUtf8; Default: Int64;
    const Prompt: string): Int64;
  function AsDate(const Switch: RawUtf8; Default: TDateTime;
    const Prompt: string): TDateTime;
  function AsEnum(const Switch, Default: RawUtf8; TypeInfo: pointer;
    const Prompt: string): integer;
  function AsArray: TRawUtf8DynArray;
  function AsJson(Format: TTextWriterJsonFormat): RawUtf8;
  function NoPrompt: boolean;
  procedure TextColor(Color: TConsoleColor);
  procedure Text(const Fmt: RawUtf8; const Args: array of const;
    Color: TConsoleColor = ccLightGray);
end;
```

#### Type-Safe Argument Accessors

Each accessor provides:
- **Switch name**: Lowercase switch identifier (e.g., `'config'` for `-config`)
- **Default value**: Returned if switch not provided and `NoPrompt` is true
- **Prompt text**: Interactive message when switch is missing

**AsUtf8** - UTF-8 text values:
```pascal
var
  ConfigFile: RawUtf8;
begin
  ConfigFile := CommandLine.AsUtf8('config', 'default.cfg',
    'Enter configuration file:');
end;
```

**AsString** - RTL string values:
```pascal
OutputPath := CommandLine.AsString('output', 'C:\Output',
  'Enter output directory:');
```

**AsInt** - Integer values:
```pascal
Port := CommandLine.AsInt('port', 8080,
  'Enter server port:');
```

**AsDate** - ISO-8601 date values:
```pascal
// Expects YYYY-MM-DD format
StartDate := CommandLine.AsDate('startdate', Now,
  'Enter start date (YYYY-MM-DD):');
```

**AsEnum** - Enumeration values (by name or ordinal):
```pascal
type
  TLogLevel = (llDebug, llInfo, llWarning, llError);

var
  Level: TLogLevel;
begin
  Level := TLogLevel(CommandLine.AsEnum('loglevel', 'info',
    TypeInfo(TLogLevel), 'Enter log level (debug/info/warning/error):'));
end;
```

#### Interactive Prompts

When a switch is missing and `NoPrompt = false`, the framework prompts the user:

```
Enter server port:
port [8080]: █
```

**Prompt behavior**:
- Displays prompt text
- Shows switch name with default in brackets
- Color-coded input (cyan for switch, white for value)
- `Enter` accepts default value
- Automatically trims whitespace

**NoPrompt mode** - Suppresses all interactive prompts:
```pascal
// Via -noprompt switch
myapp.exe -noprompt -config myfile.cfg

// Or programmatically
CommandLine := TCommandLine.Create(
  ['config', 'myfile.cfg'],
  true);  // aNoConsole = true implies NoPrompt = true
```

#### Switch Parsing

`TCommandLine.Create` parses standard switch formats:

**Named switches** (key-value pairs):
```bash
myapp.exe -config file.cfg -port 8080 -verbose
```

Parsed as:
```
config = "file.cfg"
port   = "8080"
verbose = true
```

**Boolean flags** (switches without values):
```bash
myapp.exe -verbose -debug -noprompt
```

**Special switches**:
- `-noprompt`: Disables interactive prompts globally

**Array mode** - Parse positional arguments:
```pascal
// myapp.exe file1.txt file2.txt file3.txt
CommandLine := TCommandLine.CreateAsArray(1);  // Start from ParamStr(1)
Files := CommandLine.AsArray;
// Files = ['file1.txt', 'file2.txt', 'file3.txt']
```

#### Console Redirection

`TCommandLine` supports three output modes:

**Normal console output**:
```pascal
CommandLine := TCommandLine.Create;  // NoConsole = false
CommandLine.Text('Processing %...', [FileName], ccLightGray);
// Writes to console immediately
```

**Redirected output** (GUI apps, logging):
```pascal
CommandLine := TCommandLine.Create(
  ['config', 'file.cfg'],
  true);  // NoConsole = true

CommandLine.Text('Operation started', [], ccLightGray);
CommandLine.Text('Processing...', [], ccLightGreen);
CommandLine.Text('Operation complete', [], ccLightGray);

// Retrieve all output
Log := CommandLine.ConsoleText(CRLF);
// "Operation started\r\nProcessing...\r\nOperation complete"
```

**NoConsole behavior**:
- `Text()` writes to internal buffer (`ConsoleLines[]`)
- Console not written to
- Retrieve via `ConsoleText()` or `ConsoleLines` property
- Automatically sets `NoPrompt = true`

#### Serialization

**AsJson** - Export all switches as JSON:
```pascal
// Command line: myapp.exe -config file.cfg -port 8080 -verbose
CommandLine.AsJson(jsonCompact);
// {"config":"file.cfg","port":"8080","verbose":true}
```

Useful for:
- Logging command-line configuration
- Debugging switch parsing
- Configuration file generation

#### Programmatic Construction

**From variant** (TDocVariant):
```pascal
var
  Switches: variant;
begin
  TDocVariant.New(Switches);
  Switches.config := 'file.cfg';
  Switches.port := 8080;
  Switches.verbose := true;

  CommandLine := TCommandLine.Create(Switches, true);
end;
```

**From name-value pairs**:
```pascal
CommandLine := TCommandLine.Create(
  ['config', 'file.cfg',
   'port', 8080,
   'verbose', true],
  true);
```

**Use case**: GUI applications that need to simulate command-line behavior for scripting/automation.

#### Implementation Details

**Internal storage**:
- Uses `TDocVariantData` for flexible key-value storage
- Supports both object (`dvObject`) and array (`dvArray`) modes
- Automatic type conversion for all accessor methods

**Switch consumption**:
```pascal
// First call retrieves and removes switch
Config1 := CommandLine.AsUtf8('config', '', '');  // Returns value
// Second call returns default (switch already consumed)
Config2 := CommandLine.AsUtf8('config', 'default', '');  // Returns 'default'
```

**Color management**:
- `TextColor()` changes console foreground color
- Automatically disabled when `NoPrompt = true`
- Uses `TConsoleColor` enumeration

**Thread safety**: Not thread-safe. Create separate instances per thread.

#### Example: Complete Console Application

```pascal
program ConsoleApp;

uses
  mormot.app.console,
  mormot.core.base,
  mormot.core.os;

type
  TLogLevel = (llDebug, llInfo, llWarning, llError);

var
  Cmd: ICommandLine;
  ConfigFile: RawUtf8;
  Port: Int64;
  LogLevel: TLogLevel;
  StartDate: TDateTime;
begin
  Cmd := TCommandLine.Create;

  // Type-safe argument retrieval
  ConfigFile := Cmd.AsUtf8('config', 'app.cfg',
    'Enter configuration file:');

  Port := Cmd.AsInt('port', 8080,
    'Enter server port (1024-65535):');

  LogLevel := TLogLevel(Cmd.AsEnum('loglevel', 'info',
    TypeInfo(TLogLevel), 'Enter log level:'));

  StartDate := Cmd.AsDate('startdate', Now,
    'Enter start date (YYYY-MM-DD):');

  // Display configuration
  Cmd.Text('Configuration:', [], ccLightGray);
  Cmd.TextColor(ccCyan);
  Cmd.Text('  Config: %', [ConfigFile]);
  Cmd.Text('  Port: %', [Port]);
  Cmd.Text('  Log Level: %', [GetEnumName(TypeInfo(TLogLevel), Ord(LogLevel))^]);
  Cmd.Text('  Start Date: %', [DateTimeToIso8601Text(StartDate)]);

  // Application logic here...

  ReadLn;
end.
```

**Command-line usage**:
```bash
# Interactive mode (prompts for missing values)
ConsoleApp.exe

# Non-interactive mode (all values provided)
ConsoleApp.exe -config prod.cfg -port 9000 -loglevel debug -startdate 2024-01-01 -noprompt
```

#### Best Practices

1. **Always provide defaults**: Ensures non-interactive execution works
2. **Use NoPrompt for automation**: Add `-noprompt` switch for scripts/CI
3. **Choose appropriate types**: Use `AsDate` for dates, `AsEnum` for typed values
4. **Enable console redirection for GUI**: Set `NoConsole = true` when embedding in GUI apps
5. **Export configuration**: Use `AsJson()` to log effective configuration
6. **Validate ranges**: Check returned values (e.g., port 1024-65535)
7. **Use array mode for file lists**: `CreateAsArray()` for positional arguments
