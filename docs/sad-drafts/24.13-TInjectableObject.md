## 24.13. Dependency Injection with TInjectableObject

### Overview

`TInjectableObject` provides a foundation class for implementing **Dependency Injection** (DI) and **Inversion of Control** (IoC) patterns in mORMot applications. It enables automatic dependency resolution through constructor injection, published property injection, and manual resolution.

**Key Benefits:**
- **Testability**: Replace real dependencies with stubs/mocks during testing
- **Decoupling**: Services depend on abstractions (interfaces), not implementations
- **Flexibility**: Swap implementations without changing dependent code
- **Maintainability**: Centralized dependency configuration

---

### 24.13.1. Basic Constructor Injection

The simplest form of DI uses `CreateWithResolver()` to inject a single resolver:

```pascal
type
  ILogger = interface(IInvokable)
    ['{B1234567-89AB-CDEF-0123-456789ABCDEF}']
    procedure Log(const Msg: RawUtf8);
  end;

  IEmailService = interface(IInvokable)
    ['{C2345678-9ABC-DEF0-1234-56789ABCDEF0}']
    procedure SendEmail(const ToAddr, Subject, Body: RawUtf8);
  end;

  TOrderProcessor = class(TInjectableObject)
  private
    fLogger: ILogger;
    fEmailService: IEmailService;
  public
    constructor Create; override;
    procedure ProcessOrder(OrderID: TID);
  published
    property Logger: ILogger read fLogger write fLogger;
    property EmailService: IEmailService read fEmailService write fEmailService;
  end;

constructor TOrderProcessor.Create;
begin
  // Properties will be auto-resolved after this call completes
  inherited Create;
end;

// Usage with resolver
var
  Resolver: TInterfaceResolverInjected;
  Processor: TOrderProcessor;
begin
  Resolver := TInterfaceResolverInjected.Create;
  try
    // Configure dependencies
    Resolver.InjectInstance([TFileLogger.Create, TSmtpEmailService.Create]);

    // Create with auto-injection
    Processor := TOrderProcessor.CreateWithResolver(Resolver);
    try
      Processor.ProcessOrder(1234);
    finally
      Processor.Free;
    end;
  finally
    Resolver.Free;
  end;
end;
```

**How It Works:**
1. `CreateWithResolver()` stores the resolver internally
2. Calls `inherited Create` (your constructor)
3. Calls `AutoResolve()` to inject all **published** interface properties
4. Raises `EInterfaceResolver` if any required dependency cannot be resolved

---

### 24.13.2. Multi-Resolver Injection

For complex scenarios, use `CreateInjected()` to combine stubs, resolvers, and instances:

```pascal
type
  TOrderService = class(TInjectableObject)
  private
    fRepository: IOrderRepository;
    fPricing: IPricingService;
    fNotifier: INotificationService;
  published
    property Repository: IOrderRepository read fRepository write fRepository;
    property Pricing: IPricingService read fPricing write fPricing;
    property Notifier: INotificationService read fNotifier write fNotifier;
  end;

// Testing scenario: mix stubs, mocks, and real instances
var
  Service: IOrderService;
  MockNotifier: TInterfaceMock;
begin
  // Register interfaces first
  TInterfaceFactory.RegisterInterfaces([
    TypeInfo(IOrderRepository),
    TypeInfo(IPricingService),
    TypeInfo(INotificationService)
  ]);

  // Create test instance with mixed dependencies
  Service := TOrderService.CreateInjected(
    // 1. Stubs by GUID (blank implementations)
    [IOrderRepository],

    // 2. Custom resolvers (mocks, service containers)
    [TInterfaceMock.Create(TypeInfo(INotificationService)).
       ExpectsCount('Notify', qoEqualTo, 1)],

    // 3. Real instances
    [TStandardPricingService.Create]
  ) as IOrderService;

  // Use service - all dependencies injected
  Service.PlaceOrder(...);
end;
```

**Constructor Signature:**
```pascal
constructor CreateInjected(
  const aStubsByGuid: array of TGuid;          // Auto-created blank stubs
  const aOtherResolvers: array of TInterfaceResolver; // Custom resolvers
  const aDependencies: array of TInterfacedObject;    // Real instances
  aRaiseEServiceExceptionIfNotFound: boolean = true   // Fail on missing deps
); virtual;
```

**Ownership Rules:**
- **Stubs**: Owned and freed by `TInjectableObject`
- **Resolvers**: Owned and freed by `TInjectableObject`
- **Instances**: Reference counted (AddRef/Release)

---

### 24.13.3. Manual Resolution

For lazy initialization or conditional dependencies:

```pascal
type
  TReportGenerator = class(TInjectableObject)
  private
    fRepository: IDataRepository;
    function GetRepository: IDataRepository;
  public
    function GenerateReport(ReportType: Integer): RawUtf8;
    property Repository: IDataRepository read GetRepository;
  end;

function TReportGenerator.GetRepository: IDataRepository;
begin
  if fRepository = nil then
    Resolve(TypeInfo(IDataRepository), fRepository); // Lazy load
  Result := fRepository;
end;
```

**Resolution Methods:**

| Method | Usage |
|--------|-------|
| `Resolve(aInterface: PRttiInfo; out Obj)` | Resolve by RTTI (raises on failure) |
| `Resolve(aGuid: TGuid; out Obj)` | Resolve by GUID (raises on failure) |
| `TryResolve(aInterface: PRttiInfo; out Obj): Boolean` | Safe resolution (returns false on failure) |
| `ResolveByPair(const aInterfaceObjPairs: array of pointer)` | Resolve multiple at once |
| `Resolve(const aInterfaces: array of TGuid; const aObjs: array of pointer)` | Batch resolution |

---

### 24.13.4. Service Lifetime Patterns

mORMot supports different service lifetimes through resolver configuration:

#### Transient (New Instance Per Resolution)

```pascal
type
  TTransientResolver = class(TInterfaceResolver)
  private
    fClass: TInterfacedObjectClass;
  protected
    function TryResolve(aInterface: PRttiInfo; out Obj): boolean; override;
  public
    constructor Create(aClass: TInterfacedObjectClass);
  end;

function TTransientResolver.TryResolve(aInterface: PRttiInfo; out Obj): boolean;
begin
  Result := True;
  IInterface(Obj) := fClass.Create; // New instance every time
end;

// Usage
Resolver.InjectResolver([TTransientResolver.Create(TFileLogger)]);
```

#### Singleton (Shared Instance)

```pascal
// Method 1: Via GlobalInterfaceResolver
TInterfaceResolverInjected.RegisterGlobal(
  TypeInfo(ILogger),
  TFileLogger.Create // Single shared instance
);

// Method 2: Via InjectInstance
var
  SharedLogger: ILogger;
begin
  SharedLogger := TFileLogger.Create;
  Resolver.InjectInstance([SharedLogger as TInterfacedObject]);
  // Same instance injected everywhere
end;
```

#### Scoped (Per-Request in Services)

```pascal
// In TRestServer.ServiceDefine
Server.ServiceDefine(
  TOrderService,
  [IOrderService],
  sicClientDriven // New instance per client connection
);

Server.ServiceDefine(
  TConfigService,
  [IConfigService],
  sicShared // Singleton across all clients
);
```

---

### 24.13.5. Integration with TInterfaceFactory

`TInterfaceFactory` generates runtime implementations for interfaces, working seamlessly with DI:

```pascal
// Step 1: Register interface RTTI
TInterfaceFactory.RegisterInterfaces([
  TypeInfo(ICalculator),
  TypeInfo(IStorage)
]);

// Step 2: Create stubs for testing
var
  CalcStub: TInterfaceStub;
  Calc: ICalculator;
begin
  CalcStub := TInterfaceStub.Create(TypeInfo(ICalculator), Calc);

  // Define stub behavior
  CalcStub.Returns('Add', 42);
  CalcStub.Executes('Subtract',
    procedure(const Args: array of TInterfaceStubRuleParam;
              out Result: TInterfaceStubRuleParam)
    begin
      Result.AsInteger := Args[0].AsInteger - Args[1].AsInteger;
    end);
end;

// Step 3: Inject stub into dependent
var
  Service: TCalculationService;
begin
  Service := TCalculationService.CreateInjected(
    [], // No GUID stubs
    [CalcStub], // Use configured stub
    []
  );
end;
```

**Factory + DI Workflow:**

```
┌────────────────────────────────────────────────────────────┐
│                 TInterfaceFactory Workflow                  │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  1. RegisterInterfaces([TypeInfo(IMyService)])             │
│     └─► Registers interface RTTI globally                 │
│                                                            │
│  2. TInterfaceStub.Create(TypeInfo(IMyService))            │
│     └─► Factory generates fake implementation class       │
│     └─► Stub configures method behavior                   │
│                                                            │
│  3. TInjectableObject.CreateInjected([Stub])               │
│     └─► Resolver matches interface → stub instance        │
│     └─► Auto-injects into published properties            │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

### 24.13.6. Testing with Stubs and Mocks

Full testing example combining DI, stubs, and mocks:

```pascal
type
  IOrderRepository = interface(IInvokable)
    ['{...}']
    function GetOrder(ID: TID): TOrder;
    procedure SaveOrder(Order: TOrder);
  end;

  IPaymentGateway = interface(IInvokable)
    ['{...}']
    function ProcessPayment(Amount: Currency): Boolean;
  end;

  TOrderService = class(TInjectableObject)
  published
    property Repository: IOrderRepository;
    property Gateway: IPaymentGateway;
  public
    function CheckoutOrder(OrderID: TID): Boolean;
  end;

// Test case
procedure TTestOrderService.TestSuccessfulCheckout;
var
  Service: TOrderService;
  RepoStub: TInterfaceStub;
  PaymentMock: TInterfaceMock;
  Repo: IOrderRepository;
  Payment: IPaymentGateway;
begin
  // Setup repository stub
  RepoStub := TInterfaceStub.Create(TypeInfo(IOrderRepository), Repo);
  RepoStub.Returns('GetOrder',
    ObjectToJson(CreateTestOrder(), [woHumanReadable]));

  // Setup payment mock with expectations
  PaymentMock := TInterfaceMock.Create(TypeInfo(IPaymentGateway), Payment, Self);
  PaymentMock.ExpectsCount('ProcessPayment', qoEqualTo, 1);
  PaymentMock.Returns('ProcessPayment', True);

  // Create service with injected dependencies
  Service := TOrderService.CreateInjected(
    [], // No GUID stubs
    [RepoStub, PaymentMock], // Configured stubs/mocks
    [] // No real instances
  );
  try
    // Exercise
    CheckTrue(Service.CheckoutOrder(123));

    // Verify mock expectations
    PaymentMock.Verify;
  finally
    Service.Free;
  end;
end;
```

**Stub vs Mock:**
- **Stub**: Provides canned responses, no verification
- **Mock**: Verifies method calls (count, parameters, order)

---

### 24.13.7. Global Registration

For process-wide shared services:

```pascal
initialization
  // Register global singleton implementations
  TInterfaceResolverInjected.RegisterGlobal(
    TypeInfo(ILogger),
    TFileLogger.Create('/logs/app.log')
  );

  TInterfaceResolverInjected.RegisterGlobal(
    TypeInfo(IConfigService),
    TJsonConfigService
  ); // Will instantiate on first resolve

finalization
  // Optional: Clean up before process exit
  TInterfaceResolverInjected.RegisterGlobalDelete(TypeInfo(ILogger));
```

**Built-in Global Registrations:**
```pascal
// Automatically registered by mormot.core.interfaces:
GlobalInterfaceResolver.Add(TypeInfo(IAutoLocker), TAutoLocker);
GlobalInterfaceResolver.Add(TypeInfo(ILockedDocVariant), TLockedDocVariant);
```

**When to Use Global Registration:**
- Cross-cutting concerns (logging, caching, monitoring)
- Configuration services
- Shared infrastructure (database pools, HTTP clients)

**When to Avoid:**
- Request-scoped services
- Services with per-client state
- Testing scenarios (prefer local injection)

---

### 24.13.8. Advanced: Custom Resolvers

Create specialized resolvers for complex scenarios:

```pascal
type
  /// Resolver that selects implementation based on configuration
  TConfigBasedResolver = class(TInterfaceResolver)
  private
    fConfig: IConfigService;
    fImplementations: TInterfaceResolverObjArray;
  protected
    function TryResolve(aInterface: PRttiInfo; out Obj): boolean; override;
  public
    constructor Create(Config: IConfigService);
    procedure RegisterImplementation(aInterface: PRttiInfo;
                                     aClass: TInterfacedObjectClass;
                                     const ConfigKey: RawUtf8);
  end;

function TConfigBasedResolver.TryResolve(aInterface: PRttiInfo;
                                          out Obj): boolean;
var
  SelectedClass: TInterfacedObjectClass;
begin
  // Read configuration to decide which implementation
  if fConfig.GetBool('UseCache') then
    SelectedClass := TCachedDataService
  else
    SelectedClass := TDirectDataService;

  IInterface(Obj) := SelectedClass.Create;
  Result := True;
end;

// Usage
var
  CustomResolver: TConfigBasedResolver;
  Service: TDataProcessingService;
begin
  CustomResolver := TConfigBasedResolver.Create(ConfigService);
  CustomResolver.RegisterImplementation(
    TypeInfo(IDataService),
    TCachedDataService,
    'UseCache'
  );

  Service := TDataProcessingService.CreateWithResolver(CustomResolver);
end;
```

---

### 24.13.9. Best Practices

#### 1. Prefer Published Properties for Auto-Injection

```pascal
// ✓ Good: Auto-injected
type
  TMyService = class(TInjectableObject)
  published
    property Logger: ILogger;
    property Repository: IDataRepository;
  end;

// ❌ Avoid: Requires manual resolution
type
  TMyService = class(TInjectableObject)
  private
    fLogger: ILogger;
    fRepository: IDataRepository;
  public
    constructor Create; override;
  end;
```

#### 2. Fail Fast on Missing Dependencies

```pascal
// ✓ Good: Fail during construction
Service := TOrderService.CreateWithResolver(
  Resolver,
  True  // aRaiseEServiceExceptionIfNotFound
);

// ❌ Risky: Fail later during execution
Service := TOrderService.CreateWithResolver(
  Resolver,
  False // Silent failure, NullReferenceException later
);
```

#### 3. Use Descriptive Interface Names

```pascal
// ✓ Good: Clear domain meaning
type
  IOrderPricingCalculator = interface(IInvokable)
  ICustomerNotificationService = interface(IInvokable)
  IInventoryRepository = interface(IInvokable)

// ❌ Avoid: Generic technical names
type
  IService = interface(IInvokable)
  IHelper = interface(IInvokable)
  IManager = interface(IInvokable)
```

#### 4. Keep Resolvers Scoped Appropriately

```pascal
// ✓ Good: Local resolver for request scope
procedure HandleWebRequest(Context: THttpServerRequest);
var
  Resolver: TInterfaceResolverInjected;
  Service: IRequestProcessor;
begin
  Resolver := TInterfaceResolverInjected.Create;
  try
    Resolver.InjectInstance([CreateRequestContext(Context)]);
    Resolve(TypeInfo(IRequestProcessor), Service);
    Service.Process;
  finally
    Resolver.Free;
  end;
end;

// ❌ Avoid: Shared resolver with mutable state
var
  GlobalResolver: TInterfaceResolverInjected; // Concurrency issues!
```

---

### 24.13.10. Common Patterns

#### Factory Pattern with DI

```pascal
type
  IReportFactory = interface(IInvokable)
    function CreateReport(ReportType: RawUtf8): IReport;
  end;

  TReportFactory = class(TInjectableObject, IReportFactory)
  private
    fResolver: TInterfaceResolver; // Inherited from TInjectableObject
  public
    function CreateReport(ReportType: RawUtf8): IReport;
  end;

function TReportFactory.CreateReport(ReportType: RawUtf8): IReport;
begin
  if ReportType = 'PDF' then
    Resolve(TypeInfo(IPdfReport), Result)
  else if ReportType = 'Excel' then
    Resolve(TypeInfo(IExcelReport), Result)
  else
    raise EReportError.Create('Unknown report type');
end;
```

#### Decorator Pattern with DI

```pascal
type
  IDataService = interface(IInvokable)
    function GetData(ID: TID): RawUtf8;
  end;

  // Base implementation
  TDataService = class(TInjectableObject, IDataService)
  published
    property Repository: IDataRepository;
  public
    function GetData(ID: TID): RawUtf8;
  end;

  // Caching decorator
  TCachedDataService = class(TInjectableObject, IDataService)
  private
    fInner: IDataService;
    fCache: ICache;
  published
    property Cache: ICache read fCache write fCache;
  public
    constructor CreateWithInner(Inner: IDataService);
    function GetData(ID: TID): RawUtf8;
  end;

function TCachedDataService.GetData(ID: TID): RawUtf8;
begin
  Result := fCache.Get(ID);
  if Result = '' then
  begin
    Result := fInner.GetData(ID); // Delegate to wrapped service
    fCache.Set(ID, Result);
  end;
end;

// Usage with DI
var
  BaseService: IDataService;
  CachedService: IDataService;
begin
  Resolve(TypeInfo(IDataService), BaseService);
  CachedService := TCachedDataService.CreateWithInner(BaseService);
end;
```

---

### 24.13.11. Troubleshooting

#### Issue: `EInterfaceResolver: Impossible to resolve published property X`

**Cause:** No resolver can provide the required interface.

**Solution:**
```pascal
// 1. Verify interface is registered
TInterfaceFactory.RegisterInterfaces([TypeInfo(IMyService)]);

// 2. Add implementation to resolver
Resolver.InjectInstance([TMyServiceImpl.Create]);

// 3. Check GUID matches
type
  IMyService = interface(IInvokable)
    ['{CORRECT-GUID-HERE}'] // Must match registration
  end;
```

#### Issue: Interface Reference Becomes Nil After Constructor

**Cause:** Using private fields instead of published properties.

**Solution:**
```pascal
// ❌ Wrong: Private field not auto-injected
type
  TMyClass = class(TInjectableObject)
  private
    fService: IMyService; // NOT injected
  end;

// ✓ Correct: Published property auto-injected
type
  TMyClass = class(TInjectableObject)
  published
    property Service: IMyService; // Auto-injected
  end;
```

#### Issue: Circular Dependencies

**Cause:** Service A needs Service B, Service B needs Service A.

**Solution:**
```pascal
// Break cycle with interface segregation
type
  IServiceAReader = interface(IInvokable)
    function ReadData: RawUtf8;
  end;

  IServiceAWriter = interface(IInvokable)
    procedure WriteData(const Data: RawUtf8);
  end;

  TServiceA = class(TInjectableObject, IServiceAReader, IServiceAWriter)
  published
    property ServiceB: IServiceBReader; // Only needs reader
  end;

  TServiceB = class(TInjectableObject, IServiceBReader)
  published
    property ServiceA: IServiceAWriter; // Only needs writer
  end;
```

---

### 24.13.12. Performance Considerations

**Resolution Overhead:**
- `AutoResolve()` uses RTTI to scan published properties (~microseconds)
- Resolution itself is typically fast (dictionary lookup)
- Consider caching resolved instances in hot paths

**Memory:**
- `TInjectableObject` owns stubs/resolvers (no leaks if properly destroyed)
- Interface reference counting handles cleanup automatically
- Use `sicShared` for singleton services to avoid duplicate instances

**Optimization Tips:**

```pascal
// ✓ Good: Resolve once, reuse
type
  TOptimizedService = class(TInjectableObject)
  private
    fLogger: ILogger; // Cached after first resolve
    function GetLogger: ILogger;
  published
    property Logger: ILogger read GetLogger; // Auto-resolved once
  end;

// ❌ Avoid: Re-resolve on every access
type
  TSlowService = class(TInjectableObject)
  private
    function GetLogger: ILogger;
  public
    property Logger: ILogger read GetLogger; // Resolves every time!
  end;

function TSlowService.GetLogger: ILogger;
begin
  Resolve(TypeInfo(ILogger), Result); // SLOW: Repeated resolution
end;
```

---

### 24.13.13. Summary

`TInjectableObject` enables clean, testable, maintainable code through:

| Feature | Benefit |
|---------|---------|
| **Constructor Injection** | Dependencies explicit, fail-fast on missing deps |
| **Auto-Resolution** | Published properties injected automatically |
| **Stub/Mock Support** | Isolated unit testing without real implementations |
| **Multiple Resolvers** | Flexible composition of dependency sources |
| **Service Lifetimes** | Singleton, transient, scoped patterns |
| **Global Registration** | Process-wide shared services |
| **Custom Resolvers** | Extensible for specialized scenarios |

**Key Takeaways:**
- Use **published properties** for automatic injection
- Combine **stubs, resolvers, and instances** for testing flexibility
- Leverage **TInterfaceFactory** for runtime interface generation
- Follow **SOLID principles**: depend on interfaces, not implementations
- Register interfaces with **`TInterfaceFactory.RegisterInterfaces()`** before use
- Choose appropriate **service lifetime** (singleton vs transient)

**Next Steps:**
- See Section 24.14 for **TInterfaceStub** testing patterns
- See Section 24.15 for **TServiceContainer** integration in REST servers
- Review `mormot.core.interfaces.pas` source for advanced customization
