# 11.X. TUriRouter - Modern Routing Engine

*Fast Path to Performance*

## 11.X.1. Overview

`TUriRouter` is mORMot 2's high-performance URI routing engine built on a **Radix Tree** data structure. It provides efficient server-side URL routing for `THttpServerGeneric` with thread-safe, non-blocking URI parsing and parameter extraction.

**Key Features**:

- **Ultra-fast lookups**: 25.7M lookups/second (37ns average)
- **Zero-allocation for static routes**: No memory allocation during request processing
- **Parametrized routes**: Extract values from URI patterns like `/user/<id>/pic`
- **Type-safe parameters**: Support for typed placeholders (`<int:id>`, `<path:filepath>`)
- **URI rewriting**: Transparent URL transformation before handler execution
- **Method-specific routing**: Separate route trees for GET/POST/PUT/DELETE/PATCH/OPTIONS/HEAD
- **Thread-safe**: Uses read/write locks for concurrent access
- **RTTI-based registration**: Automatic routing from published class methods

## 11.X.2. Architecture

### Radix Tree Foundation

`TUriRouter` uses a **Radix Tree** (compressed trie) for efficient URI matching. Each HTTP method has its own tree instance:

```
TUriRouterTree = array[urmGet .. high(TUriRouterMethod)] of TUriTree;
```

**Performance characteristics** (from `TNetworkProtocols._TUriTree` benchmark):

| Operation | Speed | Average Time |
|-----------|-------|--------------|
| URI lookups | 25.7M/s | 37ns |
| URI static rewrites | 11.9M/s | 80ns |
| URI parametrized rewrites | 8.1M/s | 117ns |
| URI static execute | 10.4M/s | 91ns |
| URI parametrized execute | 5.8M/s | 162ns |

### Node Structure

Each route is stored in a `TUriTreeNode` containing:

```pascal
TUriTreeNodeData = record
  ToUri: RawUtf8;                      // Rewrite destination URI
  ToUriPosLen: TIntegerDynArray;       // Parameter positions/lengths
  ToUriErrorStatus: word;              // HTTP error code (e.g., 404)
  ToUriMethod: TUriRouterMethod;       // Target HTTP method after rewrite
  ToUriFlags: set of (tufHasParameters); // Internal flags
  ToUriStaticLen: cardinal;            // Size of static content
  Execute: TOnHttpServerRequest;       // Handler callback
  ExecuteOpaque: pointer;              // Custom context pointer
end;
```

### HTTP Methods

```pascal
TUriRouterMethod = (
  urmGet,
  urmPost,
  urmPut,
  urmDelete,
  urmOptions,
  urmHead,
  urmPatch
);
```

## 11.X.3. Basic Usage

### Initialization

Access the router through `THttpServerGeneric.Route`:

```pascal
uses
  mormot.net.server;

var
  Server: THttpAsyncServer;
begin
  Server := THttpAsyncServer.Create('8080', nil, nil, '', 4);

  // Router is automatically created on first access
  Server.Route.Get('/plaintext', DoPlainText);
  Server.Route.Post('/api/users', DoCreateUser);
end;
```

### Static Routes

Register simple, fixed-path handlers:

```pascal
function DoPlainText(Ctxt: THttpServerRequestAbstract): cardinal;
begin
  Ctxt.OutContent := 'Hello, World!';
  Ctxt.OutContentType := TEXT_CONTENT_TYPE;
  result := HTTP_SUCCESS;
end;

// Registration
Server.Route.Get('/plaintext', DoPlainText);
Server.Route.Get('/json', DoJsonResponse);
Server.Route.Post('/api/submit', DoSubmit);
```

### Parametrized Routes

Extract values from URI patterns using `<param>` placeholders:

```pascal
function DoUserPic(Ctxt: THttpServerRequestAbstract): cardinal;
var
  user, picId: RawUtf8;
begin
  // Extract parameters from URI
  user := Ctxt['user'];     // Default property access
  picId := Ctxt['id'];

  // Process request
  Ctxt.OutContent := FormatUtf8('User: %, Picture: %', [user, picId]);
  result := HTTP_SUCCESS;
end;

// Registration
Server.Route.Get('/user/<user>/pic/<id>', DoUserPic);

// Matches:
//   /user/john/pic/123  → user='john', id='123'
//   /user/alice/pic/456 → user='alice', id='456'
```

### Type-Safe Parameters

Use typed placeholders to validate parameter format before routing:

```pascal
// Only match if 'id' is a valid integer
Server.Route.Get('/user/<int:id>', DoUserById);

// Match any path (useful for file serving)
Server.Route.Get('/static/<path:filepath>', DoStaticFile);
```

**Available types**:

- `<param>` - Any non-empty string (default)
- `<int:param>` - Integer value
- `<path:param>` - Path with slashes (greedy match)

### Accessing Parameters

```pascal
function DoUserById(Ctxt: THttpServerRequestAbstract): cardinal;
var
  userId: Int64;
  userName: RawUtf8;
begin
  // Type-safe integer extraction
  if Ctxt.RouteInt64('id', userId) then
  begin
    // userId is now a valid Int64
    userName := GetUserName(userId);
    Ctxt.OutContent := FormatUtf8('{"user":"%"}', [userName]);
    result := HTTP_SUCCESS;
  end
  else
    result := HTTP_BADREQUEST;
end;
```

**Parameter access methods**:

```pascal
// Default property (returns RawUtf8)
value := Ctxt['param'];

// Type-safe extraction
if Ctxt.RouteInt64('id', int64Value) then ...
if Ctxt.RouteEquals('status', 'active') then ...

// Access custom opaque pointer
customData := Ctxt.RouteOpaque;
```

## 11.X.4. URI Rewriting

Transform URIs before processing without changing client-visible URLs:

### Basic Rewriting

```pascal
// Rewrite /info to internal handler path
Server.Route.Rewrite(urmGet, '/info', urmGet, '/root/timestamp/info');

// User-friendly URL → Internal service endpoint
Server.Route.Rewrite(
  urmGet, '/path/from/<from>/to/<to>',
  urmPost, '/root/myservice/convert?from=<from>&to=<to>'
);

// Example:
//   Client: GET /path/from/USD/to/EUR
//   Server processes: POST /root/myservice/convert?from=USD&to=EUR
```

### Wildcard Rewriting

Use `*` (synonym for `<path:path>`) for catch-all routes:

```pascal
// Serve static files
Server.Route.Get('/*', '/static/*');

// Example:
//   GET /css/style.css  → /static/css/style.css
//   GET /js/app.js      → /static/js/app.js
```

### Error Code Rewriting

Return HTTP error codes for specific URIs (useful for blocking attacks):

```pascal
// Block common vulnerability scanners
Server.Route.Rewrite(urmGet, '/admin.php', urmGet, '403');
Server.Route.Rewrite(urmGet, '/index.php', urmGet, '400');
Server.Route.Rewrite(urmPost, '/.env', urmPost, '404');
```

## 11.X.5. Advanced Registration

### Multiple Methods

Register the same handler for multiple HTTP methods:

```pascal
function DoCrud(Ctxt: THttpServerRequestAbstract): cardinal;
begin
  case Ctxt.Method of
    'GET': result := DoRetrieve(Ctxt);
    'POST': result := DoCreate(Ctxt);
    'PUT': result := DoUpdate(Ctxt);
    'DELETE': result := DoDelete(Ctxt);
  else
    result := HTTP_NOTALLOWED;
  end;
end;

// Register for all CRUD operations
Server.Route.Run(
  [urmGet, urmPost, urmPut, urmDelete],
  '/user/<user>/pic/<id>',
  DoCrud
);
```

### RTTI-Based Registration

Automatically register published methods as routes:

```pascal
type
  TMyApiController = class
  published
    function users(Ctxt: THttpServerRequestAbstract): cardinal;
    function cached_query(Ctxt: THttpServerRequestAbstract): cardinal;
    function api_status(Ctxt: THttpServerRequestAbstract): cardinal;
  end;

var
  Controller: TMyApiController;
begin
  Controller := TMyApiController.Create;

  // Register all published methods as GET routes
  // Method names become URIs (exact case, _ → -)
  Server.Route.RunMethods([urmGet], Controller, '/api/');

  // Creates routes:
  //   GET /api/users
  //   GET /api/cached-query
  //   GET /api/api-status
end;
```

### Custom Context (ExecuteOpaque)

Pass additional context to handlers:

```pascal
type
  TApiContext = record
    Database: TOrmClient;
    Logger: TSynLog;
  end;

var
  Context: TApiContext;
begin
  Context.Database := CreateOrmClient;
  Context.Logger := CreateLogger;

  // Pass context pointer to handler
  Server.Route.Get('/api/data', DoGetData, @Context);
end;

function DoGetData(Ctxt: THttpServerRequestAbstract): cardinal;
var
  ApiCtx: ^TApiContext;
begin
  // Retrieve custom context
  ApiCtx := Ctxt.RouteOpaque;

  // Use context
  ApiCtx^.Logger.Log(sllDebug, 'Processing data request');
  result := ApiCtx^.Database.Retrieve(...);
end;
```

## 11.X.6. Route Inspection and Management

### Lookup Routes

Check if a URI matches any registered route:

```pascal
var
  Node: TUriTreeNode;
begin
  // Fast lookup (thread-safe)
  Node := Server.Router.Lookup('/user/123', 'GET');

  if Node <> nil then
    WriteLn('Route found: ', Node.FullText)
  else
    WriteLn('No route matches');
end;
```

### Route Statistics

Access registration counts via published properties:

```pascal
WriteLn('GET routes: ', Server.Router.Gets);
WriteLn('POST routes: ', Server.Router.Posts);
WriteLn('PUT routes: ', Server.Router.Puts);
WriteLn('DELETE routes: ', Server.Router.Deletes);
WriteLn('PATCH routes: ', Server.Router.Patchs);
WriteLn('HEAD routes: ', Server.Router.Heads);
WriteLn('OPTIONS routes: ', Server.Router.Optionss);
```

### Clear Routes

Remove routes dynamically (requires re-registration):

```pascal
// Clear all routes
Server.Router.Clear;

// Clear specific HTTP methods
Server.Router.Clear([urmGet, urmPost]);

// Re-register routes
Server.Route.Get('/new-endpoint', DoNewHandler);
```

> **Note**: Individual routes cannot be deleted once registered. Use `Clear()` followed by re-registration to modify the routing table.

## 11.X.7. Integration with HTTP Server

### Process Flow

The router integrates seamlessly with `THttpServerGeneric`:

```
1. Client request arrives → THttpServerRequest.Prepare()
2. Router.Process(Ctxt) called
   ├─ Parse HTTP method → Select appropriate TUriTree
   ├─ Radix tree lookup → Find matching TUriTreeNode
   ├─ Extract parameters → Store in Ctxt['param']
   └─ Execute handler or rewrite URI
3. If handler executed → Return HTTP status code
4. If URI rewritten → Continue to OnRequest handler
5. Generate response
```

### Custom Router Node Class

Override the default `TUriTreeNode` implementation:

```pascal
type
  TMyCustomUriNode = class(TUriTreeNode)
  protected
    function LookupParam(Ctxt: TObject; Pos: PUtf8Char; Len: integer): boolean; override;
  end;

var
  Server: THttpAsyncServer;
begin
  Server := THttpAsyncServer.Create('8080', nil, nil, '', 4);

  // Set custom node class BEFORE accessing Route
  Server.RouterClass := TMyCustomUriNode;

  // Now routing uses custom node implementation
  Server.Route.Get('/custom', DoCustom);
end;
```

### Replace Router Dynamically

Swap the entire routing table at runtime:

```pascal
var
  OldRouter, NewRouter: TUriRouter;
begin
  // Create new router with updated routes
  NewRouter := TUriRouter.Create(TUriTreeNode);
  NewRouter.Get('/v2/api', DoNewApi);

  // Atomic replacement (thread-safe)
  OldRouter := Server.ReplaceRoute(NewRouter);

  // Keep old router alive briefly for pending requests
  Sleep(5000);
  OldRouter.Free;
end;
```

## 11.X.8. Real-World Example: REST API

Complete example of a REST API with advanced routing:

```pascal
uses
  mormot.core.base,
  mormot.core.json,
  mormot.net.server,
  mormot.net.async;

type
  TApiServer = class
  private
    fServer: THttpAsyncServer;
    fDatabase: TOrmClient;

    // API handlers
    function GetUser(Ctxt: THttpServerRequestAbstract): cardinal;
    function CreateUser(Ctxt: THttpServerRequestAbstract): cardinal;
    function UpdateUser(Ctxt: THttpServerRequestAbstract): cardinal;
    function DeleteUser(Ctxt: THttpServerRequestAbstract): cardinal;
    function GetUserOrders(Ctxt: THttpServerRequestAbstract): cardinal;
    function HealthCheck(Ctxt: THttpServerRequestAbstract): cardinal;
  public
    constructor Create(const Port: RawUtf8);
    destructor Destroy; override;
  end;

constructor TApiServer.Create(const Port: RawUtf8);
begin
  // Initialize database
  fDatabase := CreateOrmClient;

  // Create async HTTP server
  fServer := THttpAsyncServer.Create(Port, nil, nil, '', 4);

  // Register routes with the router
  with fServer.Route do
  begin
    // Static routes
    Get('/health', HealthCheck);
    Get('/api/v1/status', HealthCheck);

    // RESTful user endpoints
    Get('/api/v1/users/<int:id>', GetUser);
    Post('/api/v1/users', CreateUser);
    Put('/api/v1/users/<int:id>', UpdateUser);
    Delete('/api/v1/users/<int:id>', DeleteUser);

    // Nested resources
    Get('/api/v1/users/<int:id>/orders', GetUserOrders);

    // URI rewriting for backward compatibility
    Rewrite(urmGet, '/v1/user/<id>', urmGet, '/api/v1/users/<id>');

    // Block unwanted requests
    Get('/admin.php', '403');
    Get('/.env', '404');

    // Catch-all for 404
    Get('/*', DoNotFound);
  end;
end;

destructor TApiServer.Destroy;
begin
  fServer.Free;
  fDatabase.Free;
  inherited;
end;

function TApiServer.GetUser(Ctxt: THttpServerRequestAbstract): cardinal;
var
  userId: Int64;
  user: TOrmUser;
begin
  // Extract and validate user ID
  if not Ctxt.RouteInt64('id', userId) then
  begin
    Ctxt.OutContent := '{"error":"Invalid user ID"}';
    result := HTTP_BADREQUEST;
    exit;
  end;

  // Retrieve from database
  user := TOrmUser.Create(fDatabase, userId);
  try
    if user.ID = 0 then
    begin
      Ctxt.OutContent := '{"error":"User not found"}';
      result := HTTP_NOTFOUND;
    end
    else
    begin
      Ctxt.OutContent := user.GetJsonValues(true, true, soReadableCompact);
      Ctxt.OutContentType := JSON_CONTENT_TYPE;
      result := HTTP_SUCCESS;
    end;
  finally
    user.Free;
  end;
end;

function TApiServer.CreateUser(Ctxt: THttpServerRequestAbstract): cardinal;
var
  user: TOrmUser;
begin
  // Parse JSON body
  user := TOrmUser.CreateAndFillPrepare(fDatabase, '', Ctxt.InContent);
  try
    // Validate and insert
    if fDatabase.Add(user, true) <> 0 then
    begin
      Ctxt.OutContent := FormatUtf8('{"id":%}', [user.ID]);
      Ctxt.OutContentType := JSON_CONTENT_TYPE;
      result := HTTP_CREATED;
    end
    else
    begin
      Ctxt.OutContent := '{"error":"Failed to create user"}';
      result := HTTP_SERVERERROR;
    end;
  finally
    user.Free;
  end;
end;

function TApiServer.GetUserOrders(Ctxt: THttpServerRequestAbstract): cardinal;
var
  userId: Int64;
  orders: TOrmOrders;
begin
  if not Ctxt.RouteInt64('id', userId) then
  begin
    result := HTTP_BADREQUEST;
    exit;
  end;

  // Retrieve all orders for user
  orders := TOrmOrders.CreateAndFillPrepare(fDatabase,
    'UserID=?', [userId]);
  try
    Ctxt.OutContent := orders.GetJsonValues(true);
    Ctxt.OutContentType := JSON_CONTENT_TYPE;
    result := HTTP_SUCCESS;
  finally
    orders.Free;
  end;
end;

function TApiServer.HealthCheck(Ctxt: THttpServerRequestAbstract): cardinal;
begin
  Ctxt.OutContent := '{"status":"ok","timestamp":"' +
    DateTimeToIso8601Text(NowUtc) + '"}';
  Ctxt.OutContentType := JSON_CONTENT_TYPE;
  result := HTTP_SUCCESS;
end;

// Usage
var
  Api: TApiServer;
begin
  Api := TApiServer.Create('8080');
  try
    WriteLn('REST API server running on port 8080');
    WriteLn('Routes registered:');
    WriteLn('  GET routes: ', Api.fServer.Router.Gets);
    WriteLn('  POST routes: ', Api.fServer.Router.Posts);
    WriteLn('  PUT routes: ', Api.fServer.Router.Puts);
    WriteLn('  DELETE routes: ', Api.fServer.Router.Deletes);
    ReadLn;
  finally
    Api.Free;
  end;
end.
```

## 11.X.9. Performance Considerations

### Zero-Allocation Static Routes

Static routes (without parameters) perform **zero heap allocations** during request processing:

```pascal
// Zero-allocation routing
Server.Route.Get('/plaintext', DoPlainText);
Server.Route.Get('/health', DoHealth);

// Benchmark results:
//   10.4M requests/second
//   91ns average latency
```

### Parametrized Route Overhead

Parametrized routes require minimal allocations for parameter extraction:

```pascal
// Minimal allocation routing
Server.Route.Get('/user/<id>', DoUser);

// Benchmark results:
//   5.8M requests/second
//   162ns average latency
```

### Thread Safety

`TUriRouter` uses `TObjectRWLightLock` for efficient concurrent access:

- **Read locks** during `Process()` (frequent, multiple threads)
- **Write locks** during registration (rare, setup phase)
- **Lock-free lookups** for static routes (no parameter extraction)

### Benchmarking

From `TNetworkProtocols._TUriTree` test suite:

```pascal
// 1000 URI lookups in 37µs → 25.7M/s (37ns avg)
// 1000 URI static rewrites in 80µs → 11.9M/s (80ns avg)
// 1000 URI parametrized rewrites in 117µs → 8.1M/s (117ns avg)
// 1000 URI static execute in 91µs → 10.4M/s (91ns avg)
// 1000 URI parametrized execute in 162µs → 5.8M/s (162ns avg)
```

## 11.X.10. Best Practices

### Route Organization

```pascal
// Group routes by resource
with Server.Route do
begin
  // Users
  Get('/api/users', ListUsers);
  Post('/api/users', CreateUser);
  Get('/api/users/<int:id>', GetUser);
  Put('/api/users/<int:id>', UpdateUser);
  Delete('/api/users/<int:id>', DeleteUser);

  // Orders
  Get('/api/orders', ListOrders);
  Post('/api/orders', CreateOrder);
  Get('/api/orders/<int:id>', GetOrder);

  // Nested resources
  Get('/api/users/<int:userId>/orders', GetUserOrders);
end;
```

### Parameter Validation

Always validate extracted parameters:

```pascal
function DoGetUser(Ctxt: THttpServerRequestAbstract): cardinal;
var
  userId: Int64;
begin
  // Type-safe extraction with validation
  if not Ctxt.RouteInt64('id', userId) or (userId <= 0) then
  begin
    result := HTTP_BADREQUEST;
    exit;
  end;

  // Continue with valid userId
  ...
end;
```

### Error Handling

Block unwanted routes explicitly:

```pascal
// Security: block common attack vectors
Server.Route.Get('/admin.php', '403');
Server.Route.Get('/.env', '404');
Server.Route.Get('/phpMyAdmin/*', '404');
Server.Route.Post('/xmlrpc.php', '403');
```

### Route Prefixing

Use consistent API versioning:

```pascal
with Server.Route do
begin
  // Version 1 API
  Get('/api/v1/users', DoUsers_V1);

  // Version 2 API
  Get('/api/v2/users', DoUsers_V2);

  // Rewrite for backward compatibility
  Rewrite(urmGet, '/users', urmGet, '/api/v1/users');
end;
```

### Testing Routes

```pascal
// Lookup routes for testing
procedure TestRoutes;
var
  Node: TUriTreeNode;
begin
  // Verify route exists
  Node := Server.Router.Lookup('/api/users/123', 'GET');
  Assert(Node <> nil, 'GET /api/users/<id> not registered');

  // Verify route count
  Assert(Server.Router.Gets >= 10, 'Expected at least 10 GET routes');
end;
```

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Chapter 11: HTTP/HTTPS Server](mORMot2-SAD-Chapter-11.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 12: ...](mORMot2-SAD-Chapter-12.md) |
