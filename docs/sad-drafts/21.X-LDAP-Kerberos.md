# 21.X. Enterprise Authentication

*Secure Integration with Active Directory and Kerberos*

mORMot 2 provides comprehensive support for enterprise authentication mechanisms, enabling seamless integration with Active Directory (LDAP v3) and Kerberos infrastructure. This section covers the native LDAP client implementation and Kerberos-based authentication patterns for both server-side and client-side scenarios.

---

## 21.X.1. LDAP v3 Client

### Overview

The `mormot.net.ldap` unit provides a complete LDAP (Lightweight Directory Access Protocol) version 3 client implementation, designed for integration with Active Directory and other LDAP servers.

**Key Features:**

- **LDAP v3 Protocol**: Full support for RFC-compliant LDAP operations
- **Active Directory Integration**: Native support for AD-specific features
- **Transport Security**: TLS encryption for secure credential transmission
- **SASL Authentication**: DIGEST-MD5, GSSAPI (Kerberos), and EXTERNAL mechanisms
- **Connection Discovery**: Automatic LDAP controller discovery via CLDAP
- **Paged Results**: Handle large result sets efficiently
- **Thread-Safe Design**: Use `Lock()`/`UnLock()` for shared connections

### TLdapClient Class

The `TLdapClient` class provides the main interface for LDAP operations:

```pascal
uses
  mormot.net.ldap;

var
  ldap: TLdapClient;
begin
  ldap := TLdapClient.Create;
  try
    // Connect to default LDAP server (auto-discovered)
    if ldap.Connect then
    begin
      // Bind with username/password
      ldap.Settings.UserName := 'jsmith';
      ldap.Settings.Password := 'secret123';
      if ldap.Bind then
      begin
        // Perform LDAP operations
        if ldap.Search(ldap.DefaultDN, false, '(cn=John Smith)', ['mail']) then
          WriteLn('Email: ', ldap.SearchResult[0].Attributes[0].Value);
      end;
      ldap.Close;
    end;
  finally
    ldap.Free;
  end;
end;
```

### Connection Methods

**Automatic Discovery:**

```pascal
// Connect to the default domain controller
ldap.Connect;  // Uses CLDAP to find the best controller

// Connect to a specific LDAP server
ldap.Settings.TargetHost := 'dc1.domain.com';
ldap.Settings.TargetPort := '389';
ldap.Connect;

// Connect with TLS encryption
ldap.Settings.TargetPort := '636';
ldap.Settings.FullTls := true;
ldap.Connect;
```

**Connection Discovery Modes:**

- `lccCldap`: Use CLDAP NetLogon protocol for discovery (default)
- `lccTlsFirst`: Prefer TLS-enabled controllers
- `lccKerberos`: Use Kerberos for authentication

### Authentication Methods

**Simple Bind (Username/Password):**

```pascal
ldap.Settings.UserName := 'user@domain.com';
ldap.Settings.Password := 'password';
if ldap.Bind then
  WriteLn('Authenticated successfully');
```

> **Warning**: Simple bind transmits credentials in cleartext unless TLS is enabled. Set `Settings.AllowUnsafePasswordBind := true` to override the safety check.

**SASL DIGEST-MD5:**

```pascal
// Safer than simple bind on non-TLS connections
if ldap.BindSaslDigest(daMD5_Sess) then
  WriteLn('Authenticated via DIGEST-MD5');
```

**SASL Kerberos (GSSAPI):**

```pascal
// Authenticate using current user's Kerberos ticket
if ldap.BindSaslKerberos then
  WriteLn('Authenticated via Kerberos');

// Authenticate with specific credentials
ldap.Settings.UserName := 'user@DOMAIN.COM';
ldap.Settings.Password := 'password';
if ldap.BindSaslKerberos('LDAP/dc1.domain.com@DOMAIN.COM') then
  WriteLn('Authenticated via Kerberos with explicit SPN');
```

### Search Operations

**Basic Search:**

```pascal
// Search for all users in the default naming context
if ldap.Search(ldap.DefaultDN, false, '(objectClass=user)', ['cn', 'mail']) then
begin
  for i := 0 to high(ldap.SearchResult) do
    WriteLn(ldap.SearchResult[i].ObjectName);
end;
```

**Paged Search:**

```pascal
// Handle large result sets with pagination
ldap.SearchBegin(1000);  // 1000 entries per page
repeat
  if ldap.Search(ldap.DefaultDN, false, '(objectClass=user)', ['cn']) then
  begin
    // Process current page
    ProcessResults(ldap.SearchResult);
  end;
until ldap.SearchCookie = '';  // No more pages
ldap.SearchEnd;
```

**High-Level Search (All Results):**

```pascal
// Retrieve all results automatically (handles pagination internally)
var
  results: variant;
begin
  results := ldap.SearchAllRaw(ldap.DefaultDN, '(objectClass=group)',
                               ['cn', 'member'], [roAutoRange]);
  // Returns TDocVariant with all results
end;
```

### Root DSE Information

The Root DSE (Directory Server Entry) provides server capabilities:

```pascal
WriteLn('Domain: ', ldap.DefaultDN);
WriteLn('Root Domain: ', ldap.RootDN);
WriteLn('Config DN: ', ldap.ConfigDN);
WriteLn('Schema DN: ', ldap.SchemaDN);
WriteLn('Vendor: ', ldap.VendorName);

// Check supported mechanisms
if ldap.SupportsMech('GSSAPI') then
  WriteLn('Kerberos authentication is available');

// Check supported controls
if ldap.SupportsControl('1.2.840.113556.1.4.319') then
  WriteLn('Paged results are supported');
```

### TLdapClientSettings

Configuration for LDAP connections is managed through `TLdapClientSettings`:

```pascal
ldap.Settings.TargetHost := 'dc1.domain.com';
ldap.Settings.TargetPort := '389';
ldap.Settings.UserName := 'user@domain.com';
ldap.Settings.Password := 'secret';
ldap.Settings.FullTls := false;           // Use STARTTLS instead of LDAPS
ldap.Settings.Timeout := 5000;            // 5 second timeout
ldap.Settings.AutoReconnect := true;      // Auto-reconnect on disconnect
ldap.Settings.KerberosDN := 'DOMAIN.COM'; // Kerberos realm
```

---

## 21.X.2. HTTP BASIC Authentication via LDAP

### TBasicAuthServerLdap

The `TBasicAuthServerLdap` class provides HTTP BASIC authentication backed by LDAP, ideal for REST services requiring Active Directory integration:

```pascal
uses
  mormot.net.ldap,
  mormot.rest.http.server;

var
  ldapAuth: TBasicAuthServerLdap;
  server: TRestHttpServer;
begin
  // Create LDAP authentication provider
  ldapAuth := TBasicAuthServerLdap.Create('ldap://dc1.domain.com',
                                          'domain.com',
                                          5 * 60);  // 5 minute cache

  // Attach to HTTP server
  server := TRestHttpServer.Create('8080', [restModel], '+', useHttpSocket);
  server.OnBasicAuth := ldapAuth.CheckCredential;
end;
```

**Features:**

- **Credential Caching**: Valid credentials are cached as SHA3-256 hashes
- **Cache Timeout**: Configurable timeout (default 5 minutes)
- **Auto-Discovery**: Finds default LDAP controller if no URI provided
- **TLS Support**: Enforces secure transmission for credentials

**Custom LDAP Settings:**

```pascal
var
  settings: TLdapClientSettings;
  ldapAuth: TBasicAuthServerLdap;
begin
  settings := TLdapClientSettings.Create;
  settings.TargetHost := 'dc1.domain.com';
  settings.TargetPort := '636';
  settings.FullTls := true;

  // Settings ownership transferred to ldapAuth
  ldapAuth := TBasicAuthServerLdap.Create('domain.com', settings, 60 * 60);
end;
```

### Search and Bind Pattern

Use `TLdapCheckMember` to implement "search and bind" authentication with group membership validation:

```pascal
var
  ldapAuth: TBasicAuthServerLdap;
  checkMember: TLdapCheckMember;
begin
  ldapAuth := TBasicAuthServerLdap.Create;

  // Create group membership checker
  checkMember := TLdapCheckMember.Create;
  checkMember.LdapSettings := ldapAuth.LdapSettings;
  checkMember.AllowGroupByName(['Domain Admins', 'App Users']);

  // Attach to authentication provider (ownership transferred)
  ldapAuth.CheckMember := checkMember;
end;
```

**How It Works:**

1. User submits credentials via HTTP BASIC authentication
2. `TBasicAuthServerLdap` searches LDAP for the user DN
3. Binds to LDAP using the user's credentials (validates password)
4. If `CheckMember` is set, verifies group membership
5. Caches valid credentials for subsequent requests

---

## 21.X.3. Kerberos KeyTab Support

### Overview

mORMot 2 includes native Kerberos KeyTab file support, essential for Linux/Docker deployments where services need to authenticate without interactive password prompts.

**Use Cases:**

- **Linux Services**: Authenticate to AD from Linux servers
- **Docker Containers**: Non-interactive Kerberos authentication
- **Service Accounts**: Machine account credential storage
- **Cross-Platform Deployment**: Windows/Linux/macOS support

### TKerberosKeyTab Class

Read and manage existing KeyTab files:

```pascal
uses
  mormot.core.os.security;

var
  keytab: TKerberosKeyTab;
begin
  keytab := TKerberosKeyTab.Create;
  try
    // Load from file
    if keytab.LoadFromFile('/etc/krb5.keytab') then
    begin
      WriteLn('Loaded ', Length(keytab.Entry), ' entries');

      // Inspect entries
      for i := 0 to high(keytab.Entry) do
        with keytab.Entry[i] do
          WriteLn('Principal: ', Principal,
                  ' EncType: ', ENCTYPE_TEXT[EncType],
                  ' Version: ', KeyVersion);
    end;
  finally
    keytab.Free;
  end;
end;
```

**Key Operations:**

```pascal
// Load from binary buffer
keytab.LoadFromBinary(binaryData);

// Check for specific entry
if keytab.Exists(entry) then
  WriteLn('Entry already exists');

// Merge from another KeyTab
keytab.AddFromFile('/tmp/additional.keytab', ['HTTP/web.domain.com']);

// Save to file
keytab.SaveToFile('/etc/krb5.keytab');

// Remove an entry
keytab.Delete(0);
```

### TKerberosKeyTabGenerator

Generate KeyTab files programmatically from credentials:

```pascal
uses
  mormot.crypt.secure;

var
  gen: TKerberosKeyTabGenerator;
begin
  gen := TKerberosKeyTabGenerator.Create;
  try
    // Add service principal
    gen.AddNew('HTTP/web.domain.com@DOMAIN.COM', 'ServicePassword123');

    // Add user principal
    gen.AddNew('user@DOMAIN.COM', 'UserPassword456', false);

    // Add computer account (note the $ suffix and special handling)
    gen.AddNew('WEBSERVER$@DOMAIN.COM', 'MachinePassword', true);

    // Add with custom encryption type
    gen.AddNew('ldap/server.domain.com@DOMAIN.COM', 'LdapPassword',
               false, '', ENCTYPE_AES256_CTS_HMAC_SHA1_96);

    // Save to file
    gen.SaveToFile('/etc/krb5.keytab');
  finally
    gen.Free;
  end;
end;
```

**Encryption Types:**

```pascal
// Supported Kerberos encryption types (from strongest to weakest)
ENCTYPE_AES256_CTS_HMAC_SHA1_96    // AES-256 (recommended)
ENCTYPE_AES128_CTS_HMAC_SHA1_96    // AES-128
ENCTYPE_AES256_CTS_HMAC_SHA384_192 // AES-256 with SHA-384
ENCTYPE_AES128_CTS_HMAC_SHA256_128 // AES-128 with SHA-256
```

### Linux/Docker Integration

**Generate KeyTab for Service:**

```pascal
// Generate KeyTab for a web service running in Docker
procedure GenerateServiceKeyTab(const ServiceName, Password, Realm: RawUtf8;
  const OutputFile: TFileName);
var
  gen: TKerberosKeyTabGenerator;
  principal: RawUtf8;
begin
  gen := TKerberosKeyTabGenerator.Create;
  try
    // Construct principal: service/hostname@REALM
    principal := FormatUtf8('%/%@%', [ServiceName, GetHostName, UpperCase(Realm)]);

    // Add entries for both AES-256 and AES-128 (for compatibility)
    gen.AddNew(principal, Password, false, '', ENCTYPE_AES256_CTS_HMAC_SHA1_96);
    gen.AddNew(principal, Password, false, '', ENCTYPE_AES128_CTS_HMAC_SHA1_96);

    gen.SaveToFile(OutputFile);
    WriteLn('KeyTab saved to: ', OutputFile);
  finally
    gen.Free;
  end;
end;

// Usage
GenerateServiceKeyTab('HTTP', 'ServicePass123', 'DOMAIN.COM', '/etc/krb5.keytab');
```

**Docker Deployment Example:**

```bash
# 1. Generate KeyTab in Delphi application
./mygenerator --service=myapp --password=<secret> --realm=DOMAIN.COM \
  --output=/docker/secrets/krb5.keytab

# 2. Mount in Docker container
docker run -v /docker/secrets:/etc/secrets:ro \
  -e KRB5_KTNAME=/etc/secrets/krb5.keytab \
  myapp:latest

# 3. Application uses KeyTab for Kerberos authentication
# (via GSSAPI with FILE:/etc/secrets/krb5.keytab)
```

---

## 21.X.4. HTTP BASIC Authentication via Kerberos

### TBasicAuthServerKerberos

The `TBasicAuthServerKerberos` class provides HTTP BASIC authentication backed by Kerberos (SSPI on Windows, GSSAPI on Linux), ideal for enterprise environments with Active Directory:

```pascal
uses
  mormot.net.ldap,
  mormot.rest.http.server;

var
  krbAuth: TBasicAuthServerKerberos;
  server: TRestHttpServer;
begin
  // Create Kerberos authentication provider
  krbAuth := TBasicAuthServerKerberos.Create('LDAP/dc1.domain.com@DOMAIN.COM',
                                             'domain.com',
                                             5 * 60);  // 5 minute cache

  // Attach to HTTP server
  server := TRestHttpServer.Create('8080', [restModel], '+', useHttpSocket);
  server.OnBasicAuth := krbAuth.CheckCredential;
end;
```

**Features:**

- **Cross-Platform**: Uses SSPI on Windows, GSSAPI on Linux/macOS
- **Credential Caching**: SHA3-256 hashed cache for performance
- **Group Authorization**: Windows-only group membership validation
- **No LDAP Required**: Direct Kerberos KDC authentication
- **Service Principal**: Configurable SPN for validation

### Auto-Discovery

If no SPN is provided, the controller is auto-discovered:

```pascal
// Automatically finds default LDAP controller and constructs SPN
krbAuth := TBasicAuthServerKerberos.Create;
// SPN will be e.g. 'LDAP/dc1.domain.com@DOMAIN.COM'
```

### Group-Based Authorization (Windows)

Restrict access to specific Active Directory groups:

```pascal
var
  krbAuth: TBasicAuthServerKerberos;
begin
  krbAuth := TBasicAuthServerKerberos.Create;

  // Allow only users in specific groups (by SID)
  krbAuth.AllowGroupBySid([
    'S-1-5-21-1234567890-1234567890-1234567890-512',  // Domain Admins
    'S-1-5-21-1234567890-1234567890-1234567890-1001'  // App Admins
  ]);

  // Or use CSV format
  krbAuth.AllowGroupBySid('S-1-5-21-...-512,S-1-5-21-...-1001');
end;
```

**How It Works:**

1. User submits credentials via HTTP BASIC authentication
2. `TBasicAuthServerKerberos` validates credentials against KDC via SSPI/GSSAPI
3. On Windows, extracts user's group SIDs from Kerberos token
4. If `AllowGroupBySid` is configured, checks group membership
5. Caches valid credentials for subsequent requests

### Cross-Platform Comparison

| Feature | Windows (SSPI) | Linux (GSSAPI) |
|---------|----------------|----------------|
| Authentication | via KDC | via KDC |
| Group Validation | via Token SIDs | Requires TLdapCheckMember |
| KeyTab Support | Optional | Required for services |
| Current User Auth | Automatic | Requires ticket cache |

**Linux Example with KeyTab:**

```pascal
// Linux service using KeyTab for authentication
var
  krbAuth: TBasicAuthServerKerberos;
  checkMember: TLdapCheckMember;
begin
  // Set KeyTab environment variable (or configure /etc/krb5.conf)
  SetEnvironmentVariable('KRB5_KTNAME', 'FILE:/etc/krb5.keytab');

  krbAuth := TBasicAuthServerKerberos.Create('HTTP/web.domain.com@DOMAIN.COM',
                                             'domain.com', 5 * 60);

  // Add LDAP group checking (GSSAPI doesn't provide group info)
  checkMember := TLdapCheckMember.Create;
  checkMember.AllowGroupByName(['App Users', 'Domain Admins']);
  krbAuth.CheckMember := checkMember;  // Ownership transferred
end;
```

---

## 21.X.5. Comparison: LDAP vs Kerberos Authentication

| Aspect | TBasicAuthServerLdap | TBasicAuthServerKerberos |
|--------|----------------------|--------------------------|
| **Protocol** | LDAP v3 bind | Kerberos (SSPI/GSSAPI) |
| **Network** | Requires LDAP server | Requires KDC access |
| **Security** | Password-based (needs TLS) | Ticket-based (encrypted) |
| **Caching** | SHA3-256 credential hash | SHA3-256 credential hash |
| **Groups** | via TLdapCheckMember | Windows: token SIDs / Linux: TLdapCheckMember |
| **Setup** | Minimal (just LDAP URI) | Requires SPN registration |
| **Linux Support** | Full support | Requires KeyTab for services |
| **Performance** | Direct LDAP bind | KDC ticket validation |

**When to Use LDAP:**

- Server is outside the domain
- Simple username/password authentication
- No Kerberos infrastructure available
- Need LDAP directory information

**When to Use Kerberos:**

- Server is domain-joined or has SPN
- Single Sign-On (SSO) support needed
- Maximum security required
- Windows group-based authorization

---

## 21.X.6. Complete Example: Multi-Tier Authentication

```pascal
uses
  mormot.core.base,
  mormot.net.ldap,
  mormot.rest.core,
  mormot.rest.http.server;

type
  TMyAuthServer = class
  private
    fLdapAuth: TBasicAuthServerLdap;
    fKerberosAuth: TBasicAuthServerKerberos;
    fRestServer: TRestHttpServer;
  public
    constructor Create;
    destructor Destroy; override;
    function OnBasicAuth(const aUser: RawUtf8;
      const aPassword: SpiUtf8): TAuthServerResult;
  end;

constructor TMyAuthServer.Create;
begin
  // Try Kerberos first (for domain users)
  try
    fKerberosAuth := TBasicAuthServerKerberos.Create;
    WriteLn('Kerberos authentication enabled');
  except
    on E: Exception do
      WriteLn('Kerberos unavailable: ', E.Message);
  end;

  // Fallback to LDAP (for external users)
  fLdapAuth := TBasicAuthServerLdap.Create('ldap://dc1.domain.com',
                                           'domain.com', 10 * 60);
  WriteLn('LDAP authentication enabled');

  // Create REST server
  fRestServer := TRestHttpServer.Create('8080', [restModel], '+', useHttpSocket);
  fRestServer.OnBasicAuth := OnBasicAuth;
end;

destructor TMyAuthServer.Destroy;
begin
  fRestServer.Free;
  fLdapAuth.Free;
  fKerberosAuth.Free;
  inherited;
end;

function TMyAuthServer.OnBasicAuth(const aUser: RawUtf8;
  const aPassword: SpiUtf8): TAuthServerResult;
begin
  // Try Kerberos first (faster, more secure)
  if fKerberosAuth <> nil then
  begin
    result := fKerberosAuth.CheckCredential(aUser, aPassword);
    if result = asrMatch then
      exit;
  end;

  // Fallback to LDAP
  result := fLdapAuth.CheckCredential(aUser, aPassword);
end;
```

---

## 21.X.7. Best Practices

### Security

- **Always use TLS** for LDAP connections when transmitting passwords
- **Cache credentials securely** using the built-in SHA3-256 hashing
- **Validate group membership** using `TLdapCheckMember` or `AllowGroupBySid`
- **Use Kerberos** when available for maximum security
- **Set appropriate cache timeouts** (balance security vs performance)

### Performance

- **Enable credential caching** to reduce authentication overhead
- **Use paged searches** for large result sets (`SearchBegin`/`SearchEnd`)
- **Reuse connections** with `Lock()`/`UnLock()` in multi-threaded scenarios
- **Configure auto-reconnect** for long-running services

### Linux/Docker Deployment

- **Generate KeyTab files** using `TKerberosKeyTabGenerator`
- **Use environment variables** (`KRB5_KTNAME`, `KRB5_CONFIG`)
- **Mount KeyTab as read-only** in Docker containers
- **Rotate KeyTab regularly** when passwords change
- **Use AES-256** encryption type when possible

### Error Handling

```pascal
if not ldap.Connect then
  raise ELdap.CreateUtf8('LDAP connection failed: % (%)',
    [ldap.ResultString, ToText(ldap.ResultError)^]);

if ldap.ResultError = leSizeLimitExceeded then
begin
  WriteLn('Too many results, enable pagination');
  ldap.SearchBegin(1000);
end;
```

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Chapter 21: Network Protocols](mORMot2-SAD-Chapter-21.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 22: Advanced Topics](mORMot2-SAD-Chapter-22.md) |
