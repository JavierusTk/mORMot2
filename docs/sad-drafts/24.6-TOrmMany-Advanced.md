# 24.6. TOrmMany Advanced API

*Master the Many-to-Many Pattern*

This section covers advanced usage patterns for `TOrmMany`, including SQL filtering, bidirectional navigation, batch operations, and performance optimization strategies.

---

## Overview

`TOrmMany` provides a rich API beyond basic `ManyAdd`/`ManyDelete` operations. Understanding these advanced methods enables efficient handling of complex many-to-many relationships with minimal database round-trips.

### Core Capabilities

- **SQL Filtering**: Apply WHERE conditions to pivot table queries
- **Bidirectional Navigation**: Query from Source→Dest or Dest→Source
- **FillMany Patterns**: Iterate through related records with "through" fields
- **Joined Queries**: Retrieve filtered destination records in single query
- **Batch Operations**: Use `TRestBatch` for bulk add/delete operations

---

## 24.6.1. FillMany Pattern

### Basic FillMany Usage

The `FillMany` method retrieves all destination records associated with a source, populating an internal `TOrmTable` for iteration:

```pascal
// Retrieve all destinations for a source
if Article.Tags.FillMany(Client, ArticleID) > 0 then
  while Article.Tags.FillOne do
  begin
    // Access pivot table fields
    TagID := Article.Tags.Dest;
    AddedDate := Article.Tags.AssociationTime;
    // Process each tag...
  end;
```

**Key Points**:
- Returns count of associated records (0 if none)
- Use `FillOne` to iterate (like `TOrm.FillPrepare`)
- Access pivot table "through" fields during iteration
- Use `FillRewind` to restart iteration

### FillMany with SQL Filtering

Apply additional WHERE conditions to filter pivot table records:

```pascal
// Only tags added in last 30 days
var
  WhereClause: RawUtf8;
begin
  WhereClause := FormatUtf8('AssociationTime>?', [], [Now - 30]);
  if Article.Tags.FillMany(Client, ArticleID, WhereClause) > 0 then
    while Article.Tags.FillOne do
      ShowMessage(Article.Tags.Dest);
end;
```

**Important**:
- Use inlined parameters (`?` syntax) for better performance and SQL cache
- Condition applies to pivot table fields (e.g., `AssociationTime`)
- Faster than `FillMany` + manual filtering in Pascal code

### FillManyFromDest (Reverse Navigation)

Query from destination to sources (bidirectional):

```pascal
// Find all articles with a specific tag
if Tag.Articles.FillManyFromDest(Client, TagID) > 0 then
  while Tag.Articles.FillOne do
  begin
    ArticleID := Tag.Articles.Source;
    // Process each article...
  end;
```

**Use Cases**:
- "Show all orders for this product"
- "Find all projects involving this employee"
- "List all articles with tag X"

---

## 24.6.2. Destination Retrieval Methods

### DestGet: Simple ID Retrieval

Retrieve only destination IDs (fastest method):

```pascal
var
  TagIDs: TIDDynArray;
begin
  if Article.Tags.DestGet(Client, ArticleID, TagIDs) then
    for i := 0 to High(TagIDs) do
      ProcessTag(TagIDs[i]);
end;
```

**Performance**: Fastest method when you only need IDs (single `OneFieldValues` call).

### DestGetJoined: Filtered Destination IDs

Retrieve destination IDs filtered by destination table fields:

```pascal
var
  TagIDs: TIDDynArray;
begin
  // Only tags with CategoryID = 10
  if Article.Tags.DestGetJoined(Client,
       'CategoryID=:(10):', ArticleID, TagIDs) then
    ShowCount(Length(TagIDs));
end;
```

**Key Features**:
- WHERE clause applies to **destination table** fields (not pivot)
- Faster than `FillMany` + filtering when you don't need pivot fields
- Executes single JOIN query on server

### DestGetJoined: Full Destination Records

Retrieve destination records (not just IDs) with filtering:

```pascal
var
  TagRecord: TOrm;
begin
  // Returns TOrmTag instance with FillPrepare
  TagRecord := Article.Tags.DestGetJoined(Client,
    'CategoryID=:(10):', ArticleID);
  if TagRecord <> nil then
  try
    while TagRecord.FillOne do
    begin
      Tag := TagRecord as TOrmTag;
      ProcessTag(Tag);
    end;
  finally
    TagRecord.Free;
  end;
end;
```

**Important**: You must free the returned `TOrm` instance.

### DestGetJoinedTable: Advanced Queries

Retrieve custom field combinations from pivot and destination tables:

```pascal
var
  Table: TOrmTable;
begin
  // Get both pivot and destination fields
  Table := Article.Tags.DestGetJoinedTable(Client,
    'CategoryID>:(5):', ArticleID, jkPivotAndDestFields);
  if Table <> nil then
  try
    for i := 0 to Table.RowCount - 1 do
    begin
      TagID := Table.GetAsInt64(i, 0);
      AssocTime := Table.GetAsDateTime(i, 1); // from pivot
      TagName := Table.GetAsString(i, 2);     // from dest
    end;
  finally
    Table.Free;
  end;
end;
```

**Join Kinds**:

| Kind | Fields Returned | Use Case |
|------|----------------|----------|
| `jkDestID` | Destination IDs only | Lightweight ID list |
| `jkPivotID` | Pivot table IDs | Manage pivot records |
| `jkDestFields` | Destination fields | Full destination data |
| `jkPivotFields` | Pivot fields | "Through" field analysis |
| `jkPivotAndDestFields` | Both pivot and dest | Complete relationship view |

**Field Selection**:
```pascal
// Specify exact fields with FieldsCsv parameter
Table := Article.Tags.DestGetJoinedTable(Client,
  '', ArticleID, jkPivotAndDestFields,
  'Tags.Name,Tags.CategoryID,ArticleTags.AssociationTime');
```

---

## 24.6.3. Bidirectional Navigation

### Source and Destination Properties

Every `TOrmMany` has two key properties:

```pascal
type
  TOrmArticleTags = class(TOrmMany)
  published
    property Source: TOrmArticle read fSource;
    property Dest: TOrmTag read fDest;
    property AssociationTime: TDateTime read fTime write fTime;
  end;
```

**Access Patterns**:
- `Source` property: References the "owning" entity (e.g., Article)
- `Dest` property: References the "target" entity (e.g., Tag)
- Additional fields: "Through" fields stored in pivot table

### SourceGet: Reverse ID Lookup

Find all sources for a given destination:

```pascal
var
  ArticleIDs: TIDDynArray;
begin
  // Find all articles with this tag
  if Tag.Articles.SourceGet(Client, TagID, ArticleIDs) then
    for i := 0 to High(ArticleIDs) do
      ProcessArticle(ArticleIDs[i]);
end;
```

**Symmetry**:
- `DestGet(SourceID)` → array of destination IDs
- `SourceGet(DestID)` → array of source IDs

### Navigation Pattern Example

Complete bidirectional navigation:

```pascal
// Forward: Article → Tags
procedure ShowArticleTags(ArticleID: TID);
var
  TagIDs: TIDDynArray;
begin
  if Article.Tags.DestGet(Client, ArticleID, TagIDs) then
    for var TagID in TagIDs do
      WriteLn('Tag: ', TagID);
end;

// Reverse: Tag → Articles
procedure ShowTagArticles(TagID: TID);
var
  ArticleIDs: TIDDynArray;
begin
  if Tag.Articles.SourceGet(Client, TagID, ArticleIDs) then
    for var ArticleID in ArticleIDs do
      WriteLn('Article: ', ArticleID);
end;
```

---

## 24.6.4. ManySelect: Retrieving Pivot Records

### Retrieve "Through" Fields

Use `ManySelect` to load a specific pivot table record:

```pascal
// Load the association record
if Article.Tags.ManySelect(Client, ArticleID, TagID) then
begin
  // Access "through" fields
  AddedBy := Article.Tags.AddedByUserID;
  AddedDate := Article.Tags.AssociationTime;
  Rank := Article.Tags.SortOrder;
end;
```

**Key Features**:
- Returns `true` if the Source/Dest pair exists
- Populates all pivot table fields (including "through" fields)
- Use when you need association metadata

### Update "Through" Fields

```pascal
// Modify association metadata
if Article.Tags.ManySelect(Client, ArticleID, TagID) then
begin
  Article.Tags.SortOrder := NewRank;
  Client.Update(Article.Tags);
end;
```

---

## 24.6.5. Batch Operations for Performance

### Bulk Add with TRestBatch

Use `TRestBatch` for high-performance bulk operations:

```pascal
var
  Batch: TRestBatch;
  i: Integer;
begin
  Batch := TRestBatch.Create(Client, TOrmArticleTags, 10000);
  try
    for i := 0 to High(TagIDs) do
    begin
      Article.Tags.AssociationTime := Now;
      Article.Tags.ManyAdd(Client, ArticleID, TagIDs[i], false, Batch);
    end;

    // Execute all adds in single transaction
    CheckIDs := Client.BatchSend(Batch);
    if Length(CheckIDs) = Length(TagIDs) then
      WriteLn('All associations created');
  finally
    Batch.Free;
  end;
end;
```

**Performance Gains**:
- Single transaction vs. N transactions
- Reduced network round-trips (server mode)
- ~10-100x faster for bulk operations

### Bulk Delete with Batch

```pascal
var
  Batch: TRestBatch;
begin
  Batch := TRestBatch.Create(Client, TOrmArticleTags, 1000);
  try
    for var TagID in ObsoleteTagIDs do
      Article.Tags.ManyDelete(Client, ArticleID, TagID, Batch);

    CheckIDs := Client.BatchSend(Batch);
  finally
    Batch.Free;
  end;
end;
```

### NoDuplicates Flag

Prevent duplicate associations:

```pascal
// Safe add: checks existence first
Article.Tags.ManyAdd(Client, ArticleID, TagID, NoDuplicates := true);
```

**Warning**: `NoDuplicates := true` performs an extra database query. For batch operations, ensure uniqueness in application logic instead:

```pascal
// Better for batch: ensure uniqueness before batch
var
  UniqueTagIDs: TIDDynArray;
begin
  // Remove duplicates in Pascal
  UniqueTagIDs := RemoveDuplicates(TagIDs);

  // Batch add without NoDuplicates check
  for var TagID in UniqueTagIDs do
    Article.Tags.ManyAdd(Client, ArticleID, TagID, false, Batch);
end;
```

---

## 24.6.6. Performance Considerations

### Query Optimization Matrix

| Operation | Method | Network Calls | Best For |
|-----------|--------|---------------|----------|
| Get IDs only | `DestGet` | 1 | Lightweight ID retrieval |
| Get IDs + filter dest | `DestGetJoined` (IDs) | 1 | Filtered ID lists |
| Get records + filter | `DestGetJoined` (TOrm) | 1 | Full filtered records |
| Iterate with "through" | `FillMany` | 1 | Pivot field access |
| Custom field combo | `DestGetJoinedTable` | 1 | Complex projections |
| Check single pair | `ManySelect` | 1 | Association metadata |

### Performance Best Practices

**1. Use Batch Operations for Bulk Writes**

```pascal
// ❌ Slow: N database calls
for i := 1 to 1000 do
  Article.Tags.ManyAdd(Client, ArticleID, TagIDs[i]);

// ✅ Fast: 1 batch transaction
Batch := TRestBatch.Create(Client, TOrmArticleTags, 1000);
for i := 1 to 1000 do
  Article.Tags.ManyAdd(Client, ArticleID, TagIDs[i], false, Batch);
Client.BatchSend(Batch);
```

**2. Use Inlined Parameters for Filtering**

```pascal
// ❌ Slow: No prepared statement caching
WhereClause := 'CategoryID=' + IntToStr(CatID);

// ✅ Fast: Cached prepared statement
WhereClause := FormatUtf8('CategoryID=?', [], [CatID]);
```

**3. Choose Right Method for Data Needs**

```pascal
// ❌ Wasteful: Loading full records just for IDs
TagRecord := Article.Tags.DestGetJoined(Client, '', ArticleID);
// ... extract IDs manually

// ✅ Efficient: Direct ID retrieval
Article.Tags.DestGet(Client, ArticleID, TagIDs);
```

**4. Minimize FillMany Calls**

```pascal
// ❌ Slow: Repeated FillMany calls
for var ArticleID in ArticleIDs do
  if Article.Tags.FillMany(Client, ArticleID) > 0 then
    // process...

// ✅ Fast: Single query with IN clause (if supported)
// Or: Batch retrieve using DestGetJoinedTable with custom SQL
```

**5. Index Pivot Table Foreign Keys**

Ensure your pivot table has indexes on `Source` and `Dest` columns:

```pascal
// In your model registration
Model.Props[TOrmArticleTags].AddFilterOrValidate(
  'Source', TSynValidateRest.Create);
Model.Props[TOrmArticleTags].AddFilterOrValidate(
  'Dest', TSynValidateRest.Create);
```

**Database Schema**:
```sql
-- Ensure indexes exist (automatic with mORMot for virtual tables)
CREATE INDEX IF NOT EXISTS ArticleTags_Source ON ArticleTags(Source);
CREATE INDEX IF NOT EXISTS ArticleTags_Dest ON ArticleTags(Dest);
```

### Memory Considerations

**FillMany and FillPrepare**: Both methods load results into `TOrmTable` in memory. For large result sets:

```pascal
// ❌ Risk: Loading 100K records into memory
Article.Tags.FillMany(Client, ArticleID);

// ✅ Better: Use pagination or filtering
Article.Tags.FillMany(Client, ArticleID,
  FormatUtf8('AssociationTime>?', [], [LastFetchTime]));
```

**Destination Record Retrieval**: `DestGetJoined(TOrm)` loads full records. For large datasets, use `DestGet` (IDs only) + lazy loading:

```pascal
// ❌ Memory-heavy: Load all destination records
TagRecord := Article.Tags.DestGetJoined(Client, '', ArticleID);

// ✅ Memory-efficient: Load IDs, then fetch on-demand
if Article.Tags.DestGet(Client, ArticleID, TagIDs) then
  for var TagID in TagIDs do
  begin
    Tag := TOrmTag.Create(Client, TagID); // Lazy load
    try
      ProcessTag(Tag);
    finally
      Tag.Free;
    end;
  end;
```

---

## 24.6.7. Advanced SQL Filtering Examples

### Complex WHERE Conditions

```pascal
// Multiple conditions with inlined parameters
WhereClause := FormatUtf8(
  'AssociationTime>? AND AssociationTime<? AND AddedByUserID=?',
  [], [StartDate, EndDate, UserID]);

Article.Tags.FillMany(Client, ArticleID, WhereClause);
```

### Destination Table Filtering

```pascal
// Filter on destination table fields
WhereClause := FormatUtf8(
  'Tags.CategoryID=? AND Tags.IsActive=?',
  [], [CategoryID, 1]);

Article.Tags.DestGetJoined(Client, WhereClause, ArticleID, TagIDs);
```

### Custom SQL with DestGetJoinedTable

```pascal
// Complex projection with custom field selection
Table := Article.Tags.DestGetJoinedTable(Client,
  'Tags.Score>:(100): AND Tags.CategoryID IN (1,2,3)',
  ArticleID,
  jkPivotAndDestFields,
  'Tags.Name,Tags.Score,ArticleTags.AssociationTime');
```

### Using IDWhereSql (Advanced)

Manually construct WHERE clauses for custom queries:

```pascal
var
  WhereClause: RawUtf8;
begin
  // Get base WHERE clause for source
  WhereClause := Article.Tags.IDWhereSql(Client, ArticleID, false);

  // Add custom conditions
  WhereClause := WhereClause + ' AND SortOrder>:(10):';

  // Execute custom query
  Table := Client.MultiFieldValues(TOrmArticleTags, '', WhereClause);
end;
```

---

## 24.6.8. Common Patterns and Recipes

### Pattern 1: Tag Cloud Generation

```pascal
function GenerateTagCloud(ArticleIDs: TIDDynArray): TTagCloudData;
var
  Article: TOrmArticle;
  TagCounts: TDictionary<TID, Integer>;
  TagID: TID;
  TagIDs: TIDDynArray;
begin
  TagCounts := TDictionary<TID, Integer>.Create;
  Article := TOrmArticle.Create;
  try
    for var ArticleID in ArticleIDs do
      if Article.Tags.DestGet(Client, ArticleID, TagIDs) then
        for TagID in TagIDs do
          TagCounts.AddOrSetValue(TagID,
            TagCounts.GetValueOrDefault(TagID, 0) + 1);

    // Convert to tag cloud data
    Result := ConvertToTagCloud(TagCounts);
  finally
    Article.Free;
    TagCounts.Free;
  end;
end;
```

### Pattern 2: Association Metadata Update

```pascal
procedure UpdateAssociationRank(ArticleID, TagID: TID; NewRank: Integer);
begin
  if Article.Tags.ManySelect(Client, ArticleID, TagID) then
  begin
    Article.Tags.SortOrder := NewRank;
    Article.Tags.ModifiedTime := Now;
    Client.Update(Article.Tags);
  end;
end;
```

### Pattern 3: Bulk Association Replacement

```pascal
procedure ReplaceArticleTags(ArticleID: TID; NewTagIDs: TIDDynArray);
var
  OldTagIDs: TIDDynArray;
  Batch: TRestBatch;
begin
  // Get existing tags
  Article.Tags.DestGet(Client, ArticleID, OldTagIDs);

  Batch := TRestBatch.Create(Client, TOrmArticleTags, 1000);
  try
    // Delete old associations
    for var TagID in OldTagIDs do
      Article.Tags.ManyDelete(Client, ArticleID, TagID, Batch);

    // Add new associations
    for var TagID in NewTagIDs do
    begin
      Article.Tags.AssociationTime := Now;
      Article.Tags.ManyAdd(Client, ArticleID, TagID, false, Batch);
    end;

    Client.BatchSend(Batch);
  finally
    Batch.Free;
  end;
end;
```

### Pattern 4: Filtered Relationship Count

```pascal
function CountRecentTags(ArticleID: TID; DaysSince: Integer): Integer;
var
  WhereClause: RawUtf8;
begin
  WhereClause := FormatUtf8('AssociationTime>?',
    [], [Now - DaysSince]);
  Result := Article.Tags.FillMany(Client, ArticleID, WhereClause);
end;
```

---

## 24.6.9. External Database Considerations

### Virtual Table Registration

For external databases, register `TOrmMany` as virtual table:

```pascal
Model.VirtualTableExternalRegister(
  TOrmArticleTags,
  TOrmVirtualTableModuleSQLite3,
  'ArticleTags');
```

### Mapped Table Names

If your pivot table has a different name in external DB:

```pascal
// Map to existing table
Props := Model.Props[TOrmArticleTags];
Props.ExternalDB.TableName := 'article_tag_mapping';
Props.ExternalDB.MapField('Source', 'article_id');
Props.ExternalDB.MapField('Dest', 'tag_id');
```

### Transaction Handling

Use transactions for batch operations with external databases:

```pascal
Client.TransactionBegin(TOrmArticleTags);
try
  // Batch operations
  Batch := TRestBatch.Create(Client, TOrmArticleTags, 1000);
  try
    // ... ManyAdd/ManyDelete calls
    Client.BatchSend(Batch);
  finally
    Batch.Free;
  end;

  Client.Commit;
except
  Client.RollBack;
  raise;
end;
```

---

## Summary

The `TOrmMany` advanced API provides powerful tools for efficient many-to-many relationship management:

- **FillMany/FillManyFromDest**: Iterate through related records with "through" fields
- **DestGet/SourceGet**: Lightweight ID retrieval (bidirectional)
- **DestGetJoined**: Server-side filtering for destination records
- **DestGetJoinedTable**: Custom field projections from pivot and destination tables
- **ManySelect**: Access association metadata ("through" fields)
- **Batch Operations**: High-performance bulk add/delete using `TRestBatch`
- **SQL Filtering**: Flexible WHERE conditions on pivot and destination tables

**Performance Keys**:
1. Use batch operations for bulk writes
2. Choose minimal data retrieval method (IDs vs. full records)
3. Apply inlined parameters for query caching
4. Index pivot table foreign keys
5. Consider memory usage for large result sets

**Next**: Chapter 25 explores ORM caching strategies and optimization techniques.

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [24.5. Pivot Tables](24.5-Pivot-Tables.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 25: ORM Caching](mORMot2-SAD-Chapter-25.md) |
