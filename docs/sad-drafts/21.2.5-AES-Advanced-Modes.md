# 21.2.5. Advanced AES Modes

*Custom AEAD Modes for High-Performance Applications*

---

## Overview

Beyond the standard AES modes (ECB, CBC, CFB, OFB, CTR) and the industry-standard AES-GCM, mORMot2 provides three custom **AEAD** (Authenticated Encryption with Associated Data) modes:

- **AES-CFC**: Cipher Feedback with CRC (CFB + 256-bit crc32c MAC)
- **AES-OFC**: Output Feedback with CRC (OFB + 256-bit crc32c MAC)
- **AES-CTC**: Counter with CRC (CTR + 256-bit crc32c MAC)

These proprietary modes combine standard AES block cipher modes with hardware-accelerated CRC32C for message authentication, offering:

- **Hardware acceleration** via AES-NI and SSE4.2 instructions
- **Dual integrity protection** (encrypted + plain text MAC)
- **Early error detection** (pre-decryption validation)
- **Internal protocol** optimization (simpler than full GCM)

> **Note**: These modes are **non-standard** and specific to mORMot. Use AES-GCM for interoperability with external systems.

---

## Why Custom AEAD Modes?

### Standard AES-GCM Limitations

While AES-GCM is the industry standard for AEAD, it has specific trade-offs:

- **One-pass only**: Authentication happens during decryption
- **No early validation**: Cannot check integrity before processing
- **Complex implementation**: Requires GHASH polynomial multiplication
- **Limited flexibility**: Fixed GMAC output format

### mORMot2 Custom AEAD Benefits

The custom CFC/OFC/CTC modes address these limitations:

```
┌─────────────────────────────────────────────────────────────┐
│  Feature             │ AES-GCM     │ AES-CFC/OFC/CTC         │
├──────────────────────┼─────────────┼─────────────────────────┤
│  Standard compliance │ ✓ NIST      │ ✗ mORMot-only           │
│  Pre-decrypt check   │ ✗           │ ✓ (encrypted CRC)       │
│  Post-decrypt check  │ ✓ (GMAC)    │ ✓ (plain CRC)           │
│  Hardware accel.     │ AES-NI+CLMUL│ AES-NI+SSE4.2           │
│  Fuzzing protection  │ None        │ Header CRC32C           │
│  Internal protocol   │ Complex     │ Simple                  │
└─────────────────────────────────────────────────────────────┘
```

**Key advantage**: The dual MAC approach allows detecting transmission errors **before** decryption, saving CPU cycles on corrupted data.

---

## 256-bit Dual MAC Design

### Architecture

Each custom AEAD mode computes **two independent CRC32C hashes** during encryption:

```pascal
TAesMac256 = record
  /// AES-encrypted MAC of the plain content
  // - digital signature of the plain text, for message authentication
  // - checked AFTER decryption via MacDecryptCheckTag()
  plain: THash128;

  /// Plain MAC of the encrypted content
  // - digital signature of the encrypted text, for error detection
  // - checked BEFORE decryption via MacCheckError()
  encrypted: THash128;
end;
```

### Workflow

**Encryption**:
```
┌──────────────┐
│  Plain Data  │
└──────┬───────┘
       │
       ├─────────► CRC32C ───► plain.crc (seeded from nonce)
       │
       ▼
  ┌─────────┐
  │ AES CTR │
  └────┬────┘
       │
       ├─────────► CRC32C ───► encrypted.crc (fixed seed)
       │
       ▼
┌──────────────┐
│ Cipher Data  │
└──────────────┘

Final MAC = AES(plain.crc) || encrypted.crc
```

**Decryption with early validation**:
```
┌──────────────┐
│ Cipher Data  │◄── Compare encrypted.crc
└──────┬───────┘   ▲
       │           │ MacCheckError()
       │           │ ✓ Pre-validation
       ▼           │
  ┌─────────┐      │
  │ AES CTR │      │
  └────┬────┘      │
       │           │
       ▼           │
┌──────────────┐   │
│  Plain Data  │◄──┘ Compare plain.crc
└──────────────┘    MacDecryptCheckTag()
                    ✓ Authentication
```

### Security Properties

1. **Plain CRC seeded from random nonce**: Prevents replay attacks
2. **Encrypted CRC with fixed seed**: No nonce leakage, safe for error detection
3. **Plain CRC encrypted**: Prevents forgery attacks on authentication MAC
4. **Associated data support**: Additional context-specific data protection

---

## Mode Details

### AES-CFC (Cipher Feedback + CRC)

**Class**: `TAesCfc`

**Algorithm**: Combines CFB mode with 256-bit CRC32C authentication.

**Characteristics**:
- Asymmetric Encrypt/Decrypt methods (CFB is non-symmetric)
- Best for **streaming data** where block alignment is uncertain
- Handles trailing bytes (non-multiple of 16) gracefully

**Performance** (x86_64, 2.5MB buffer):
```
mormot aes-128-cfc in 2.74ms i.e. 889K/s or 1.8 GB/s
mormot aes-256-cfc in 3.63ms i.e. 671.2K/s or 1.4 GB/s
```

**Performance** (i386, 2.5MB buffer):
```
mormot aes-128-cfc in 2.83ms i.e. 859.9K/s or 1.8 GB/s
mormot aes-256-cfc in 3.68ms i.e. 663K/s or 1.4 GB/s
```

**When to use**:
- WebSocket encryption (variable-length frames)
- Streaming protocols where data arrives in chunks
- Text-based protocols with unpredictable message sizes

---

### AES-OFC (Output Feedback + CRC)

**Class**: `TAesOfc`

**Algorithm**: Combines OFB mode with 256-bit CRC32C authentication.

**Characteristics**:
- Symmetric Encrypt/Decrypt (both call same `Encrypt()` method)
- Simpler than CFB, similar performance
- Good for **random access** (can encrypt/decrypt at any position)

**Performance** (x86_64, 2.5MB buffer):
```
mormot aes-128-ofc in 3.06ms i.e. 795.7K/s or 1.6 GB/s
mormot aes-256-ofc in 3.97ms i.e. 614.9K/s or 1.3 GB/s
```

**Performance** (i386, 2.5MB buffer):
```
mormot aes-128-ofc in 2.82ms i.e. 863.3K/s or 1.8 GB/s
mormot aes-256-ofc in 3.69ms i.e. 660.3K/s or 1.4 GB/s
```

**When to use**:
- File encryption with random access requirements
- Database field encryption (individual record access)
- Simple symmetric use cases (same code path for encrypt/decrypt)

---

### AES-CTC (Counter + CRC)

**Class**: `TAesCtc`

**Algorithm**: Combines CTR mode with 256-bit CRC32C authentication.

**Characteristics**:
- Symmetric Encrypt/Decrypt (both call same `Encrypt()` method)
- **Highest performance** on x86_64 (8x interleaved AES-NI operations)
- Counter mode allows parallel processing
- Best overall choice for **internal mORMot protocols**

**Performance** (x86_64, 2.5MB buffer - 8x interleaved):
```
mormot aes-128-ctc in 965us i.e. 2.4M/s or 5.3 GB/s
mormot aes-256-ctc in 1.10ms i.e. 2.1M/s or 4.7 GB/s
```

**Performance** (i386, 2.5MB buffer - non-interleaved):
```
mormot aes-128-ctc in 3.80ms i.e. 641.6K/s or 1.3 GB/s
mormot aes-256-ctc in 4.68ms i.e. 521.3K/s or 1.1 GB/s
```

**When to use**:
- High-throughput applications (REST API encryption)
- CPU-intensive services (maximum hardware utilization)
- **Recommended default** for internal mORMot protocols
- Alternative to AES-GCM when standards compliance is not required

---

## Performance Comparison

### Benchmarks Summary (x86_64, AES-NI + SSE4.2)

| Mode       | AES-128 (GB/s) | AES-256 (GB/s) | Relative Speed |
|------------|----------------|----------------|----------------|
| **AES-CTC** | **5.3**       | **4.7**        | **1.0x** (fastest) |
| AES-GCM    | 5.0            | 4.4            | 0.94x          |
| AES-CFC    | 1.8            | 1.4            | 0.34x          |
| AES-OFC    | 1.6            | 1.3            | 0.30x          |
| AES-CFB    | 2.0            | 1.5            | 0.38x (no MAC) |

**Key insights**:
- **AES-CTC** is the fastest custom AEAD mode (comparable to AES-GCM)
- **8x interleaving** on x86_64 gives CTC a 3-5x speedup over non-interleaved modes
- On **i386** (no interleaving), all modes have similar performance (~1.3-1.8 GB/s)
- Hardware acceleration (AES-NI + SSE4.2) is critical for all modes

### Hardware Requirements

**Optimal performance requires**:
- `cfAESNI` in `CpuFeatures` (x86_64/i386 AES-NI instructions)
- `cfSSE42` in `CpuFeatures` (CRC32C hardware instruction)

**Without hardware acceleration**:
- Falls back to pure Pascal implementations
- Performance drops by **10-20x** (still usable, but slower)
- CRC32C uses 4KB pre-computed lookup table

---

## Usage Patterns

### Simple Encryption/Decryption

**High-level API** (recommended for small messages):

```pascal
uses
  mormot.core.crypto;

var
  plaintext, ciphertext, decrypted: RawByteString;
  key: THash256;
  associated: RawByteString;
begin
  // Generate key (use proper key derivation in production)
  TAesPrng.Main.FillRandom(key);

  // Optional associated data (e.g., protocol version, session ID)
  associated := 'MyApp/v1.0/SessionABC';

  // Encrypt with AES-256-CTC
  ciphertext := TAesCtc.MacEncrypt(
    plaintext,      // data to encrypt
    key,            // 256-bit key
    true,           // encrypt = true
    associated      // authenticated associated data
  );

  // Decrypt and authenticate
  decrypted := TAesCtc.MacEncrypt(
    ciphertext,     // data to decrypt
    key,            // same key
    false,          // encrypt = false
    associated      // must match encryption
  );

  // Empty result = authentication failure
  if decrypted = '' then
    raise Exception.Create('MAC validation failed');
end;
```

**Format** (MacEncrypt/MacAndCrypt):
```
┌─────────────────────────────────────────────────────────────┐
│ Header (69 bytes)          │ Encrypted Data (N bytes)       │
├────────────────────────────┼────────────────────────────────┤
│ Nonce (32) │ MAC (32) │CRC │ PKCS7-padded ciphertext        │
│ THash256   │ THash256 │ 4  │ (includes IV if IVAtBeginning) │
└─────────────────────────────────────────────────────────────┘
```

**Security**:
- Nonce is randomly generated per encryption (prevents replay)
- CRC32C of header detects fuzzing/corruption before AES/MAC
- MAC includes associated data in computation

---

### Low-level Instance API

**For large messages or streaming**:

```pascal
uses
  mormot.core.crypto;

var
  aes: TAesCtc;
  nonce: THash256;
  mac: THash256;
  plaintext: RawByteString;
  ciphertext: RawByteString;
begin
  // Create AES-256-CTC instance
  aes := TAesCtc.Create(key, 256);
  try
    // Step 1: Initialize AEAD with random nonce
    TAesPrng.Main.FillRandom(nonce);
    aes.MacSetNonce(
      true,         // DoEncrypt = true
      nonce,        // random nonce (unique per message)
      'context'     // associated data
    );

    // Step 2: Encrypt with PKCS7 padding
    ciphertext := aes.EncryptPkcs7(plaintext, true); // IVAtBeginning

    // Step 3: Get MAC tag
    if not aes.MacEncryptGetTag(mac) then
      raise Exception.Create('MAC generation failed');

    // Transmit: nonce || ciphertext || mac

  finally
    aes.Free;
  end;
end;
```

**Decryption**:

```pascal
var
  aes: TAesCtc;
  received_nonce, received_mac: THash256;
  ciphertext, plaintext: RawByteString;
begin
  aes := TAesCtc.Create(key, 256);
  try
    // Step 1: Pre-validate encrypted content (optional, saves CPU)
    if not aes.MacCheckError(
      pointer(ciphertext),
      length(ciphertext)
    ) then
      raise Exception.Create('Transmission error detected');

    // Step 2: Initialize AEAD with received nonce
    aes.MacSetNonce(
      false,              // DoEncrypt = false
      received_nonce,
      'context'
    );

    // Step 3: Decrypt
    plaintext := aes.DecryptPkcs7(ciphertext, true); // IVAtBeginning

    // Step 4: Authenticate
    if not aes.MacDecryptCheckTag(received_mac) then
    begin
      FillZero(plaintext); // erase potentially forged data
      raise Exception.Create('Authentication failed');
    end;

    // plaintext is now authenticated

  finally
    aes.Free;
  end;
end;
```

---

### User Data Protection

**Practical example** (cross-platform user secrets):

```pascal
function CryptDataForCurrentUser(
  const Data, AppSecret: RawByteString;
  Encrypt: boolean
): RawByteString;
```

**Implementation**:
- Uses `TAesCfc.MacEncrypt()` internally (fast cipher + CRC)
- Derives key from user-specific secret file (per-user isolation)
- Windows: DPAPI-protected secret file
- Linux/POSIX: chmod 400 hidden `.syn-*` file in `$HOME`
- **100x faster** than Windows CryptProtectData DPAPI
- Consistent across all Operating Systems

**Usage**:

```pascal
var
  secret, encrypted, decrypted: RawByteString;
begin
  secret := 'My sensitive data';

  // Encrypt (stores in memory)
  encrypted := CryptDataForCurrentUser(
    secret,
    'MyApp/Config/v1.0', // application-specific salt
    true
  );

  // Later: decrypt
  decrypted := CryptDataForCurrentUser(
    encrypted,
    'MyApp/Config/v1.0', // must match
    false
  );

  if decrypted = '' then
    raise Exception.Create('Decryption failed (wrong user or corruption)');
end;
```

**Security notes**:
- AppSecret acts as additional salt (binds to application context)
- Empty result on decryption = authentication failure
- Key file is user-specific (other users cannot decrypt)
- Safe for protecting configuration, credentials, API keys

---

## Choosing the Right Mode

### Decision Matrix

```
┌─────────────────────────────────────────────────────────────┐
│ Requirement               │ Recommended Mode                │
├───────────────────────────┼─────────────────────────────────┤
│ Standards compliance      │ AES-GCM (NIST SP 800-38D)       │
│ Maximum performance       │ AES-CTC (8x interleaved)        │
│ Streaming/WebSockets      │ AES-CFC (handles odd sizes)     │
│ Random access encryption  │ AES-OFC (symmetric)             │
│ Early error detection     │ AES-CFC/OFC/CTC (all support)   │
│ Simple internal protocol  │ AES-CTC (recommended default)   │
│ External interoperability │ AES-GCM (only standard option)  │
│ Legacy mORMot 1 compat.   │ AES-CFC (was TAesCfbCrc)        │
└─────────────────────────────────────────────────────────────┘
```

### Recommendations

**Use AES-GCM** when:
- Communicating with external systems (REST APIs, third-party clients)
- Compliance requirements mandate NIST-approved algorithms
- OpenSSL compatibility is needed

**Use AES-CTC** when:
- Building internal mORMot services (client ↔ server)
- Performance is critical (high-throughput REST services)
- Platform is x86_64 with AES-NI (8x interleaving advantage)

**Use AES-CFC** when:
- Implementing WebSocket encryption (variable frame sizes)
- Migrating from mORMot 1 (was `TAesCfbCrc`)
- Streaming data with unpredictable chunk sizes

**Use AES-OFC** when:
- Encrypting database fields (individual record access)
- Random-access file encryption
- Symmetric encrypt/decrypt simplifies code logic

---

## Implementation Notes

### Accessing Mode Classes

**Runtime dispatch** (recommended):

```pascal
uses
  mormot.core.crypto;

var
  TAesFast: TAesAbstractClasses = (
    TAesEcb, TAesCbc, TAesCfb, TAesOfb,
    TAesC64, TAesCtr,
    TAesCfc, TAesOfc, TAesCtc, TAesGcm
  );

var
  aes: TAesAbstract;
begin
  // Create fastest implementation for mode
  aes := TAesFast[mCtc].Create(key, 256);
  try
    // Use aes instance
  finally
    aes.Free;
  end;
end;
```

> **Note**: `mormot.crypt.openssl` may replace some entries (e.g., `TAesGcm` → `TAesGcmOsl`) if OpenSSL library is loaded.

**Mode detection**:

```pascal
const
  AES_AEAD = [mCfc, mOfc, mCtc, mGcm];
  AES_INTERNAL = [mC64, mCfc, mOfc, mCtc]; // mORMot-specific

if aes.AlgoMode in AES_AEAD then
  writeln('Supports MacSetNonce/MacEncryptGetTag');

if aes.AlgoMode in AES_INTERNAL then
  writeln('Non-standard mode (no OpenSSL equivalent)');
```

**Algorithm naming**:

```pascal
writeln(aes.AlgoName);
// Output: 'aes-256-ctc' (OpenSSL-like naming, even for custom modes)
```

---

### MAC API Reference

**Core AEAD methods** (all custom modes):

```pascal
// Initialize before encryption/decryption
function MacSetNonce(
  DoEncrypt: boolean;
  const RandomNonce: THash256;
  const Associated: RawByteString = ''
): boolean;

// After encryption: get MAC tag
function MacEncryptGetTag(
  out EncryptMac: THash256
): boolean;

// After decryption: validate MAC tag
function MacDecryptCheckTag(
  const DecryptMac: THash256
): boolean;

// Before decryption: quick integrity check (optional)
function MacCheckError(
  Encrypted: pointer;
  Count: cardinal
): boolean;

// One-shot encrypt/decrypt with authentication
function MacAndCrypt(
  const Data: RawByteString;
  Encrypt, IVAtBeginning: boolean;
  const Associated: RawByteString = '';
  EndingSize: cardinal = 0
): RawByteString;
```

**Class methods** (convenience wrappers):

```pascal
class function MacEncrypt(
  const Data: RawByteString;
  const Key: THash256;
  Encrypt: boolean;
  const Associated: RawByteString = '';
  IV: PAesBlock = nil
): RawByteString;
```

---

### Thread Safety

**Instance-level**:
- Each `TAesAbstract` instance is **not thread-safe**
- Create separate instances per thread
- Do not share instances across threads

**Class-level**:
- `TAesFast` global array is read-only (safe)
- `TAesPrng.Main` is thread-safe (uses TLightLock)
- `CryptDataForCurrentUser()` is thread-safe (internal locking)

**Example** (worker threads):

```pascal
procedure TMyWorker.Execute;
var
  aes: TAesCtc;
begin
  aes := TAesCtc.Create(fKey, 256); // per-thread instance
  try
    while not Terminated do
    begin
      // Use aes for encryption/decryption
    end;
  finally
    aes.Free;
  end;
end;
```

---

## Security Considerations

### Best Practices

1. **Never reuse nonces**: Always generate fresh nonce per message
   ```pascal
   TAesPrng.Main.FillRandom(nonce); // cryptographically secure RNG
   ```

2. **Use associated data**: Bind encryption to context
   ```pascal
   associated := 'SessionID:' + sessionID + '/MessageType:' + msgType;
   ```

3. **Check MAC results**: Empty result = failure
   ```pascal
   plaintext := aes.DecryptPkcs7(...);
   if not aes.MacDecryptCheckTag(mac) then
   begin
     FillZero(plaintext); // erase untrusted data
     raise Exception.Create('Authentication failed');
   end;
   ```

4. **Erase sensitive data**: Use `FillZero()` after use
   ```pascal
   try
     // Use key/plaintext
   finally
     FillZero(key);
     FillZero(plaintext);
   end;
   ```

5. **Use proper key derivation**: Never use passwords directly
   ```pascal
   Pbkdf2HmacSha256(password, salt, rounds, key);
   ```

### Attack Resistance

**Protected against**:
- ✓ Replay attacks (random nonce per message)
- ✓ Forgery attacks (plain CRC encrypted, cannot forge)
- ✓ Transmission errors (encrypted CRC pre-validation)
- ✓ Fuzzing attacks (header CRC32C in MacAndCrypt format)

**Not protected against**:
- ✗ Weak key derivation (use PBKDF2/Argon2)
- ✗ Nonce reuse (application must ensure uniqueness)
- ✗ Side-channel attacks (timing, cache) - use constant-time operations if critical

### Format Validation

**MacAndCrypt format** includes pre-validation:

```pascal
// Header CRC prevents naive fuzzing
TMacAndCryptData = packed record
  nonce: THash256;
  mac: THash256;
  crc: cardinal; // crc32c(nonce+mac) - validated before AES/MAC
  data: byte;    // PKCS7-padded ciphertext follows
end;
```

**Decryption** checks CRC before expensive AES operations:
1. Validate header CRC (fast, detects corruption/fuzzing)
2. If invalid → return empty result immediately
3. If valid → proceed with AES decryption + MAC validation

This saves CPU on malformed input (e.g., network fuzzing, storage corruption).

---

## Migration Guide

### From mORMot 1

**Class name changes**:

```pascal
// mORMot 1              →  mORMot 2
TAesCfbCrc             →  TAesCfc
TAesOfbCrc             →  TAesOfc
TAesCtrCrc             →  TAesCtc
TAESCTR (non-standard) →  TAesC64 (64-bit CRC)
TAESCTR (NIST)         →  TAesCtr (standard CTR)
```

**Compatibility aliases** (deprecated, will be removed):

```pascal
{$ifndef PUREMORMOT2}
type
  TAesCfbCrc = TAesCfc;
  TAesOfbCrc = TAesOfc;
  TAesCtrCrc = TAesCtc;
{$endif}
```

**Recommended migration**:
```pascal
// Replace all occurrences
TAesCfbCrc → TAesCfc
TAesOfbCrc → TAesOfc
TAesCtrCrc → TAesCtc
```

### From OpenSSL

**Standard modes** (use as-is):
- AES-GCM: `TAesGcm` (mORMot) ≈ EVP_aes_*_gcm (OpenSSL)
- AES-CTR: `TAesCtr` (mORMot) ≈ EVP_aes_*_ctr (OpenSSL)

**Custom modes** (no OpenSSL equivalent):
- AES-CFC, AES-OFC, AES-CTC are mORMot-specific
- For interoperability, use AES-GCM instead

---

## Reference

### Related Documentation

- **Section 21.2.4**: AES-GCM implementation (standard AEAD)
- **Section 21.3**: Key derivation (PBKDF2, Argon2)
- **Section 21.7**: Hardware acceleration (AES-NI, SSE4.2)

### Source Files

- `mormot.crypt.core.pas`:
  - `TAesCfc` (lines 1150-1166)
  - `TAesOfc` (lines 1177-1191)
  - `TAesCtc` (lines 1193-1209)
  - `TAesAbstractAead` (lines 1093-1148)
  - `MacAndCrypt()` implementation (lines 5541-5632)

### Constants

```pascal
const
  AES_AEAD = [mCfc, mOfc, mCtc, mGcm];      // AEAD-capable modes
  AES_INTERNAL = [mC64, mCfc, mOfc, mCtc];  // mORMot-specific modes
```

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Section 21.2.4: AES-GCM](21.2.4-AES-GCM.md) | [Index](mORMot2-SAD-Index.md) | [Section 21.3: Key Derivation](21.3-Key-Derivation.md) |
