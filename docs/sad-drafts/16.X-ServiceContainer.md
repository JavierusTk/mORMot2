# 16.X. Service Container Internals

*Managing the Service Ecosystem*

The `TServiceContainerServer` class serves as the central registry and lifecycle manager for all SOA services in a mORMot 2 application. While `TServiceFactoryServer` manages individual service implementations, the container orchestrates the entire service ecosystem, handling authorization policies, instance lifecycle, callback management, and asynchronous notifications.

## 16.X.1. Container Architecture

### Service Registry Structure

The service container inherits from `TServiceContainerClientAbstract` to enable remote access capabilities while adding server-side management features:

```pascal
TServiceContainerServer = class(TServiceContainerClientAbstract)
protected
  fRestServer: TRestServer;
  fConnectionID: TRestConnectionID;
  fFakeCallbacks: TSynObjectListLocked;
  fRecordVersionCallback: array of IServiceRecordVersionCallbackDynArray;
  fCallbackNamesSorted: TRawUtf8DynArray;
  fPublishSignature: boolean;
  fCallbackOptions: TServiceCallbackOptions;
  fSessionTimeout: cardinal;
  fOnCallbackReleasedOnClientSide: TOnCallbackReleased;
  fOnCallbackReleasedOnServerSide: TOnCallbackReleased;
```

Key responsibilities:

- **Service Registration**: Maintains list of `TServiceFactoryServer` instances
- **Callback Management**: Tracks server-side callback instances (`TInterfacedObjectFakeServer`)
- **Session Coordination**: Manages service instance lifecycle across sessions
- **Notification Routing**: Dispatches asynchronous ORM change notifications

### Service Factory Management

The container provides the `AddImplementation` method to register services with multiple interfaces:

```pascal
function AddImplementation(aImplementationClass: TInterfacedClass;
  const aInterfaces: array of PRttiInfo;
  aInstanceCreation: TServiceInstanceImplementation;
  aSharedImplementation: TInterfacedObject;
  const aContractExpected: RawUtf8): TServiceFactoryServer;
```

This method:

- Validates that `aImplementationClass` implements all interfaces in `aInterfaces`
- Creates a `TServiceFactoryServer` for each interface
- Reuses existing factory if interface already registered
- For `sicShared` mode, reuses the same shared instance across interfaces
- Returns the factory for the first interface in the array

## 16.X.2. Service Instance Lifecycle

### Instance Creation Modes

The container supports seven instance creation strategies through `TServiceInstanceImplementation`:

| Mode | Lifecycle | Thread Safety | Use Case |
|------|-----------|---------------|----------|
| `sicSingle` | New instance per call | Not required | Stateless operations, safest default |
| `sicShared` | One instance for all calls | **Required** | High-performance shared resources |
| `sicClientDriven` | Instance per client connection | Not required | Stateful client sessions |
| `sicPerSession` | Instance per authenticated session | **Required** | User session state |
| `sicPerUser` | Instance per user across sessions | **Required** | Cross-session user resources |
| `sicPerGroup` | Instance per user group | **Required** | Group-level shared state |
| `sicPerThread` | Instance per calling thread | Not required | Thread-local resources |

### Session Management

The container coordinates session-based instance lifecycle:

```pascal
// Called when client renews session (heartbeat)
function ClientSessionRenew(Ctxt: TRestServerUriContext): integer;

// Called when session closes (logout or timeout)
function OnCloseSession(aSessionID: cardinal): integer;
```

For `sicPerSession` and `sicClientDriven` modes:

- Instances are stored in `TServiceFactoryServer.fInstance` array
- Accessed via instance ID or session ID
- Automatically released on session close
- Timeout managed via `fSessionTimeout` (default: 30 minutes)

### Connection Management

The container tracks client connections for callback routing:

```pascal
// Replace connection ID (e.g., after WebSocket reconnect)
function ClientReplaceConnectionID(old, new: TRestConnectionID): integer;

// Remove callbacks when connection closes
procedure RemoveFakeCallbackOnConnectionClose(aConnectionID: TRestConnectionID);
```

This enables seamless client reconnection without losing callback subscriptions.

## 16.X.3. Authorization Policies

### Method-Level Security

Each `TServiceFactoryServer` inherits authorization methods from `TServiceFactoryServerAbstract`:

```pascal
// Default: all methods allowed
Server.ServiceRegister(TMyService, [TypeInfo(IMyService)], sicShared);

// Whitelist approach (recommended for security)
Server.Services.Resolve(IMyService, Factory);
Factory.DenyAll.Allow(['GetPublicData', 'Search']);

// Blacklist approach
Factory.AllowAll.Deny(['DeleteAll', 'AdminOperation']);
```

Authorization is enforced in `TServiceFactoryServer.ExecuteMethod` before method invocation.

### Runtime Authorization Hook

The `OnMethodExecute` event allows dynamic authorization:

```pascal
type
  TOnServiceCanExecute = function(Ctxt: TRestServerUriContext;
    const Method: TInterfaceMethod): boolean of object;

// Example: Role-based authorization
Factory.OnMethodExecute := function(Ctxt: TRestServerUriContext;
  const Method: TInterfaceMethod): boolean
begin
  if Method.InterfaceDotMethodName = 'IAdmin.DeleteUser' then
  begin
    if Ctxt.SessionGroup <> ADMIN_GROUP then
    begin
      Ctxt.Error('Unauthorized', HTTP_NOTALLOWED);
      Exit(False);
    end;
  end;
  Result := True;
end;
```

The event receives:

- `Ctxt.ServiceMethod`: Method being called
- `Ctxt.ServiceMethodIndex`: Index in interface methods array
- `Ctxt.ServiceParameters`: JSON-encoded input parameters
- `Ctxt.Session`, `Ctxt.SessionUser`, `Ctxt.SessionGroup`: Authentication context

Return `False` to deny execution (set error via `Ctxt.Error`).

## 16.X.4. Per-Method Statistics

### Automatic Metrics Collection

Each `TServiceFactoryServer` maintains execution statistics per method:

```pascal
property Stats: TSynMonitorInputOutputObjArray read fStats;
property Stat[const aMethod: RawUtf8]: TSynMonitorInputOutput read GetStat;
```

The `TSynMonitorInputOutput` class tracks:

- **Call count**: Total method invocations
- **Data volume**: Input/output byte sizes
- **Timing**: Min, max, average, total execution time
- **Errors**: Failed call count

### Accessing Statistics

```pascal
// By method name
var
  Stat: TSynMonitorInputOutput;
begin
  if Server.Services.Resolve(ICalculator, Factory) then
  begin
    Stat := Factory.Stat['Add'];
    WriteLn('Add called: ', Stat.Count, ' times');
    WriteLn('Average time: ', Stat.PerSec, ' ms');
  end;
end;

// Iterate all methods
var
  I: Integer;
begin
  for I := 0 to High(Factory.Stats) do
    if Factory.Stats[I] <> nil then
      WriteLn(Factory.Interface.Methods[I].InterfaceDotMethodName,
              ': ', Factory.Stats[I].Count, ' calls');
end;
```

Statistics are initialized lazily on first method call and persist for the lifetime of the factory.

## 16.X.5. Callback Management

### Server-Side Callback Instances

For callback interfaces (parameters or return values), the container creates `TInterfacedObjectFakeServer` instances:

```pascal
// Called when service method returns callback interface
procedure GetFakeCallback(Ctxt: TRestServerUriContext;
  ParamInterfaceRtti: TRttiCustom; FakeID: PtrInt; out Obj);
```

The fake instance:

- Implements the callback interface via RTTI
- Routes calls to `TRestServer.OnNotifyCallback`
- Sends JSON-RPC messages to the client
- Tracked in `fFakeCallbacks` list for cleanup

### Callback Lifecycle Events

```pascal
type
  TOnCallbackReleased = procedure(Sender: TServiceContainer;
    Instance: TInterfacedObject; Callback: pointer) of object;

property OnCallbackReleasedOnClientSide: TOnCallbackReleased;
property OnCallbackReleasedOnServerSide: TOnCallbackReleased;
```

Events triggered when:

- **Client-side release**: Client calls `_free_` on callback
- **Server-side release**: Server destroys callback instance

Use cases:

- Unsubscribe from event sources
- Release server-side resources
- Log callback usage

### Callback Error Handling

The `TServiceCallbackOptions` set controls callback error behavior:

```pascal
type
  TServiceCallbackOptions = set of (
    coRaiseExceptionIfReleasedByClient
  );

property CallbackOptions: TServiceCallbackOptions;
```

By default, invoking a released callback logs a warning and continues. With `coRaiseExceptionIfReleasedByClient`, it raises `EInterfaceFactoryException`.

### Explicit Callback Release

Clients can release callbacks to reduce server resource usage:

```pascal
// Client-side
Client.CallbackRelease(MyCallback); // Sends _free_ to server

// Server receives root/cacheflush/_callback_ URI
procedure ClientFakeCallbackRelease(Ctxt: TRestServerUriContext);
```

The server removes the callback from `fFakeCallbacks` and triggers `OnCallbackReleasedOnClientSide`.

## 16.X.6. Asynchronous Notification Framework

### Master/Slave Replication

The container provides built-in support for ORM change notifications via the `IServiceRecordVersion` / `IServiceRecordVersionCallback` pattern:

```pascal
// Master server setup
Server.RecordVersionSynchronizeMasterStart(TOrmCustomer);

// Slave server subscribes
type
  IServiceRecordVersion = interface(IInvokable)
    ['{06A355CA-19EB-4CC6-9D87-7B48967D1D9F}']
    function Subscribe(const SqlTableName: RawUtf8;
      const revision: TRecordVersion;
      const callback: IServiceRecordVersionCallback): boolean;
  end;

// Slave callback receives notifications
type
  IServiceRecordVersionCallback = interface(IInvokable)
    ['{0BA61F76-4F09-44AF-8FBC-8E33B7F4D9}}']
    procedure Added(const NewContent: RawJson);
    procedure Updated(const ModifiedContent: RawJson);
    procedure Deleted(const ID: TID; const Revision: TRecordVersion);
  end;
```

### Notification Dispatch

The container maintains callback subscriptions per table:

```pascal
fRecordVersionCallback: array of IServiceRecordVersionCallbackDynArray;

// Called by TRestServer after ORM operations
procedure RecordVersionNotifyAddUpdate(Occasion: TOrmOccasion;
  TableIndex: integer; const Document: TDocVariantData);

procedure RecordVersionNotifyDelete(TableIndex: integer;
  const ID: TID; const Revision: TRecordVersion);
```

Notification flow:

1. ORM operation (Insert/Update/Delete) completes on master
2. Master's `TServiceContainerServer.RecordVersionNotifyXxx` called
3. Iterates `fRecordVersionCallback[TableIndex]` array
4. Invokes each callback's `Added`/`Updated`/`Deleted` method
5. Callback sends JSON-RPC to slave via WebSockets (non-blocking)
6. Slave's `TServiceRecordVersionCallback` applies changes to local DB

### Callback Subscription Management

Automatic cleanup of released callbacks:

```pascal
procedure RecordVersionCallbackNotify(TableIndex: integer;
  Occasion: TOrmOccasion; const DeletedID: TID;
  const DeletedRevision: TRecordVersion; const AddUpdateJson: RawUtf8);
begin
  for i := length(arr^) - 1 downto 0 do // Downto for safe deletion
    if CallbackReleasedOnClientSide(arr^[i]) then
      InterfaceArrayDelete(arr^, i) // Remove stale callback
    else
      // Invoke callback...
end;
```

This ensures that disconnected slaves don't accumulate in the callback list.

### Non-Blocking Notification

Callbacks with no return values are executed asynchronously:

```pascal
// In TInterfacedObjectFakeServer.FakeInvoke
if aMethod.ArgsOutputValuesCount = 0 then
  aResult := nil; // Asynchronous non-blocking callback

result := fServer.OnNotifyCallback(fServer, aMethod.InterfaceDotMethodName,
  aParams, fLowLevelConnectionID, aFakeID^, aResult, aErrorMsg);
```

This prevents master operations from blocking on slave processing.

## 16.X.7. Signature Publication Control

### Contract Verification

The `PublishSignature` property controls whether clients can retrieve interface contracts:

```pascal
property PublishSignature: boolean read fPublishSignature write SetPublishSignature;
```

When `True`:

- Clients can call `root/interface/_signature_` URI
- Returns method names, parameter types, and contract hash
- Enables dynamic client validation

When `False` (default):

- Signature requests return 404 (security by obscurity)
- Clients must use pre-compiled interface definitions
- Prevents interface structure discovery

Usage:

```pascal
// Enable for development/debugging
Server.Services.PublishSignature := True;

// Client retrieves signature
if Client.Services.Resolve(ICalculator, Factory) then
  WriteLn(Factory.RetrieveSignature);
```

Setting `PublishSignature` triggers `TRestServer.ResetRoutes` to activate/deactivate the signature URI.

## 16.X.8. Service Logging

### Automatic Method Logging

The container can log all service method executions to a `TOrmServiceLog` table:

```pascal
procedure SetServiceLog(const aLogRest: IRestOrm;
  aLogClass: TOrmServiceLogClass; const aExcludedMethodNamesCsv: RawUtf8);
```

This calls `TServiceFactoryServer.SetServiceLog` for each registered service, excluding methods in `aExcludedMethodNamesCsv`.

Logged information (via `TOrmServiceLog`):

- Method name and interface
- Input/output parameters (if configured)
- Execution time
- Success/error status
- Session/user context

### Per-Service Logging Configuration

```pascal
// Log all methods of ICalculator
Server.Services.Resolve(ICalculator, Factory);
Factory.SetServiceLog(['*'], LogDB, TOrmServiceLog);

// Log specific methods only
Factory.SetServiceLog(['Add', 'Multiply'], LogDB);

// Exclude slow methods
Server.Services.SetServiceLog(LogDB, TOrmServiceLog, 'GetLargeReport,ExportAll');
```

## 16.X.9. Implementation Patterns

### Dependency Injection

Services can access the container via `TInjectableObjectRest`:

```pascal
type
  TMyService = class(TInjectableObjectRest, IMyService)
  public
    function ProcessData(const Input: RawUtf8): RawUtf8;
  end;

function TMyService.ProcessData(const Input: RawUtf8): RawUtf8;
var
  OtherService: IOtherService;
begin
  // Access server ORM
  Server.Orm.Add(TOrmLog.Create);

  // Resolve other services from container
  if Server.Services.Resolve(IOtherService, OtherService) then
    Result := OtherService.Transform(Input);
end;
```

The `Factory` and `Server` properties are auto-injected by `TServiceFactoryServer.CreateInstance`.

### Custom Callback Implementation

```pascal
type
  TProgressCallback = class(TInterfacedCallback, IProgressCallback)
  public
    procedure OnProgress(Percent: Integer);
  end;

procedure TProgressCallback.OnProgress(Percent: Integer);
begin
  WriteLn('Progress: ', Percent, '%');
end;

// Service method receives callback
function TMyService.LongOperation(const Callback: IProgressCallback): boolean;
var
  I: Integer;
begin
  for I := 1 to 100 do
  begin
    // Do work...
    if Callback <> nil then
      Callback.OnProgress(I); // Async notification to client
  end;
  Result := True;
end;
```

The framework automatically creates `TInterfacedObjectFakeServer` on the server side to route `OnProgress` calls to the client.

### Background Instance Cleanup

Services with `sicClientDriven`, `sicPerSession`, `sicPerUser`, or `sicPerGroup` modes use timeout-based garbage collection:

```pascal
// Set timeout to 10 minutes
Factory.SetTimeoutSec(10 * 60);

// Automatic cleanup in TServiceFactoryServer
function DoInstanceGC(Tix10: cardinal; Final: boolean): PtrInt;
begin
  for i := fInstances.Count - 1 downto 0 do
    if (Tix10 - Inst.LastAccessTix10) * 1024 > fInstanceTimeOut * 1000 then
    begin
      // Release instance
      InstanceFreeOrGC(Inst.Instance);
      fInstances.Delete(i);
    end;
end;
```

The GC runs periodically via `TRestServer` housekeeping timers.

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Section 16.Y: Previous Topic](16.Y-PreviousTopic.md) | [Index](mORMot2-SAD-Index.md) | [Section 16.Z: Next Topic](16.Z-NextTopic.md) |
