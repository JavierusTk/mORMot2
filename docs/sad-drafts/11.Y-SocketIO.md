# 11.Y. Socket.IO Protocol

*Real-Time Event-Driven Communication*

## 11.Y.1. Overview

mORMot 2 implements **Socket.IO**, a widely-adopted bidirectional event-driven communication protocol built on top of **Engine.IO**. This implementation provides seamless interoperability with Node.js Socket.IO servers and clients while maintaining the framework's performance and architectural principles.

### Architecture Layers

```
┌─────────────────────────────────────────────────────────┐
│  Application Layer                                      │
│  ┌──────────────────┬────────────────┬────────────────┐ │
│  │ Event Handlers   │ Namespaces     │ Rooms          │ │
│  └──────────────────┴────────────────┴────────────────┘ │
└─────────────────────────────────────────────────────────┘
                         │
┌─────────────────────────────────────────────────────────┐
│  Socket.IO Layer (mormot.net.ws.core)                   │
│  ┌──────────────────────────────────────────────────┐  │
│  │ TSocketIOPacket: Event/Ack/Connect/Disconnect    │  │
│  │ TSocketIOMessage: Message parsing and routing    │  │
│  │ TSocketIOLocalNamespace: Event dispatching       │  │
│  │ TSocketIORemoteNamespace: Event emission         │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                         │
┌─────────────────────────────────────────────────────────┐
│  Engine.IO Layer (mormot.net.ws.core)                   │
│  ┌──────────────────────────────────────────────────┐  │
│  │ TEngineIOPacket: Open/Close/Ping/Pong/Message    │  │
│  │ TEngineIOAbstract: Session management            │  │
│  │ Heartbeat mechanism (ping/pong)                  │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                         │
┌─────────────────────────────────────────────────────────┐
│  WebSocket Layer (mormot.net.ws.*)                      │
│  ┌──────────────────────────────────────────────────┐  │
│  │ TWebSocketFrame: Binary/Text frames              │  │
│  │ TWebSocketProcess: Frame processing              │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### Key Features

- **Full Protocol Support**: Engine.IO v4 and Socket.IO v4 compliance
- **Namespace Isolation**: Multiple logical channels over a single connection
- **Event-Driven**: Publisher/subscriber pattern with acknowledgments
- **Binary Support**: Automatic handling of text and binary payloads
- **Type Safety**: Pascal records and enumerations for all packet types
- **Node.js Interoperability**: Compatible with Socket.IO JavaScript libraries

---

## 11.Y.2. Engine.IO Base Protocol

### Protocol Overview

**Engine.IO** is the transport layer that provides connection lifecycle management and heartbeat mechanisms. It runs on top of WebSockets and handles the low-level connection details.

### Packet Types

```pascal
TEngineIOPacket = (
  eioOpen,      // (0) Handshake, sent after connection establishment
  eioClose,     // (1) Request connection closure
  eioPing,      // (2) Heartbeat ping (server → client in v4)
  eioPong,      // (3) Heartbeat pong response
  eioMessage,   // (4) Payload carrier (contains Socket.IO messages)
  eioUpgrade,   // (5) Protocol upgrade (not used in WebSocket-only mode)
  eioNoop       // (6) No operation
);
```

### Connection Lifecycle

```
Client                                  Server
  │                                       │
  │──── WebSocket Upgrade Request ───────►│
  │     GET /socket.io/?EIO=4&transport=  │
  │         websocket&t=<random>          │
  │                                       │
  │◄─── HTTP 101 Switching Protocols ────│
  │                                       │
  │◄──────── eioOpen (0) ─────────────────│
  │     {"sid":"<session-id>",            │
  │      "pingTimeout":20000,             │
  │      "pingInterval":25000}            │
  │                                       │
  │◄──────── eioPing (2) ─────────────────│ (every 25s)
  │                                       │
  │──────── eioPong (3) ──────────────────►│
  │                                       │
  │◄─── eioMessage (4) + Socket.IO ──────│
  │                                       │
  │──────── eioClose (1) ─────────────────►│ (graceful shutdown)
  │                                       │
```

### Session Parameters

The `eioOpen` handshake establishes session parameters:

```pascal
TEngineIOAbstract = class(TSynPersistent)
published
  property EngineSid: RawUtf8;      // Session ID (e.g., 'dwy_mNoFzsrMlhINAAAA')
  property Version: integer;        // Protocol version (fixed to 4)
  property PingTimeout: integer;    // Milliseconds (default: 20000)
  property PingInterval: integer;   // Milliseconds (default: 25000)
  property MaxPayload: integer;     // Optional chunk size (default: 0 = unlimited)
end;
```

### Heartbeat Mechanism

Engine.IO v4 implements server-initiated heartbeat:

- **Server sends `eioPing`** every `PingInterval` milliseconds
- **Client must respond** with `eioPong` within `PingTimeout` milliseconds
- **Connection closed** if client fails to respond in time
- Ensures connection liveness and detects network failures

**Example** (default values):
- Server pings every 25 seconds
- Client has 20 seconds to respond
- Effective timeout: 45 seconds of inactivity

---

## 11.Y.3. Socket.IO Packet Layer

### Packet Types

Socket.IO messages are nested inside `eioMessage` frames:

```pascal
TSocketIOPacket = (
  sioConnect,       // (0) Namespace connection request/response
  sioDisconnect,    // (1) Namespace disconnection
  sioEvent,         // (2) Event emission (primary communication method)
  sioAck,           // (3) Event acknowledgment response
  sioConnectError,  // (4) Namespace connection error
  sioBinaryEvent,   // (5) Binary event emission
  sioBinaryAck      // (6) Binary acknowledgment
);
```

### Message Structure

```pascal
TSocketIOMessage = record
  property PacketType: TSocketIOPacket;     // Packet kind
  property NameSpace: pointer;              // Namespace buffer (not null-terminated)
  property NameSpaceLen: PtrInt;            // Namespace length
  property ID: TSocketIOAckID;              // Optional acknowledgment ID
  property BinaryAttachment: cardinal;      // Binary attachment count
  property Sender: TWebSocketProcess;       // Connection context
  // Methods for decoding:
  function DataGet(out Dest: TDocVariantData): boolean;  // Parse JSON
  function NameSpaceIs(const Name: RawUtf8): boolean;
end;
```

### Wire Format

Socket.IO packets follow this text format:

```
<packet-type>[binary-attachments-]<namespace>,<ack-id><json-payload>
```

**Examples**:

```
2["message","Hello"]              → Event on default namespace '/'
2/chat,["message","Hello"]        → Event on '/chat' namespace
21["message","Hello"]             → Event with ack ID 1
3["response","data"]              → Acknowledgment (to ack ID from previous event)
0/admin,{"token":"abc123"}        → Connect to '/admin' namespace with auth
```

### Reserved Event Names

These event names are **reserved** by Socket.IO and cannot be used for custom events:

```pascal
function SocketIOReserved(const event: RawUtf8): boolean;
// Returns true for: 'connect', 'message', 'disconnect'
```

---

## 11.Y.4. Namespaces and Event Routing

### Namespace Concept

**Namespaces** provide logical separation of communication channels over a single WebSocket connection. They are analogous to "rooms" or "channels" in other messaging systems.

```
Single WebSocket Connection
│
├── '/' (default namespace)       → Chat events
├── '/admin'                      → Admin control
├── '/notifications'              → Push notifications
└── '/metrics'                    → Real-time monitoring
```

### Local Namespaces (Receiving Events)

**Local namespaces** handle incoming events from remote peers:

```pascal
TSocketIOLocalNamespace = class(TSocketIONamespace)
  // Register event handlers
  function RegisterEvent(const aEventName: RawUtf8;
    const aCallback: TOnSocketIOEvent): TSocketIOLocalNamespace;

  // Register all published methods as handlers
  procedure RegisterPublishedMethods(aInstance: TObject);

  // Dispatch incoming event to handler
  procedure HandleEvent(const aMessage: TSocketIOMessage;
    aIgnoreUnknownEvent: boolean);
end;
```

**Event Handler Signatures**:

```pascal
// Callback-based handler
TOnSocketIOEvent = function(Sender: TSocketIOLocalNamespace;
  const EventName: RawUtf8; const Data: TDocVariantData): RawJson of object;

// Published method handler (for RegisterPublishedMethods)
TOnSocketIOMethod = function(const Data: TDocVariantData): RawJson of object;
```

**Example** (client receiving events):

```pascal
var
  client: TSocketsIOClient;
  local: TSocketIOLocalNamespace;

// Register event handler for default namespace
local := client.Local('/');
local.RegisterEvent('message',
  function(Sender: TSocketIOLocalNamespace;
           const EventName: RawUtf8;
           const Data: TDocVariantData): RawJson
  begin
    WriteLn('Received: ', Data.ToJson);
    result := ''; // No acknowledgment
  end);

// Or use published methods
type
  TChatHandler = class
  published
    function message(const Data: TDocVariantData): RawJson;
  end;

local.RegisterPublishedMethods(TChatHandler.Create);
```

### Remote Namespaces (Sending Events)

**Remote namespaces** emit events to connected peers:

```pascal
TSocketIORemoteNamespace = class(TSocketIONamespace)
  // Emit event with optional acknowledgment callback
  function SendEvent(const aEventName: RawUtf8;
                     const aDataArray: RawUtf8 = '';
                     const aOnAck: TOnSocketIOAck = nil): TSocketIOAckID;

  // Handle acknowledgment from remote
  procedure Acknowledge(const aMessage: TSocketIOMessage);

  // Cancel pending acknowledgment
  function Discard(aAckID: TSocketIOAckID): boolean;
published
  property Sid: RawUtf8;          // Session ID
  property NameSpace: RawUtf8;    // Namespace path
end;
```

**Example** (client sending events):

```pascal
var
  remote: TSocketIORemoteNamespace;
  ackId: TSocketIOAckID;

// Connect to namespace
remote := client.Connect('/chat');

// Send event without acknowledgment
remote.SendEvent('message', JsonEncodeArray(['Hello', 'World']));

// Send event with acknowledgment callback
ackId := remote.SendEvent('request',
  JsonEncodeArray(['data']),
  procedure(const Message: TSocketIOMessage)
  var
    response: TDocVariantData;
  begin
    if Message.DataGet(response) then
      WriteLn('Server responded: ', response.ToJson);
  end);

// Disconnect from namespace
client.Disconnect(remote);
```

### Namespace Connection Handshake

```
Client                                  Server
  │                                       │
  │────── sioConnect (0) /admin ──────────►│
  │     {"token":"secret"}                │
  │                                       │
  │◄───── sioConnect (0) /admin ──────────│
  │     {"sid":"xyz789"}                  │
  │                                       │
  │◄──── sioEvent (2) /admin ─────────────│
  │     ["welcome","Admin connected"]     │
  │                                       │
```

---

## 11.Y.5. Event Acknowledgments

### Request-Response Pattern

Socket.IO supports **request-response semantics** through acknowledgments:

1. **Sender** emits event with acknowledgment ID
2. **Receiver** processes event and sends `sioAck` with response data
3. **Sender** callback is invoked with response

### Acknowledgment Flow

```
Client                                  Server
  │                                       │
  │─── sioEvent (2) ID=1 ─────────────────►│
  │    ["getData",{"key":"user123"}]      │
  │                                       │
  │    (Server processes request)         │
  │                                       │
  │◄───── sioAck (3) ID=1 ────────────────│
  │    [{"name":"John","age":30}]         │
  │                                       │
  │    (Client callback invoked)          │
  │                                       │
```

### Implementation Details

**Acknowledgment ID Generation**:

```pascal
TSocketIORemoteNamespace = class
private
  fCallbackSafe: TLightLock;              // Thread-safe callback registry
  fCallbacks: array of TSocketIOCallback; // Pending acknowledgments
  fAckIdCursor: TSocketIOAckID;           // Monotonic counter

  function GenerateAckId(const aOnAck: TOnSocketIOAck): TSocketIOAckID;
end;
```

- **Thread-safe**: Callbacks protected by `TLightLock`
- **Efficient storage**: Dynamic array with O(1) void slot reuse
- **Automatic cleanup**: Callbacks removed after invocation or discard

**Example** (request-response):

```pascal
// Client requests data with timeout
var
  ackId: TSocketIOAckID;
  received: boolean = false;

ackId := remote.SendEvent('getData',
  JsonEncodeArray(['user123']),
  procedure(const Message: TSocketIOMessage)
  var
    data: TDocVariantData;
  begin
    if Message.DataGet(data) then
    begin
      WriteLn('User: ', data.U['name']);
      received := true;
    end;
  end);

// Wait for response or timeout
Sleep(5000);
if not received then
begin
  client.Discard(ackId); // Cancel callback
  WriteLn('Request timed out');
end;
```

---

## 11.Y.6. Node.js Interoperability

### JavaScript Client Example

mORMot 2 Socket.IO servers are fully compatible with Node.js Socket.IO clients:

```javascript
// Node.js / Browser client
const io = require('socket.io-client');

// Connect to mORMot 2 server
const socket = io('http://localhost:8080', {
  transports: ['websocket']  // Force WebSocket (no polling)
});

// Listen for events
socket.on('connect', () => {
  console.log('Connected:', socket.id);
});

socket.on('message', (data) => {
  console.log('Received:', data);
});

// Emit event with acknowledgment
socket.emit('getData', { key: 'user123' }, (response) => {
  console.log('Server response:', response);
});

// Namespace example
const adminSocket = io('http://localhost:8080/admin', {
  auth: { token: 'secret' }
});
```

### mORMot 2 Server Implementation

```pascal
uses
  mormot.net.ws.core,
  mormot.net.ws.server;

type
  TMySocketIOServer = class(TWebSocketServer)
  private
    procedure OnSocketIOMessage(Sender: TSocketIOLocalNamespace;
      const EventName: RawUtf8; var Data: TDocVariantData);
  public
    constructor Create;
  end;

constructor TMySocketIOServer.Create;
var
  local: TSocketIOLocalNamespace;
begin
  inherited Create('8080', nil, nil, 'socketio');

  // Register event handlers for default namespace
  local := TSocketIOLocalNamespace.Create(nil, '/');
  local.RegisterEvent('getData',
    function(Sender: TSocketIOLocalNamespace;
             const EventName: RawUtf8;
             const Data: TDocVariantData): RawJson
    var
      key: RawUtf8;
      response: variant;
    begin
      key := Data.U['key'];
      // Fetch data from database...
      response := _ObjFast(['name', 'John', 'age', 30]);
      result := VariantSaveJson(response); // Return as acknowledgment
    end);
end;
```

### Protocol Compatibility

| Feature | mORMot 2 | Node.js Socket.IO |
|---------|----------|-------------------|
| Engine.IO v4 | ✓ | ✓ |
| Socket.IO v4 | ✓ | ✓ |
| WebSocket transport | ✓ | ✓ |
| HTTP polling | ✗ | ✓ |
| Namespaces | ✓ | ✓ |
| Rooms (server broadcast) | Manual | ✓ |
| Binary events | ✓ | ✓ |
| Acknowledgments | ✓ | ✓ |
| Auto-reconnection | ✓ (client) | ✓ |

**Note**: mORMot 2 implements **WebSocket-only** transport. The HTTP long-polling fallback (used by Socket.IO for older browsers) is not supported. Clients must support WebSockets.

---

## 11.Y.7. Performance Characteristics

### Memory Efficiency

**Namespace Overhead**:
- Local namespace: ~200 bytes + event handlers
- Remote namespace: ~150 bytes + pending acknowledgments
- Multiple namespaces share single WebSocket connection

**Message Parsing**:
- Zero-copy parsing for namespace/data fields
- In-place JSON decoding with `TDocVariantData`
- No intermediate string allocations

### Scalability

**Concurrent Connections**:
- Each connection: 1 WebSocket + 1 Engine.IO session
- Heartbeat: 2 packets per `PingInterval` (default: 25s)
- Event dispatching: O(n) lookup in event handlers (hash-based with `TDynArrayHashed`)

**Broadcast Optimization**:
```pascal
// Broadcast to all connections
procedure TWebSocketServer.WebSocketBroadcast(const aFrame: TWebSocketFrame);
// Broadcast to subset of connections
procedure TWebSocketServer.WebSocketBroadcast(const aFrame: TWebSocketFrame;
  const aClientsConnectionID: TIntegerDynArray);
```

### Benchmarks (Typical)

| Operation | Latency | Notes |
|-----------|---------|-------|
| Event dispatch (local) | ~0.01 ms | Hash lookup + callback |
| Event emission (remote) | ~0.05 ms | JSON encoding + frame send |
| Acknowledgment roundtrip | ~1-5 ms | Network + processing |
| Namespace connection | ~2-10 ms | Handshake + registration |
| Heartbeat overhead | ~0.1% CPU | At 25s interval |

**Note**: Benchmarks on typical server hardware (Xeon, 10 Gbps network). Actual performance depends on application logic and network conditions.

---

## 11.Y.8. Common Usage Patterns

### Chat Application

```pascal
// Server-side chat room
type
  TChatRoom = class
  private
    fUsers: TRawUtf8DynArray;
  published
    function join(const Data: TDocVariantData): RawJson;
    function message(const Data: TDocVariantData): RawJson;
    function leave(const Data: TDocVariantData): RawJson;
  end;

function TChatRoom.message(const Data: TDocVariantData): RawJson;
var
  user, text: RawUtf8;
begin
  user := Data.U['user'];
  text := Data.U['text'];

  // Broadcast to all users (manual implementation)
  // mORMot 2 doesn't have built-in rooms like Node.js
  // Use WebSocketBroadcast() or maintain user connection list

  result := ''; // No acknowledgment needed
end;
```

### Real-Time Notifications

```pascal
// Client-side notification listener
local := client.Local('/notifications');
local.RegisterEvent('alert',
  function(Sender: TSocketIOLocalNamespace;
           const EventName: RawUtf8;
           const Data: TDocVariantData): RawJson
  begin
    ShowNotification(Data.U['title'], Data.U['message']);
    result := ''; // No ack
  end);

// Server-side notification emitter
procedure TNotificationService.SendAlert(const aUserId: RawUtf8;
  const aTitle, aMessage: RawUtf8);
var
  remote: TSocketIORemoteNamespace;
begin
  remote := GetUserNamespace(aUserId, '/notifications');
  if remote <> nil then
    remote.SendEvent('alert',
      JsonEncodeArray([_ObjFast(['title', aTitle, 'message', aMessage])]));
end;
```

### Reconnection Handling

```pascal
// Client auto-reconnection
client := TSocketsIOClient.Create('http://localhost:8080');
client.OnReconnect := procedure(Sender: TSocketsIOClient)
  begin
    WriteLn('Reconnected after network failure');
    // Re-subscribe to namespaces automatically handled by framework
  end;

client.OnDisconnect := procedure(Sender: TSocketsIOClient)
  begin
    WriteLn('Disconnected, will retry...');
  end;
```

---

## 11.Y.9. Best Practices

### Event Handler Design

**✓ DO**:
- Use published methods for clean handler organization
- Return empty string if no acknowledgment needed
- Handle malformed data gracefully (check `DataGet` result)
- Use case-sensitive event names (Socket.IO standard)

**✗ DON'T**:
- Block event handlers (they run synchronously)
- Raise exceptions for unknown events (use `snoIgnoreUnknownEvent`)
- Use reserved event names: `'connect'`, `'message'`, `'disconnect'`
- Forget to disconnect namespaces on cleanup

### Namespace Strategy

**Single Namespace** (default `/`):
- Simple use cases
- No logical separation needed
- Lower overhead

**Multiple Namespaces**:
- Different authorization levels (`/public`, `/admin`)
- Separate concerns (`/chat`, `/notifications`)
- Isolated event handlers

### Acknowledgment Management

```pascal
// Always discard acknowledgments on form close
procedure TMyForm.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  // Cancel pending acknowledgments
  if Assigned(fRemoteNamespace) then
    fRemoteNamespace.Discard(fPendingAckCallback);
end;
```

### Security Considerations

**Authentication**:
```pascal
// Namespace connection with auth
remote := client.Connect('/admin',
  JsonEncodeArray([_ObjFast(['token', GetAuthToken])]),
  5000); // 5s timeout

// Server validates token in connect handler
```

**Input Validation**:
```pascal
function THandler.processData(const Data: TDocVariantData): RawJson;
begin
  // Validate input structure
  if not Data.Exists('userId') or not Data.Exists('action') then
  begin
    result := JsonEncodeArray(['error', 'Invalid request']);
    exit;
  end;

  // Process sanitized data...
end;
```

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Section 11.X: WebSockets Async Server](11.X-WebSocketsAsync.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 12: Security & Encryption](mORMot2-SAD-Chapter-12.md) |
