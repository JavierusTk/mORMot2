# 4.Y. Threading and Background Processing

*Controlled Concurrency*

## Overview

mORMot 2 provides a comprehensive set of threading utilities in `mormot.core.threads.pas` for background processing, parallel execution, and thread pool management. These classes build on the foundation of `TSynEvent`, `TLightLock`, and synchronization primitives to deliver high-level abstractions for common threading patterns.

### Key Components

- **TSynBackgroundThread** variants - Managed background execution with lifecycle hooks
- **TSynParallelProcess** - Parallel work distribution across thread pools
- **TBlockingProcess** - Semaphore-based synchronization for async/blocking patterns
- **TSynThreadPool** - Server-oriented IOCP/event-driven thread pool

---

## 4.Y.1. Background Thread Abstraction

### TSynBackgroundThreadAbstract

Base class for background thread execution with proper lifecycle management.

```pascal
TSynBackgroundThreadAbstract = class(TThreadAbstract)
public
  constructor Create(const aThreadName: RawUtf8;
    const OnBeforeExecute: TOnNotifyThread = nil;
    const OnAfterExecute: TOnNotifyThread = nil;
    CreateSuspended: boolean = false);

  procedure WaitForNotExecuting(maxMS: integer = 500);
  function SleepOrTerminated(MS: cardinal): boolean;

  property Pause: boolean;
  property ProcessEvent: TSynEvent;
end;
```

**Key features**:
- Thread-safe termination via `TerminatedSet()`
- Lifecycle callbacks (`OnBeforeExecute`, `OnAfterExecute`) for resource management
- Execution state tracking (`exCreated`, `exRun`, `exFinished`)
- Safe destruction with `WaitForNotExecuting()` to avoid GPF

**Common pattern**:
```pascal
// Nest thread execution within TRestServer context
fBackgroundThread := TSynBackgroundThreadProcess.Create(
  'MyBackgroundTask',
  OnProcess,
  1000,  // 1 second interval
  Server.BeginCurrentThread,  // Called before each task
  Server.EndCurrentThread     // Called after each task
);
```

---

## 4.Y.2. Method-Based Background Threads

### TSynBackgroundThreadMethodAbstract

Allows background execution of methods with UI responsiveness support.

```pascal
type
  TOnIdleSynBackgroundThread = procedure(Sender: TSynBackgroundThreadAbstract;
    ElapsedMS: integer) of object;

  TSynBackgroundThreadMethodAbstract = class(TSynBackgroundThreadAbstract)
  public
    function RunAndWait(OpaqueParam: pointer): boolean;

    property OnIdle: TOnIdleSynBackgroundThread;
    property OnIdleBackgroundThreadActive: boolean;
  end;
```

**Typical use**: Long-running network calls while keeping UI responsive.

```pascal
procedure TMyForm.OnIdleProcess(Sender: TSynBackgroundThreadAbstract;
  ElapsedMS: integer);
begin
  if ElapsedMS = 0 then
    StatusLabel.Caption := 'Processing...'
  else if ElapsedMS = -1 then
    StatusLabel.Caption := 'Done'
  else
    Application.ProcessMessages;  // Keep UI responsive
end;

// In TRestClientUri.Uri() implementation:
fBackgroundThread.OnIdle := OnIdleProcess;
fBackgroundThread.RunAndWait(@Request);  // Blocks caller but UI stays alive
```

**State machine**:
```
flagIdle → flagStarted → flagFinished → flagIdle (via Reset)
           ↓
           flagDestroying (on termination)
```

### Concrete Implementations

#### TSynBackgroundThreadEvent

Execute method callbacks with context parameter.

```pascal
TSynBackgroundThreadEvent = class(TSynBackgroundThreadMethodAbstract)
public
  constructor Create(const aOnProcess: TOnProcessSynBackgroundThread;
    const aOnIdle: TOnIdleSynBackgroundThread;
    const aThreadName: RawUtf8);

  property OnProcess: TOnProcessSynBackgroundThread;
end;

// Usage:
fThread := TSynBackgroundThreadEvent.Create(ProcessData, OnIdle, 'DataProcessor');
fThread.RunAndWait(@MyContext);

procedure TMyClass.ProcessData(Sender: TSynBackgroundThreadEvent;
  ProcessOpaqueParam: pointer);
begin
  // Runs in background thread with MyContext parameter
end;
```

#### TSynBackgroundThreadMethod

Execute simple `TThreadMethod` callbacks.

```pascal
fThread := TSynBackgroundThreadMethod.Create(nil, 'QuickTask');
fThread.RunAndWait(
  procedure
  begin
    // Anonymous method executed in background
  end
);
```

#### TSynBackgroundThreadProcedure

Execute global procedure callbacks.

```pascal
procedure MyGlobalProc(ProcessOpaqueParam: pointer);
begin
  // Process data
end;

fThread := TSynBackgroundThreadProcedure.Create(@MyGlobalProc, nil, 'Worker');
fThread.RunAndWait(@Context);
```

---

## 4.Y.3. Periodic Background Processing

### TSynBackgroundThreadProcess

Executes a callback at regular intervals or on-demand.

```pascal
TSynBackgroundThreadProcess = class(TSynBackgroundThreadAbstract)
public
  constructor Create(const aThreadName: RawUtf8;
    const aOnProcess: TOnSynBackgroundThreadProcess;
    aOnProcessMS: cardinal;
    const aOnBeforeExecute: TOnNotifyThread = nil;
    const aOnAfterExecute: TOnNotifyThread = nil;
    aStats: TSynMonitorClass = nil;
    CreateSuspended: boolean = false);

  property OnProcess: TOnSynBackgroundThreadProcess;
  property OnProcessMS: cardinal;  // Interval in milliseconds
  property OnException: TNotifyEvent;
  property Stats: TSynMonitor;
end;
```

**Example**: Database cleanup task

```pascal
fCleanupThread := TSynBackgroundThreadProcess.Create(
  'DBCleanup',
  procedure(Sender: TSynBackgroundThreadProcess)
  begin
    Database.DeleteOldRecords;
  end,
  60000  // Run every 60 seconds
);

// Trigger immediate execution without waiting
fCleanupThread.ProcessEvent.SetEvent;
```

### TSynBackgroundTimer

Multi-task scheduler with FIFO message queues per task.

```pascal
TSynBackgroundTimer = class(TSynBackgroundThreadProcess)
public
  procedure Enable(const aOnProcess: TOnSynBackgroundTimerProcess;
    aOnProcessSecs: cardinal);
  function Disable(const aOnProcess: TOnSynBackgroundTimerProcess): boolean;

  function EnQueue(const aOnProcess: TOnSynBackgroundTimerProcess;
    const aMsg: RawUtf8; aExecuteNow: boolean = false): boolean;
  function DeQueue(const aOnProcess: TOnSynBackgroundTimerProcess;
    const aMsg: RawUtf8): boolean;
  function ExecuteNow(const aOnProcess: TOnSynBackgroundTimerProcess): boolean;

  property Processing: boolean;
end;
```

**Example**: Multi-tenant background tasks

```pascal
type
  TOnSynBackgroundTimerProcess = procedure(Sender: TSynBackgroundTimer;
    const Msg: RawUtf8) of object;

fTimer := TSynBackgroundTimer.Create('TenantTasks');

// Register periodic tasks
fTimer.Enable(CleanupTenant, 300);  // Every 5 minutes
fTimer.Enable(SyncData, 60);        // Every minute

// Queue message for specific tenant
fTimer.EnQueue(CleanupTenant, 'TENANT123', true);

procedure TMyServer.CleanupTenant(Sender: TSynBackgroundTimer;
  const Msg: RawUtf8);
begin
  if Msg = '' then
    // Periodic execution - process all tenants
  else
    // Process specific tenant from message queue
    CleanupTenantData(Msg);
end;
```

**Message FIFO behavior**:
- Each registered task has its own FIFO queue
- `EnQueue()` adds messages, processed sequentially on next execution
- Empty `Msg` parameter indicates periodic execution (no queued messages)

**Use in mORMot**: `TRest.TimerEnable/TimerDisable` use `TRestBackgroundTimer` (inherited from `TSynBackgroundTimer`).

---

## 4.Y.4. Blocking Process Synchronization

### TBlockingProcess

Semaphore for async-to-blocking pattern conversion.

```pascal
TBlockingEvent = (evNone, evWaiting, evTimeOut, evRaised);

TBlockingProcess = class(TSynEvent)
public
  constructor Create(aTimeOutMs: integer); overload;
  constructor Create(aTimeOutMs: integer; aSafe: PSynLocker); overload;

  function WaitFor: TBlockingEvent; overload;
  function WaitFor(TimeOutMS: integer): TBlockingEvent; overload;
  function NotifyFinished(alreadyLocked: boolean = false): boolean;
  function Reset: boolean;

  property Event: TBlockingEvent;
  property TimeOutMs: integer;
end;
```

**Pattern**: Convert asynchronous callback to blocking call

```pascal
// Caller thread (blocking)
procedure TMyClient.SendRequest;
var
  Process: TBlockingProcess;
begin
  Process := TBlockingProcess.Create(5000);  // 5 second timeout
  try
    AsyncEngine.SendRequest(RequestData, Process.Call);

    case Process.WaitFor of  // Block until callback or timeout
      evRaised:  ShowMessage('Success');
      evTimeOut: ShowMessage('Timeout');
    end;
  finally
    Process.Free;
  end;
end;

// Callback from async engine (background thread)
procedure TAsyncEngine.OnRequestComplete(Call: integer);
var
  Process: TBlockingProcess;
begin
  Process := ProcessPool.FromCall(Call);
  if Process <> nil then
  begin
    // Set result data here
    Process.NotifyFinished;  // Release WaitFor
  end;
end;
```

### TBlockingProcessPool

Manages reusable `TBlockingProcess` instances with unique call identifiers.

```pascal
TBlockingProcessPool = class(TSynPersistent)
public
  constructor Create(aClass: TBlockingProcessPoolItemClass = nil);

  function NewProcess(aTimeOutMs: integer): TBlockingProcessPoolItem;
  function FromCall(call: TBlockingProcessPoolCall;
    locked: boolean = false): TBlockingProcessPoolItem;
end;

TBlockingProcessPoolItem = class(TBlockingProcess)
published
  property Call: TBlockingProcessPoolCall;  // Unique ID
end;
```

**Example**: REST server callback handling

```pascal
fPool := TBlockingProcessPool.Create;

// Client request
function TRestClientAsync.ExecuteBlocking(const Request: RawUtf8): RawUtf8;
var
  Process: TBlockingProcessPoolItem;
begin
  Process := fPool.NewProcess(10000);
  try
    SendAsync(Request, Process.Call);  // Pass Call ID to async handler

    if Process.WaitFor = evRaised then
      Result := Process.ResponseData
    else
      raise ETimeOut.Create('Request timeout');
  finally
    Process.Reset;  // Return to pool
  end;
end;

// Async callback
procedure OnAsyncComplete(Call: TBlockingProcessPoolCall; const Response: RawUtf8);
var
  Process: TBlockingProcessPoolItem;
begin
  Process := fPool.FromCall(Call, true);  // Retrieve by ID (locked)
  if Process <> nil then
  try
    Process.ResponseData := Response;
    Process.NotifyFinished(true);  // Release WaitFor (already locked)
  finally
    Process.Unlock;
  end;
end;
```

**Benefits**:
- Reuses `TEvent` system resources
- Thread-safe call ID tracking
- Ideal for DDD async/blocking emulation

---

## 4.Y.5. Parallel Execution

### TSynParallelProcess

Distributes index-based work across a thread pool.

```pascal
type
  TOnSynParallelProcess = procedure(IndexStart, IndexStop: integer) of object;

  TSynParallelProcess = class(TSynPersistent)
  public
    constructor Create(ThreadPoolCount: integer; const ThreadName: RawUtf8;
      const OnBeforeExecute: TOnNotifyThread = nil;
      const OnAfterExecute: TOnNotifyThread = nil;
      MaxThreadPoolCount: integer = 32);

    procedure ParallelRunAndWait(const Method: TOnSynParallelProcess;
      MethodCount: integer; const OnMainThreadIdle: TNotifyEvent = nil);

    property ParallelRunCount: integer;
    property ThreadPoolCount: integer;
  end;
```

**Example**: Parallel image processing

```pascal
const
  IMAGES_COUNT = 1000;
var
  Parallel: TSynParallelProcess;
begin
  Parallel := TSynParallelProcess.Create(
    SystemInfo.dwNumberOfProcessors,  // One thread per CPU core
    'ImageProcessor'
  );
  try
    Parallel.ParallelRunAndWait(
      procedure(IndexStart, IndexStop: integer)
      var
        i: integer;
      begin
        for i := IndexStart to IndexStop do
          ProcessImage(Images[i]);  // Each thread handles subset of images
      end,
      IMAGES_COUNT
    );
  finally
    Parallel.Free;
  end;
end;
```

**Characteristics**:
- Work split evenly across threads: `0..MethodCount-1` divided by `ThreadPoolCount`
- Each thread processes contiguous index range
- Caller blocks until all threads complete
- If `ThreadPoolCount=0`, runs in current thread (no parallelism)
- `OnMainThreadIdle` allows UI responsiveness during wait

**Use case**: CPU-bound operations on large datasets (compression, hashing, parsing).

---

## 4.Y.6. Server Thread Pool

### TSynThreadPool

Production-grade thread pool for server applications (HTTP handlers, etc.).

```pascal
TSynThreadPool = class
protected
  procedure Task(aCaller: TSynThreadPoolWorkThread;
    aContext: pointer); virtual; abstract;
  procedure TaskAbort(aContext: pointer); virtual;
public
  {$ifdef USE_WINIOCP}
  constructor Create(NumberOfThreads: integer = 32;
    aOverlapHandle: THandle = INVALID_HANDLE_VALUE;
    const aName: RawUtf8 = '');
  {$else}
  constructor Create(NumberOfThreads: integer = 32;
    aQueuePendingContext: boolean = false;
    const aName: RawUtf8 = '');
  {$endif}

  function Push(aContext: pointer; aWaitOnContention: boolean = false): boolean;

  property WorkThreadCount: integer;
  property RunningThreads: integer;
  property ContentionAbortCount: cardinal;
  property ContentionAbortDelay: integer;  // Default 5000ms
  property PendingContextCount: integer;
end;
```

**Platform implementation**:
- **Windows**: I/O Completion Ports (IOCP) with kernel queue
- **POSIX**: Event-driven with optional internal context queue

**Example**: HTTP request handler

```pascal
type
  THttpThreadPool = class(TSynThreadPool)
  protected
    procedure Task(aCaller: TSynThreadPoolWorkThread;
      aContext: pointer); override;
    procedure TaskAbort(aContext: pointer); override;
  end;

procedure THttpThreadPool.Task(aCaller: TSynThreadPoolWorkThread;
  aContext: pointer);
var
  Request: PHttpRequest absolute aContext;
begin
  try
    ProcessHttpRequest(Request);
  finally
    Dispose(Request);  // Cleanup context
  end;
end;

procedure THttpThreadPool.TaskAbort(aContext: pointer);
begin
  Dispose(PHttpRequest(aContext));  // Called on pool shutdown
end;

// Server accept loop
while not Terminated do
begin
  Connection := Accept;
  New(Request);
  Request.Connection := Connection;

  if not fThreadPool.Push(Request) then
  begin
    // Pool full - reject connection
    Connection.Close;
    Dispose(Request);
  end;
end;
```

**Contention handling**:
- `Push()` returns `false` if all threads busy (POSIX without queue)
- `aWaitOnContention=true`: Retry for up to `ContentionAbortDelay` ms
- Monitor `ContentionCount` and `ContentionAbortCount` to tune `WorkThreadCount`

**Statistics**:
```pascal
// Tune thread pool based on metrics
if Pool.ContentionAbortCount > 100 then
  LogWarning('High contention - consider increasing WorkThreadCount');

AvgContentionTime := Pool.ContentionTime / Pool.ContentionCount;
```

**Use in mORMot**: `THttpServer` and `THttpApiServer` use `TSynThreadPool` for connection handling.

---

## 4.Y.7. Thread Pool Comparison

| Class | Purpose | Lifecycle | Queuing | Best For |
|-------|---------|-----------|---------|----------|
| `TSynBackgroundThreadProcess` | Periodic single task | Long-lived | Event trigger | Timers, heartbeats |
| `TSynBackgroundTimer` | Multiple periodic tasks | Long-lived | Per-task FIFO | Multi-tenant schedulers |
| `TSynParallelProcess` | Index-based parallelism | On-demand | N/A (blocking) | CPU-bound batch work |
| `TSynThreadPool` | Server request handling | Long-lived | IOCP/internal | I/O-bound servers |

---

## 4.Y.8. Best Practices

### Resource Management

**Always use lifecycle callbacks for context-sensitive resources**:

```pascal
// Database connections require thread context initialization
fWorker := TSynBackgroundThreadProcess.Create(
  'DBWorker',
  ProcessData,
  1000,
  procedure(Sender: TThread)
  begin
    // Called in worker thread before first task
    TMyConnection(Sender.Tag).Open;
  end,
  procedure(Sender: TThread)
  begin
    // Called in worker thread after last task
    TMyConnection(Sender.Tag).Close;
  end
);
```

### Exception Handling

**Background threads must handle exceptions internally**:

```pascal
fTimer := TSynBackgroundTimer.Create('SafeTimer');
fTimer.OnException := procedure(Sender: TObject)
  begin
    LogException(Exception(Sender));  // Log but don't propagate
  end;
```

**Method-based threads propagate exceptions to caller**:

```pascal
try
  fThread.RunAndWait(@Context);
except
  on E: Exception do
    // Exception raised in background thread is re-raised here
end;
```

### Thread Count Tuning

**Match pool size to workload type**:

```pascal
// CPU-bound: One thread per core
fParallel := TSynParallelProcess.Create(
  SystemInfo.dwNumberOfProcessors,
  'CPUWork'
);

// I/O-bound: Oversubscribe cores (waiting threads don't consume CPU)
fHttpPool := THttpThreadPool.Create(
  SystemInfo.dwNumberOfProcessors * 4,
  {$ifdef MSWINDOWS} IOCPHandle {$endif}
);

// Adjust dynamically based on contention
ThreadCountAdjust(PoolCount);  // Handles platform quirks (ARM, etc.)
```

### Avoid Deadlocks

**Never call `RunAndWait()` from `OnIdle` callback of same thread**:

```pascal
// WRONG - deadlock!
procedure TForm.OnIdle(Sender: TSynBackgroundThreadAbstract; ElapsedMS: integer);
begin
  if NeedMoreWork then
    fThread.RunAndWait(@NewContext);  // Recursive wait = deadlock
end;

// CORRECT - check active state
procedure TForm.OnIdle(Sender: TSynBackgroundThreadAbstract; ElapsedMS: integer);
begin
  if NeedMoreWork and not fThread.OnIdleBackgroundThreadActive then
    fThread.RunAndWait(@NewContext);  // Safe
end;
```

### Graceful Shutdown

**Use `WaitForNotExecuting()` for clean finalization**:

```pascal
destructor TMyServer.Destroy;
begin
  fBackgroundThread.Terminate;  // Signal termination
  fBackgroundThread.ProcessEvent.SetEvent;  // Wake up if sleeping
  fBackgroundThread.WaitForNotExecuting(5000);  // Wait up to 5s
  fBackgroundThread.Free;
  inherited;
end;
```

---

## Summary

mORMot 2's threading utilities provide production-ready abstractions for:
- **Background execution** with UI responsiveness (`TSynBackgroundThreadMethodAbstract`)
- **Periodic tasks** with message queues (`TSynBackgroundTimer`)
- **Async/blocking patterns** with semaphores (`TBlockingProcess`)
- **Parallel work distribution** across cores (`TSynParallelProcess`)
- **High-performance server pools** with IOCP support (`TSynThreadPool`)

All classes integrate with mORMot's lifecycle management (BeginCurrentThread/EndCurrentThread), logging infrastructure, and exception handling patterns, ensuring robust multi-threaded server and client applications.

---

**See also**:
- Section 4.X: Thread Synchronization (TSynEvent, TLightLock)
- Section 9.X: HTTP Server Threading (THttpServer internals)
- `mormot.core.threads.pas` source documentation
