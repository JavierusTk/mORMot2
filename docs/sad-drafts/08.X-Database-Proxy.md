# 8.X. Database Proxy System

*Remote Access via HTTP*

## 8.X.1. Multi-Tier Database Architecture

The **Database Proxy System** in `mormot.db.proxy` enables **remote HTTP access** to any `mormot.db.sql` database connection using an efficient proprietary binary protocol. This multi-tier architecture allows client applications to execute database operations through HTTP/HTTPS without direct database connectivity.

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLIENT TIER                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  Application Code                                         │  │
│  │  ┌──────────────────────────────────────────────────┐     │  │
│  │  │  TSqlDBSocketConnectionProperties                │     │  │
│  │  │  TSqlDBWinHttpConnectionProperties               │     │  │
│  │  │  TSqlDBCurlConnectionProperties                  │     │  │
│  │  └──────────────────────────────────────────────────┘     │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                           │
                           │ HTTP/HTTPS
                           │ Binary Protocol
                           │ (SynLZ compressed + encrypted)
                           │
┌─────────────────────────────────────────────────────────────────┐
│                         SERVER TIER                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  TSqlDBServerSockets / TSqlDBServerHttpApi               │  │
│  │  ┌──────────────────────────────────────────────────┐     │  │
│  │  │  TSqlDBRemoteConnectionProtocol                  │     │  │
│  │  │  - Authentication                                │     │  │
│  │  │  - Encryption/Compression                        │     │  │
│  │  │  - Transaction management                        │     │  │
│  │  └──────────────────────────────────────────────────┘     │  │
│  └───────────────────────────────────────────────────────────┘  │
│                           │                                     │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  Any TSqlDBConnectionProperties Implementation           │  │
│  │  (Oracle, MSSQL, PostgreSQL, SQLite3, etc.)             │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                           │
                           │ Native DB Protocol
                           │
┌─────────────────────────────────────────────────────────────────┐
│                         DATABASE TIER                           │
│                     (Any supported RDBMS)                       │
└─────────────────────────────────────────────────────────────────┘
```

### Key Benefits

- **Database Independence**: Client applications are completely decoupled from the database backend
- **Zero Database Driver Deployment**: No database client libraries needed on client machines
- **Centralized Access Control**: All database access funneled through a single authenticated endpoint
- **Network Efficiency**: Binary protocol with compression reduces network overhead vs. raw SQL protocols
- **Security**: Built-in encryption and authentication layer

---

## 8.X.2. Proxy Protocol Commands

The proxy protocol implements **18 specialized commands** for database operations, metadata access, and session management.

### Command Types

#### Session Commands

| Command | Input | Output | Purpose |
|---------|-------|--------|---------|
| `cGetToken` | - | `Int64` | Retrieve authentication token |
| `cGetDbms` | User hash | `TSqlDBDefinition` | Authenticate and get DBMS type |
| `cConnect` | - | - | Open database connection |
| `cDisconnect` | - | - | Close database connection |
| `cQuit` | - | - | End session and cleanup |

#### Transaction Commands

| Command | Input | Output | Purpose |
|---------|-------|--------|---------|
| `cTryStartTransaction` | - | `boolean` | Attempt transaction start |
| `cCommit` | - | - | Commit active transaction |
| `cRollback` | - | - | Rollback active transaction |
| `cServerTimestamp` | - | `TTimeLog` | Get server current timestamp |

#### Metadata Commands

| Command | Input | Output | Purpose |
|---------|-------|--------|---------|
| `cGetFields` | Table name | `TSqlDBColumnDefineDynArray` | Retrieve column definitions |
| `cGetIndexes` | Table name | `TSqlDBIndexDefineDynArray` | Retrieve index definitions |
| `cGetTableNames` | - | `TRawUtf8DynArray` | List all table names |
| `cGetForeignKeys` | - | `TSynNameValue` | Retrieve foreign key relationships |

#### Execution Commands

| Command | Input | Output | Purpose |
|---------|-------|--------|---------|
| `cExecute` | SQL + Params | Update count | Execute non-query statement |
| `cExecuteToBinary` | SQL + Params | Binary rowset | Execute and return binary data |
| `cExecuteToJson` | SQL + Params | JSON rowset | Execute and return JSON (compact) |
| `cExecuteToExpandedJson` | SQL + Params | JSON rowset | Execute and return JSON (expanded) |

#### Error Handling

| Command | Purpose |
|---------|---------|
| `cExceptionRaised` | Server-side exception relay to client |

### Command Execution Structure

All execution commands use the `TSqlDBProxyConnectionCommandExecute` structure:

```pascal
TSqlDBProxyConnectionCommandExecute = packed record
  Sql: RawUtf8;                    // SQL statement
  Params: TSqlDBParamDynArray;     // Bound parameters
  ArrayCount: integer;             // For batch operations
  Force: TSqlDBProxyConnectionCommandExecuteForce; // Execution flags
end;
```

**Force Flags**:
- `fBlobAsNull`: Treat BLOBs as NULL in results
- `fDateWithMS`: Include milliseconds in datetime values
- `fNoUpdateCount`: Skip UpdateCount retrieval for performance

---

## 8.X.3. Server Implementation

### Server Classes

#### TSqlDBServerAbstract

**Abstract base class** for database proxy servers providing core processing logic.

```pascal
constructor Create(
  aProperties: TSqlDBConnectionProperties;
  const aDatabaseName: RawUtf8;
  const aPort: RawUtf8 = SYNDB_DEFAULT_HTTP_PORT; // '8092'
  const aUserName: RawUtf8 = '';
  const aPassword: RawUtf8 = '';
  aHttps: boolean = false;
  aThreadPoolCount: integer = 1;
  aProtocol: TSqlDBProxyConnectionProtocolClass = nil;
  aThreadMode: TSqlDBConnectionPropertiesThreadSafeThreadingMode = tmMainConnection;
  aAuthenticate: TSynAuthenticationAbstract = nil
);
```

**Key Properties**:
- `Properties: TSqlDBConnectionProperties` - The underlying database connection
- `Port: RawUtf8` - HTTP server port
- `DatabaseName: RawUtf8` - URI endpoint name
- `Protocol: TSqlDBProxyConnectionProtocol` - Communication protocol handler
- `ProcessLocked: boolean` - Critical section protection for single-threaded mode

#### TSqlDBServerSockets

**User-mode socket server** implementation via `THttpServer`.

```pascal
// Example: Publish Oracle database via HTTP
var
  Props: TOracleSqlDBConnectionProperties;
  Server: TSqlDBServerSockets;
begin
  Props := TOracleSqlDBConnectionProperties.Create(
    'server', 'database', 'user', 'password');
  Server := TSqlDBServerSockets.Create(
    Props, 'mydb', '8092', 'admin', 'secret');
  try
    WriteLn('Server running on http://localhost:8092/mydb');
    ReadLn;
  finally
    Server.Free;
    Props.Free;
  end;
end;
```

**Characteristics**:
- One thread per client connection
- Suitable for database providers requiring per-thread isolation
- Works on all platforms (Windows, Linux, macOS)

#### TSqlDBServerHttpApi

**Windows-only kernel-mode HTTP server** via `http.sys`.

```pascal
{$ifdef USEHTTPSYS}
Server := TSqlDBServerHttpApi.Create(
  Props, 'mydb', '8092', 'admin', 'secret');
{$endif}
```

**Characteristics**:
- High-performance kernel-mode HTTP processing
- Thread pool architecture
- Requires administrator rights for URI registration
- Windows-specific (requires `http.sys` driver)

### Protocol Layer

#### TSqlDBProxyConnectionProtocol

**Base protocol class** with no encryption/compression.

```pascal
procedure RemoteProcessMessage(
  const Input: RawUtf8;
  out Output: RawUtf8;
  Connection: TSqlDBConnection
); virtual;
```

Processes incoming binary messages and executes the corresponding database operations.

#### TSqlDBRemoteConnectionProtocol

**Production protocol class** with security features:

- **SynLZ Compression**: Reduces payload size (typically 70-80% compression ratio)
- **Digital Signature**: CRC32C checksum for integrity verification
- **Symmetric Encryption**: Simple XOR-based encryption with `REMOTE_MAGIC` key

```pascal
function HandleInput(const input: RawByteString): RawByteString; override;
// 1. Decrypt
// 2. Decompress (with CRC32C verification)
// 3. Return plaintext

function HandleOutput(const output: RawByteString): RawByteString; override;
// 1. Compress (with CRC32C)
// 2. Encrypt
// 3. Return ciphertext
```

---

## 8.X.4. Client Implementation

### Client Classes

#### TSqlDBSocketConnectionProperties

**Cross-platform socket-based client** using `THttpClientSocket`.

```pascal
// Client usage example
var
  Props: TSqlDBSocketConnectionProperties;
  Conn: TSqlDBConnection;
  Stmt: ISqlDBStatement;
begin
  Props := TSqlDBSocketConnectionProperties.Create(
    'localhost:8092', 'mydb', 'admin', 'secret');
  try
    Conn := Props.NewConnection;
    Stmt := Conn.NewStatementPrepared(
      'SELECT * FROM Customers WHERE Country = ?', true);
    Stmt.Bind(1, 'France');
    Stmt.ExecutePrepared;
    while Stmt.Step do
      WriteLn(Stmt.ColumnUtf8(0));
  finally
    Props.Free;
  end;
end;
```

**Features**:
- Keep-alive connections (configurable via `KeepAliveMS` property)
- Works on all platforms
- Simple, efficient socket implementation

#### TSqlDBWinHttpConnectionProperties

**Windows HTTP client** via WinHTTP API.

```pascal
{$ifdef USEWININET}
Props := TSqlDBWinHttpConnectionProperties.Create(
  'https://server:8092', 'mydb', 'admin', 'secret');
{$endif}
```

**Benefits**:
- Native Windows HTTP stack integration
- Proxy server support
- SSL/TLS certificate validation

#### TSqlDBWinINetConnectionProperties

**Windows Internet Explorer HTTP client** via WinINet API.

```pascal
{$ifdef USEWININET}
Props := TSqlDBWinINetConnectionProperties.Create(
  'https://server:8092', 'mydb', 'admin', 'secret');
{$endif}
```

**Benefits**:
- Uses Internet Explorer settings (proxy, cache)
- Good for intranet environments with enterprise proxy configuration

#### TSqlDBCurlConnectionProperties

**libcurl-based client** for Linux/Unix platforms.

```pascal
{$ifdef USELIBCURL}
Props := TSqlDBCurlConnectionProperties.Create(
  'https://server:8092', 'mydb', 'admin', 'secret');
{$endif}
```

**Benefits**:
- Full-featured HTTP client (supports HTTP/2, proxy, SSL)
- Cross-platform (requires libcurl shared library)

### Client-Side Protocol Processing

All client classes inherit from `TSqlDBRemoteConnectionPropertiesAbstract`, which implements:

```pascal
function Process(
  Command: TSqlDBProxyConnectionCommand;
  const Input;
  var Output
): integer; virtual; abstract;
```

**Message Flow**:
```
1. Client calls Process(cExecuteToBinary, SQL+Params, ResultBinary)
2. Build binary message: Header(Magic, SessionID, Command) + Input
3. Protocol.HandleOutput() → Compress + Encrypt
4. HTTP POST to server URI
5. Receive HTTP response
6. Protocol.HandleInput() → Decrypt + Decompress
7. Parse output based on command type
8. Return sessionID
```

---

## 8.X.5. Security and Authentication

### Authentication Flow

```
Client                                    Server
  │                                          │
  ├──── cGetToken ────────────────────────►  │
  │                                          │
  │ ◄──────────── Token (Int64) ────────────┤
  │                                          │
  ├──── cGetDbms ───────────────────────────►│
  │     (User + Hash(Token, User, Pass))     │
  │                                          │ Validate credentials
  │                                          │ Create session
  │ ◄──── SessionID + DBMS Type ─────────────┤
  │                                          │
  │     All subsequent commands include      │
  │     SessionID in message header          │
  │                                          │
  ├──── cExecute (SessionID) ───────────────►│
  │                                          │ Verify SessionID
  │ ◄──────── Result ────────────────────────┤
  │                                          │
  ├──── cQuit (SessionID) ───────────────────►│
  │                                          │ Remove session
  │ ◄──────── OK ────────────────────────────┤
```

### TSynAuthentication

**Simple username/password authentication**:

```pascal
// Server-side
Protocol.Authenticate := TSynAuthentication.Create('admin', 'secret');
Protocol.Authenticate.AuthenticateUser('user2', 'password2'); // Add user

// Client-side
Props := TSqlDBSocketConnectionProperties.Create(
  'localhost:8092', 'mydb', 'admin', 'secret');
```

### Custom Authentication

Inherit from `TSynAuthenticationAbstract` for advanced scenarios:

```pascal
type
  TMyCustomAuth = class(TSynAuthenticationAbstract)
  public
    function ComputeHash(const aToken: Int64; const aUser, aPassword: RawUtf8): cardinal; override;
    function CreateSession(const aUser: RawUtf8; aHash: cardinal): integer; override;
    function SessionExists(aID: integer): boolean; override;
    procedure RemoveSession(aID: integer); override;
  end;
```

---

## 8.X.6. Transaction Management

### Single Active Transaction Model

The proxy enforces **one active transaction at a time** to prevent concurrency issues:

```pascal
// Server-side transaction tracking
fTransactionSessionID: integer;           // Current session holding transaction
fTransactionRetryTimeout: Int64;          // Retry time if transaction locked (100ms)
fTransactionActiveTimeout: Int64;         // Auto-rollback timeout (120 seconds)
fTransactionActiveAutoReleaseTicks: Int64; // When to force rollback
```

### Transaction Workflow

```pascal
// Client-side
Conn.StartTransaction;
try
  // Execute multiple statements
  Stmt1.ExecutePrepared;
  Stmt2.ExecutePrepared;
  Conn.Commit;
except
  Conn.Rollback;
  raise;
end;
```

**Server-side processing**:

1. **cTryStartTransaction**:
   - Check if `fTransactionSessionID = 0` (no active transaction)
   - If locked, retry for `fTransactionRetryTimeout` (default 100ms)
   - If timeout, raise `ESqlDBRemote` exception
   - If successful, set `fTransactionSessionID` and start timeout clock

2. **cCommit / cRollback**:
   - Verify SessionID matches `fTransactionSessionID`
   - Execute database commit/rollback
   - Reset `fTransactionSessionID := 0`

3. **Auto-Rollback**:
   - If `GetTickCount64 > fTransactionActiveAutoReleaseTicks`, force rollback
   - Prevents orphaned transactions from client disconnections

### Thread Safety

```pascal
// Default threading mode for proxy servers
aThreadMode: TSqlDBConnectionPropertiesThreadSafeThreadingMode = tmMainConnection;

// tmMainConnection:
//   - Single connection shared across all requests
//   - ProcessLocked = true (critical section protection)
//   - Suitable for most database providers
```

> **Warning**: Do **not** use `tmThreadPool` mode with proxy servers. Transactions require the same thread/connection for StartTransaction/Commit/Rollback operations.

---

## 8.X.7. Data Transfer Formats

### Binary Format (cExecuteToBinary)

**Most efficient format** for client-server communication, generated by `TSqlDBStatement.FetchAllToBinary()`:

```
┌────────────────────────────────────────────────────────────┐
│  HEADER                                                    │
├────────────────────────────────────────────────────────────┤
│  Magic (VarUInt32)                                         │
│  ColumnCount (VarUInt32)                                   │
│  For each column:                                          │
│    ColumnName (VarString)                                  │
│    ColumnType (byte: TSqlDBFieldType)                      │
│    ColumnValueDBSize (VarUInt32)                           │
├────────────────────────────────────────────────────────────┤
│  DATA ROWS                                                 │
├────────────────────────────────────────────────────────────┤
│  For each row:                                             │
│    NullBitmap length (VarUInt32)                           │
│    NullBitmap (byte array)                                 │
│    For each non-null column:                               │
│      [ColumnType (byte)] // Only if ftUnknown (SQLite3)    │
│      Value (type-specific encoding):                       │
│        ftInt64: VarInt64                                   │
│        ftDouble/ftCurrency/ftDate: 8 bytes                 │
│        ftUtf8/ftBlob: VarUInt32(length) + data             │
├────────────────────────────────────────────────────────────┤
│  FOOTER                                                    │
├────────────────────────────────────────────────────────────┤
│  RowCount (integer)                                        │
└────────────────────────────────────────────────────────────┘
```

**Benefits**:
- Compact representation (VarInt encoding for numbers)
- Type-safe deserialization
- Direct memory mapping (no parsing overhead)
- Used internally by `TSqlDBProxyStatement`

### JSON Format (cExecuteToJson / cExecuteToExpandedJson)

**Compact JSON** (non-expanded):

```json
{
  "fieldCount": 3,
  "values": [
    "ID", "Name", "Age",
    1, "John", 30,
    2, "Jane", 25
  ],
  "rowCount": 2
}
```

**Expanded JSON** (standard array of objects):

```json
[
  {"ID": 1, "Name": "John", "Age": 30},
  {"ID": 2, "Name": "Jane", "Age": 25}
]
```

**Usage**:

```pascal
// Get compact JSON for mORMot ORM consumption
var
  Json: RawUtf8;
begin
  Stmt.ExecutePreparedAndFetchAllAsJson(false, Json);
  // Parse with TDocVariantData.InitArrayFromResults
end;

// Get expanded JSON for Ajax/REST clients
Stmt.ExecutePreparedAndFetchAllAsJson(true, Json);
// Direct consumption in JavaScript: JSON.parse(json)
```

---

## 8.X.8. Advanced Features

### Virtual Statement Classes

#### TSqlDBProxyStatement

**Client-side statement** for remote execution:

```pascal
// Preparation is local (not sent to server)
Stmt := Conn.NewStatementPrepared('SELECT * FROM ?', true);

// Execution sends SQL + params to server, receives binary data
Stmt.Bind(1, 'Customers');
Stmt.ExecutePrepared;

// Step() iterates over cached binary data (no server round-trips)
while Stmt.Step do
  WriteLn(Stmt.ColumnUtf8(0));
```

**Key Methods**:
- `ExecutePrepared`: Sends `cExecuteToBinary` command
- `ExecutePreparedAndFetchAllAsJson`: Sends `cExecuteToJson` / `cExecuteToExpandedJson`
- `FetchAllToBinary`: Returns cached binary data (almost instant)
- `Step`: Iterates over local binary buffer
- `UpdateCount`: Returns update count from `cExecute` command

#### TSqlDBProxyStatementRandomAccess

**Direct data access** without connection, used by `TSynSqlStatementDataSet`:

```pascal
// Create from binary buffer
var
  Data: RawByteString;
  Stmt: TSqlDBProxyStatementRandomAccess;
begin
  // Data is FetchAllToBinary output
  Stmt := TSqlDBProxyStatementRandomAccess.Create(
    pointer(Data), Length(Data), nil, false);
  try
    // Random access to rows
    Stmt.GotoRow(10);
    WriteLn(Stmt.ColumnUtf8(0));

    // Search for value
    RowIndex := Stmt.ColumnSearch(2, 'Smith', true);
  finally
    Stmt.Free;
  end;
end;
```

**Features**:
- `GotoRow(Index)`: Direct row access (no sequential iteration)
- `ColumnSearch(Col, Value, CaseInsensitive)`: Search for value in column
- No connection required (pure data buffer manipulation)

### Testing Infrastructure

#### TSqlDBRemoteConnectionPropertiesTest

**In-process proxy testing** without HTTP:

```pascal
var
  RealProps: TOracleSqlDBConnectionProperties;
  TestProps: TSqlDBRemoteConnectionPropertiesTest;
begin
  RealProps := TOracleSqlDBConnectionProperties.Create(...);
  try
    // Test proxy overhead without network
    TestProps := TSqlDBRemoteConnectionPropertiesTest.Create(
      RealProps, 'admin', 'secret', TSqlDBRemoteConnectionProtocol);
    try
      // Use TestProps like any remote connection
      Conn := TestProps.NewConnection;
      // ... test code ...

      // Resulting overhead: typically < 1% vs direct connection
    finally
      TestProps.Free;
    end;
  finally
    RealProps.Free;
  end;
end;
```

---

## 8.X.9. Performance Characteristics

### Binary Protocol Overhead

**Benchmark results** (TSqlDBRemoteConnectionPropertiesTest):

| Operation | Direct Connection | Via Proxy | Overhead |
|-----------|-------------------|-----------|----------|
| Execute 1000 INSERTs | 245 ms | 247 ms | +0.8% |
| Fetch 10000 rows | 180 ms | 183 ms | +1.7% |
| Metadata query (GetFields) | 12 ms | 13 ms | +8.3% |

> **Note**: Overhead is **unnoticeable** for local testing. Over network, latency dominates (not protocol overhead).

### Compression Ratios

**Typical SynLZ compression results**:

| Data Type | Original Size | Compressed Size | Ratio |
|-----------|---------------|-----------------|-------|
| JSON result set (1000 rows) | 450 KB | 95 KB | 78.9% |
| Binary result set (1000 rows) | 280 KB | 68 KB | 75.7% |
| Metadata (column defs) | 8 KB | 2 KB | 75.0% |

### Network Efficiency

```
Traditional DB Client ──────► Network ──────► Database
  (SQL text)                 (High bandwidth)

mORMot Proxy Client ────────► Network ────────► Proxy Server ───► Database
  (Binary + Compressed)       (Low bandwidth)    (Local connection)
```

**Benefits**:
- Reduced network traffic (70-80% compression)
- Single connection to database (connection pooling on server)
- Lower latency (binary parsing vs. SQL text parsing)

---

## 8.X.10. Usage Scenarios

### Scenario 1: Desktop Application with Remote Database

**Problem**: Deploy desktop app to 100+ users without installing Oracle client on each machine.

**Solution**:

```pascal
// Server (single instance on app server)
var
  DbProps: TOracleSqlDBConnectionProperties;
  ProxyServer: TSqlDBServerSockets;
begin
  DbProps := TOracleSqlDBConnectionProperties.Create(
    'oracle-prod', 'hr_db', 'app_user', 'app_password');
  ProxyServer := TSqlDBServerSockets.Create(
    DbProps, 'hr', '8092', 'proxy_user', 'proxy_pass');
  // Server runs 24/7
end;

// Client (100+ desktop installations)
var
  Props: TSqlDBSocketConnectionProperties;
begin
  Props := TSqlDBSocketConnectionProperties.Create(
    'appserver:8092', 'hr', 'proxy_user', 'proxy_pass');
  // Use Props like local database connection
  // No Oracle client DLLs required!
end;
```

### Scenario 2: Cross-Platform Database Access

**Problem**: Access MSSQL database from Linux/macOS applications.

**Solution**:

```pascal
// Windows server with MSSQL connectivity
ProxyServer := TSqlDBServerSockets.Create(
  MSSQLProps, 'sales', '8092', 'admin', 'secret');

// Linux/macOS client
Props := TSqlDBCurlConnectionProperties.Create(
  'winserver:8092', 'sales', 'admin', 'secret');
// Full MSSQL access from non-Windows platforms
```

### Scenario 3: Firewall Penetration

**Problem**: Database server only allows connections from specific IPs, but clients are dynamic.

**Solution**:

```pascal
// Proxy server on whitelisted IP
ProxyServer := TSqlDBServerSockets.Create(
  DbProps, 'erp', '8092', 'proxy', 'pass');

// Clients from any IP connect to proxy
Props := TSqlDBSocketConnectionProperties.Create(
  'proxy.company.com:8092', 'erp', 'proxy', 'pass');
// Database firewall rules remain simple
```

---

## 8.X.11. Best Practices

### Server Deployment

**1. Use tmMainConnection threading mode** (default):

```pascal
// Single connection, serialized access
Server := TSqlDBServerSockets.Create(
  Props, 'mydb', '8092', 'user', 'pass',
  false, 1, nil, tmMainConnection); // ProcessLocked = true
```

**Benefits**:
- Transaction safety guaranteed
- Works with all database providers
- Simplified debugging (single connection state)

**2. Enable HTTPS for production**:

```pascal
Server := TSqlDBServerSockets.Create(
  Props, 'mydb', '443', 'user', 'pass',
  true); // aHttps = true
```

**3. Use strong authentication**:

```pascal
// Custom authentication with password hashing
Auth := TMyCustomAuth.Create;
Auth.AuthenticateUser('user1', HashPassword('password1'));
Server := TSqlDBServerSockets.Create(
  Props, 'mydb', '8092', '', '', false, 1, nil, tmMainConnection, Auth);
```

### Client Configuration

**1. Set appropriate KeepAliveMS**:

```pascal
Props := TSqlDBSocketConnectionProperties.Create(...);
Props.KeepAliveMS := 60000; // 1 minute (default)
// Or Props.KeepAliveMS := 0; // Disable keep-alive
```

**2. Handle connection failures gracefully**:

```pascal
try
  Conn := Props.NewConnection;
  Stmt := Conn.NewStatementPrepared('SELECT ...', true);
  Stmt.ExecutePrepared;
except
  on E: ESqlDBRemote do
  begin
    // Log error, retry logic, or fallback
    LogError('Database proxy error: ' + E.Message);
  end;
end;
```

**3. Minimize transaction duration**:

```pascal
// Bad: Long-lived transaction blocks other clients
Conn.StartTransaction;
try
  DoSlowOperation; // Blocks other clients for 2 minutes!
  Conn.Commit;
finally
  Conn.Rollback;
end;

// Good: Quick transaction
PrepareData;
Conn.StartTransaction;
try
  Stmt.ExecutePrepared; // Fast database operation
  Conn.Commit;
finally
  Conn.Rollback;
end;
```

### Performance Tuning

**1. Use binary format for large result sets**:

```pascal
// Default: cExecuteToBinary (fastest)
Stmt.ExecutePrepared;
while Stmt.Step do
  ProcessRow;

// Avoid JSON for high-volume data
// Stmt.ExecutePreparedAndFetchAllAsJson(...); // Slower for large sets
```

**2. Batch operations with BindArray**:

```pascal
// Efficient: Single round-trip for 1000 inserts
Stmt := Conn.NewStatementPrepared('INSERT INTO T (A, B) VALUES (?, ?)', false);
Stmt.BindArray(1, ftInt64, IDs);      // 1000 values
Stmt.BindArray(2, ftUtf8, Names);     // 1000 values
Stmt.ExecutePrepared;                 // 1 server call
```

**3. Cache metadata queries**:

```pascal
// Cache GetFields results (rarely change)
if FColumnCache = nil then
  Props.GetFields('Customers', FColumnCache);
// Use FColumnCache for subsequent operations
```

---

## 8.X.12. Limitations and Considerations

### Single Transaction Limitation

- Only **one active transaction** at a time on the server
- Multiple clients cannot have concurrent transactions
- Transactions auto-rollback after 2 minutes (configurable via `fTransactionActiveTimeout`)

**Workaround**: Use multiple proxy server instances (each with own connection).

### No Statement Caching

- `IsCacheable()` always returns `false`
- New statement instance created for each execution
- Server-side caching handled by database (not proxy)

### Connection Pooling

- Proxy server uses a **single connection** (default)
- Connection pooling must be implemented at the database layer or via multiple proxy instances

### Network Latency

- Each command requires a network round-trip
- High-latency networks (e.g., satellite) may see noticeable delays
- Minimize round-trips by batching operations

---

## 8.X.13. Comparison with Direct Database Access

| Feature | Direct Connection | Proxy Connection |
|---------|-------------------|------------------|
| **Deployment** | Database client libraries required | No client libraries needed |
| **Security** | Database credentials on each client | Centralized authentication |
| **Network Protocol** | Database-specific (TDS, TNS, etc.) | HTTP/HTTPS (firewall-friendly) |
| **Overhead** | None | ~1-2% (binary protocol) |
| **Latency** | Minimal | +1 network hop |
| **Concurrency** | High (database connection pool) | Limited (single transaction) |
| **Firewall** | Database ports must be open | Only HTTP/HTTPS ports |
| **Platform Support** | Database client support required | Any platform with HTTP client |
| **Debugging** | Direct access to database logs | Proxy layer adds indirection |

**When to Use Proxy**:
- Desktop application deployment without DB client installation
- Cross-platform access to platform-specific databases
- Firewall restrictions (only HTTP/HTTPS allowed)
- Centralized access control and auditing

**When to Use Direct**:
- High-concurrency server applications
- Latency-critical operations
- Complex transaction isolation requirements
- Direct database feature access (e.g., stored procedures with OUT parameters)

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Chapter 8: Database Access Layer](mORMot2-SAD-Chapter-08.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 9: REST and JSON](mORMot2-SAD-Chapter-09.md) |
