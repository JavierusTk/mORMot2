# 21.Y. ACME v2 / Let's Encrypt

*Automatic SSL Certificates for HTTPS Servers*

---

## Overview

The `mormot.net.acme` unit provides a complete client implementation of the **ACME v2** (Automatic Certificate Management Environment) protocol, as specified in **RFC 8555**. This enables automatic generation and renewal of free, domain-validated SSL/TLS certificates from **Let's Encrypt** and **ZeroSSL**.

**Key Features**:
- **HTTP-01 challenge** automated validation flow
- **JWS (JSON Web Signature)** authenticated requests
- **Automatic renewal** with background certificate checking
- **Multi-domain support** with SNI (Server Name Indication)
- **Zero-downtime** certificate replacement
- **Built-in HTTP server** for challenge responses (port 80)
- **ZeroSSL support** via External Account Binding (EAB)

> **Note**: This unit requires `USE_OPENSSL` to be defined and OpenSSL 1.1+ libraries available.

---

## 21.Y.1. Architecture

### Three-Layer Design

The ACME implementation consists of three distinct layers:

```
┌────────────────────────────────────────────┐
│  TAcmeLetsEncryptServer                    │
│  - HTTP server on port 80                  │
│  - HTTPS redirect (301/308)                │
│  - Automatic renewal scheduler             │
│  - Challenge HTTP server                   │
└────────────────────────────────────────────┘
                  │
┌────────────────────────────────────────────┐
│  TAcmeLetsEncrypt                          │
│  - Certificate lifecycle management        │
│  - Multi-domain coordination               │
│  - File-based persistence                  │
│  - SNI callback handler                    │
└────────────────────────────────────────────┘
                  │
┌────────────────────────────────────────────┐
│  TAcmeClient                               │
│  - ACME v2 protocol implementation         │
│  - Challenge handling (HTTP-01)            │
│  - CSR submission and download             │
└────────────────────────────────────────────┘
                  │
┌────────────────────────────────────────────┐
│  TJwsHttpClient                            │
│  - JWS signature (RFC 7515)                │
│  - Nonce management                        │
│  - Key authorization                       │
└────────────────────────────────────────────┘
```

### Certificate File Structure

Each domain managed by the system uses four files:

| File | Purpose | Format |
|------|---------|--------|
| `domain.json` | Configuration (contact, subjects, EAB) | JSON |
| `domain.acme.pem` | Local private key for JWS signing | PEM (ES256/RSA) |
| `domain.crt.pem` | Signed certificate from ACME server | PEM chain |
| `domain.key.pem` | TLS private key (optionally encrypted) | PEM |

**Example `domain.json`**:
```json
{
  "contact": "mailto:admin@synopse.info",
  "subjects": ["synopse.info", "www.synopse.info"]
}
```

**With ZeroSSL External Account Binding**:
```json
{
  "contact": "mailto:admin@example.com",
  "subjects": ["example.com"],
  "eab": {
    "algo": "Sha256",
    "kid": "your-eab-kid",
    "mac_key": "your-eab-mac-key"
  }
}
```

---

## 21.Y.2. JWS HTTP Client

### TJwsHttpClient Class

The `TJwsHttpClient` implements **JSON Web Signature** (JWS) authenticated HTTP requests required by the ACME protocol. All POST requests to the ACME server must be signed using the client's private key.

**JWS Request Structure**:
```json
{
  "protected": "<base64url-encoded-header>",
  "payload": "<base64url-encoded-json>",
  "signature": "<base64url-encoded-signature>"
}
```

**Protected Header Example**:
```json
{
  "alg": "ES256",
  "kid": "https://acme-v02.api.letsencrypt.org/acme/acct/12345",
  "nonce": "oFvnlFP1wIhRlYS2jTaXbA",
  "url": "https://acme-v02.api.letsencrypt.org/acme/new-order"
}
```

### Key Methods

#### Constructor
```pascal
constructor Create(aLog: TSynLogClass; const aCert: ICryptCert);
```
- `aLog`: Logging class for tracing requests
- `aCert`: Local certificate with private key for signing

#### Authenticated Requests
```pascal
function Head(const aUrl: RawUtf8): RawJson;
function Get(const aUrl: RawUtf8): RawJson;
function Post(const aUrl: RawUtf8; const aJson: RawJson): RawJson;
```

**Automatic Features**:
- **Nonce management**: Extracts `Replay-Nonce` header automatically
- **Kid tracking**: Stores account key identifier after registration
- **Error handling**: Raises `EJwsHttp` on non-2xx responses
- **JWK thumbprint**: Computes SHA-256 digest for challenge keys

**Nonce Flow**:
```
Client ──HEAD──► ACME Server
       ◄────────  Replay-Nonce: xyz123

Client ──POST──► ACME Server (nonce: xyz123)
       ◄────────  Replay-Nonce: abc456
```

---

## 21.Y.3. ACME Client Implementation

### TAcmeClient Class

The `TAcmeClient` implements the complete ACME v2 workflow for certificate issuance:

1. **Directory discovery** (read ACME endpoint URLs)
2. **Account creation** (or retrieval of existing account)
3. **Order creation** (request certificate for domains)
4. **Authorization** (prove domain ownership via challenges)
5. **Finalization** (submit CSR)
6. **Certificate download** (retrieve signed certificate)

### HTTP-01 Challenge Flow

The ACME server validates domain ownership using the **HTTP-01 challenge**:

```
┌─────────┐                                     ┌──────────────┐
│  ACME   │                                     │  Challenge   │
│  Client │                                     │  HTTP Server │
└────┬────┘                                     └──────┬───────┘
     │                                                 │
     │ 1. POST /new-order                             │
     ├────────────────────────────► ACME Server       │
     │                                   │            │
     │ 2. Authorization URLs             │            │
     ◄───────────────────────────────────┤            │
     │                                   │            │
     │ 3. POST /authz (get challenges)   │            │
     ├───────────────────────────────────►            │
     │                                   │            │
     │ 4. Challenge: token + url         │            │
     ◄───────────────────────────────────┤            │
     │                                   │            │
     │ 5. Publish token to HTTP server   │            │
     ├───────────────────────────────────┼───────────►│
     │     /.well-known/acme-challenge/<TOKEN>        │
     │                                   │            │
     │ 6. POST /challenge (ready)        │            │
     ├───────────────────────────────────►            │
     │                                   │            │
     │                        7. GET /.well-known/... │
     │                        ◄───────────────────────┤
     │                                   │            │
     │ 8. Status: valid                  │            │
     ◄───────────────────────────────────┤            │
     │                                   │            │
     │ 9. POST /finalize (CSR)           │            │
     ├───────────────────────────────────►            │
     │                                   │            │
     │ 10. Certificate URL               │            │
     ◄───────────────────────────────────┤            │
     │                                   │            │
     │ 11. POST /cert (download)         │            │
     ├───────────────────────────────────►            │
     │                                   │            │
     │ 12. PEM certificate chain         │            │
     ◄───────────────────────────────────┤            │
     │                                                │
```

### Challenge Content

The challenge **key authorization** is published at:
```
http://<domain>/.well-known/acme-challenge/<token>
```

**Key Authorization Format**:
```
<token>.<JWK-thumbprint-base64url>
```

Example:
```
DGyRejmCefe7v4NfDGDKfA.9jg46WB3rR_AHD-EBXdN7cBkH1WOu0tA3M9fm21mqTI
```

### Registration Workflow

#### High-Level API
```pascal
function RegisterAndWait(
  const OnChallenge: TOnAcmeChallenge;
  const OutSignedCert, OutPrivateKey: TFileName;
  const aPrivateKeyPassword: SpiUtf8;
  WaitForSec: cardinal;
  Terminated: PBoolean): TAcmeStatus;
```

**Parameters**:
- `OnChallenge`: Callback to publish challenge content
- `OutSignedCert`: Where to save signed certificate
- `OutPrivateKey`: Where to save TLS private key
- `aPrivateKeyPassword`: Optional password for private key
- `WaitForSec`: Maximum wait time (e.g., 30 seconds)
- `Terminated`: External shutdown flag

**Return Values**:
- `asValid`: Certificate successfully obtained
- `asPending`: Timeout (validation still in progress)
- `asInvalid`: Validation failed

#### Low-Level Step-by-Step API
```pascal
procedure StartDomainRegistration;
function CheckChallengesStatus: TAcmeStatus;
function FinalizeDomainRegistration(
  out aPrivateKey: RawUtf8;
  const aPrivateKeyPassword: SpiUtf8): TAcmeStatus;
function CompleteDomainRegistration(out aCert: RawUtf8): TAcmeStatus;
procedure ClearDomainRegistration;
```

**Step-by-Step Flow**:
1. `StartDomainRegistration()` - Creates order and triggers challenges
2. Loop: `CheckChallengesStatus()` - Poll until `asValid` or `asInvalid`
3. `FinalizeDomainRegistration()` - Submit CSR, get private key
4. Loop: `CompleteDomainRegistration()` - Poll until certificate ready
5. `ClearDomainRegistration()` - Cleanup temporary challenge files

### Challenge Callback

The `TOnAcmeChallenge` event publishes and clears challenge content:

```pascal
TOnAcmeChallenge = procedure(
  Sender: TObject;
  const Domain, Key, Token: RawUtf8) of object;
```

**Called Twice**:
- **Before validation**: `Key <> ''` (publish challenge content)
- **After validation**: `Key = ''` (remove challenge content)

**Example Implementation**:
```pascal
procedure OnChallengeWwwFolder(Sender: TObject;
  const Domain, Key, Token: RawUtf8);
var
  fn: TFileName;
begin
  fn := FormatString('%%.well-known/acme-challenge/%',
    [fChallengeWwwFolder, Token]);
  if Key <> '' then
    FileFromString(Key, fn)  // Create file with challenge content
  else
    DeleteFile(fn);          // Remove file after validation
end;
```

### External Account Binding (EAB)

ZeroSSL requires **External Account Binding** to link ACME account with ZeroSSL account:

```pascal
property EabAlgo: TSignAlgo;      // Typically saSha256
property EabKid: RawUtf8;         // Key identifier from ZeroSSL
property EabMacKey: RawUtf8;      // MAC key from ZeroSSL (base64url)
```

**EAB Computation** (internal):
```json
{
  "protected": "<base64url(header)>",
  "payload": "<base64url(JWK)>",
  "signature": "<base64url(HMAC-SHA256(protected.payload, mac_key))>"
}
```

---

## 21.Y.4. Certificate Lifecycle Management

### TAcmeLetsEncrypt Class

The `TAcmeLetsEncrypt` manages multiple domains with automated renewal:

```pascal
constructor Create(
  aLog: TSynLogClass;
  const aKeyStoreFolder: TFileName;
  const aDirectoryUrl, aAlgo: RawUtf8;
  const aPrivateKeyPassword: SpiUtf8);
```

**Parameters**:
- `aKeyStoreFolder`: Directory containing `*.json` domain files
- `aDirectoryUrl`: ACME endpoint (`ACME_LETSENCRYPT_URL` or `ACME_ZEROSSL_URL`)
- `aAlgo`: Certificate algorithm (default: `'x509-es256'`)
- `aPrivateKeyPassword`: Optional password for `*.key.pem` files

### ACME Directory URLs

| Provider | Production | Staging (Testing) |
|----------|-----------|-------------------|
| **Let's Encrypt** | `ACME_LETSENCRYPT_URL` | `ACME_LETSENCRYPT_DEBUG_URL` |
| **ZeroSSL** | `ACME_ZEROSSL_URL` | `ACME_ZEROSSL_DEBUG_URL` |

**Constants**:
```pascal
const
  ACME_LETSENCRYPT_URL =
    'https://acme-v02.api.letsencrypt.org/directory';
  ACME_LETSENCRYPT_DEBUG_URL =
    'https://acme-staging-v02.api.letsencrypt.org/directory';
  ACME_ZEROSSL_URL =
    'https://acme.zerossl.com/v2/DV90';
  ACME_ZEROSSL_DEBUG_URL =
    'https://acme.zerossl.com/v2/DV90/staging';
```

> **Warning**: Always test with staging URLs first. Production servers have strict rate limits.

### Initialization Workflow

```pascal
var
  Acme: TAcmeLetsEncrypt;
begin
  // 1. Create instance
  Acme := TAcmeLetsEncrypt.Create(
    TSynLog,
    'C:\certs\',
    ACME_LETSENCRYPT_URL,
    'x509-es256',
    'password123');
  try
    // 2. Load existing certificates from disk
    Acme.LoadFromKeyStoreFolder;

    // 3. Validate and renew certificates
    Acme.CheckCertificatesBackground;
  finally
    Acme.Free;
  end;
end;
```

### Certificate Renewal

#### Automatic Renewal Policy

The renewal process is controlled by:

```pascal
property RenewBeforeEndDays: integer;    // Default: 30 days
property RenewWaitForSeconds: integer;   // Default: 30 seconds
```

**Renewal Logic**:
- Certificates expiring within `RenewBeforeEndDays` are renewed
- Each renewal waits up to `RenewWaitForSeconds` for validation
- Disabled if `RenewBeforeEndDays <= 0`

**Best Practice**: Let's Encrypt recommends renewing 30 days before expiration.

#### CheckCertificates Method

```pascal
procedure CheckCertificates(Sender: TObject);
```

**Workflow**:
1. Load all `*.json` files from `KeyStoreFolder`
2. Check each `*.crt.pem` expiration date
3. For expiring certificates:
   - Call `TAcmeClient.RegisterAndWait()`
   - Create temporary `*.crt.pem.tmp` and `*.key.pem.tmp`
   - Validate new certificate with `NewServerContext()`
   - Replace old files atomically
   - Update `PSSL_CTX` without server restart

**Zero-Downtime Replacement**:
```pascal
// Old PSSL_CTX remains in use during renewal
ctx := NewServerContext(tmpCert, tmpKey);
if ctx <> nil then
begin
  // Atomic file replacement
  RenameFile(tmpCert, fSignedCert);
  RenameFile(tmpKey, fPrivKey);
  // Replace context (old one is leaked/freed later)
  ReplaceContext(ctx);
end;
```

#### Background Renewal

```pascal
procedure CheckCertificatesBackground;
```

Launches a `TLoggedWorkThread` for non-blocking renewal:
```pascal
TLoggedWorkThread.Create(
  fLog,
  'CheckCertificates',
  self,
  CheckCertificates);
```

### SNI (Server Name Indication) Integration

The `OnNetTlsAcceptServerName` callback provides per-domain SSL contexts:

```pascal
function OnNetTlsAcceptServerName(
  Context: PNetTlsContext;
  TLS: pointer;
  ServerName: PUtf8Char): pointer;
```

**Usage with THttpAsyncServer**:
```pascal
HttpsServer.SetTlsServerNameCallback(
  Acme.OnNetTlsAcceptServerName);
```

**Flow**:
1. Client sends TLS ClientHello with SNI extension (`ServerName`)
2. mORMot calls `OnNetTlsAcceptServerName()`
3. Callback returns `PSSL_CTX` for the requested domain
4. Connection continues with domain-specific certificate

**Example**:
```
Client requests "www.example.com"
  → OnNetTlsAcceptServerName('www.example.com')
  → GetClient('www.example.com')
  → Returns PSSL_CTX with www.example.com certificate
```

---

## 21.Y.5. HTTP Server Integration

### TAcmeLetsEncryptServer Class

The `TAcmeLetsEncryptServer` combines certificate management with an HTTP server on port 80:

```pascal
constructor Create(
  aLog: TSynLogClass;
  const aKeyStoreFolder: TFileName;
  const aDirectoryUrl, aAlgo: RawUtf8;
  const aPrivateKeyPassword: SpiUtf8;
  aHttpsServer: THttpServerGeneric = nil;
  aHttpServerThreadCount: integer = -1;
  const aPort: RawUtf8 = '');
```

**Additional Parameters**:
- `aHttpsServer`: Optional main HTTPS server for configuration sharing
- `aHttpServerThreadCount`: Threads for HTTP server (default: 1)
- `aPort`: HTTP port (default: `'80'`)

### HTTP Server Responsibilities

The port 80 HTTP server handles two tasks:

#### 1. ACME HTTP-01 Challenges

During renewal, responds to ACME validation requests:
```
GET /.well-known/acme-challenge/<token>
→ 200 OK
→ Content: <token>.<JWK-thumbprint>
```

**Implementation**:
```pascal
function OnHeaderParsed(Request: THttpServerSocket):
  THttpServerSocketGetRequestResult;
begin
  if fClientsRenewing and
     HttpServerChallenge(Request.Http.Host,
                         Request.Http.CommandUri,
                         body) then
    Request.SockSend('HTTP/1.0 200 OK'#13#10 +
                     BINARY_CONTENT_TYPE_HEADER)
  else
    // ...
end;
```

#### 2. HTTPS Redirection

Redirects all non-challenge HTTP requests to HTTPS:

| Request Method | Response Code | Reason |
|----------------|---------------|--------|
| `GET`, `HEAD`, `DELETE` | `301 Moved Permanently` | Safe to cache |
| `POST`, `PUT`, `PATCH` | `308 Permanent Redirect` | Preserves method/body |

**Redirect Response**:
```
HTTP/1.0 301 Moved Permanently
Location: https://example.com/path
Server: mORMot2 ACME Server
Content-Length: 0
Connection: Close
```

**Custom Redirect URLs**:
```pascal
function Redirect(const Domain, Redirection: RawUtf8): boolean;
```

Example:
```pascal
// Redirect blog.synopse.info to main site
AcmeServer.Redirect('blog.synopse.info',
                    'https://synopse.info/blog');
```

### Automated Renewal Scheduling

The `OnAcceptIdle` event triggers renewal checks:

```pascal
procedure OnAcceptIdle(Sender: TObject; Tix64: Int64);
begin
  if Tix64 >= fNextCheckTix then
  begin
    fNextCheckTix := Tix64 + (MilliSecsPerDay shr 1);
    CheckCertificatesBackground;
  end;
end;
```

**Schedule**:
- **First check**: Immediately at startup
- **Recurring checks**: Every 12 hours (`MilliSecsPerDay shr 1`)

---

## 21.Y.6. Complete Usage Example

### Setup Files

**1. Create `synopse.json`**:
```json
{
  "contact": "mailto:admin@synopse.info",
  "subjects": ["synopse.info", "www.synopse.info"]
}
```

**2. Create `api.json`**:
```json
{
  "contact": "mailto:admin@synopse.info",
  "subjects": ["api.synopse.info"]
}
```

### Server Implementation

```pascal
uses
  mormot.core.base,
  mormot.core.log,
  mormot.net.server,
  mormot.net.acme;

var
  HttpsServer: THttpAsyncServer;
  AcmeServer: TAcmeLetsEncryptServer;
begin
  // Create HTTPS server on port 443
  HttpsServer := THttpAsyncServer.Create(
    '443',
    nil,
    nil,
    'Synopse API',
    32);
  HttpsServer.WaitStarted;

  // Create ACME manager with HTTP server on port 80
  AcmeServer := TAcmeLetsEncryptServer.Create(
    TSynLog,
    'C:\certs\',                  // Certificate storage
    ACME_LETSENCRYPT_URL,         // Production Let's Encrypt
    'x509-es256',                 // ECDSA P-256
    '',                           // No private key password
    HttpsServer,                  // Link to HTTPS server
    1,                            // Single-threaded HTTP server
    '80');                        // HTTP port

  // Load existing certificates
  AcmeServer.LoadFromKeyStoreFolder;

  // Trigger initial renewal check
  AcmeServer.CheckCertificatesBackground;

  WriteLn('HTTPS server running on port 443');
  WriteLn('HTTP/ACME server running on port 80');
  WriteLn('Press Enter to quit');
  ReadLn;

  AcmeServer.Free;
  HttpsServer.Free;
end.
```

### First Run Behavior

When no certificates exist (`*.crt.pem` missing):

1. `LoadFromKeyStoreFolder()` creates `*.acme.pem` (JWS signing key)
2. `CheckCertificatesBackground()` starts renewal:
   - Contacts ACME server
   - Creates account
   - Requests validation
   - Waits for HTTP-01 challenge on port 80
   - Submits CSR
   - Downloads certificate
   - Creates `*.crt.pem` and `*.key.pem`
3. HTTPS server immediately uses new certificates via SNI callback

### Ongoing Operation

**Every 12 hours**:
1. `OnAcceptIdle` triggers `CheckCertificatesBackground()`
2. Checks expiration dates
3. Renews certificates within 30 days of expiration
4. Replaces `PSSL_CTX` atomically (zero downtime)

---

## 21.Y.7. Error Handling

### Exception Types

```pascal
EJwsHttp       = class(ESynException);    // JWS client errors
EAcmeClient    = class(ESynException);    // ACME protocol errors
EAcmeLetsEncrypt = class(ESynException);  // Certificate management errors
```

### Common Error Scenarios

#### Invalid Account
```
EAcmeClient: https://acme-v02.api.letsencrypt.org/acme/new-acct
returned status "invalid" (expected "valid")
```
**Cause**: ACME account creation failed (e.g., invalid email)

#### Challenge Timeout
```
TAcmeStatus.asPending (after 30 seconds)
```
**Causes**:
- Port 80 not accessible from internet
- DNS not pointing to server
- Firewall blocking connections
- Challenge content not published correctly

**Debug**: Check logs for `GetChallenge` calls and challenge URLs.

#### Rate Limiting
```
EJwsHttp: Error 429 [too many requests] while querying ...
```
**Cause**: Exceeded Let's Encrypt rate limits

**Limits** (Let's Encrypt production):
- **Certificates per domain**: 50 per week
- **New accounts**: 10 per 3 hours per IP
- **Failed validations**: 5 per hour per account

**Solution**: Use staging environment for testing.

#### Invalid Certificate Files
```
EAcmeLetsEncrypt: LoadFromKeyStoreFolder: renamed as
synopse.json.invalid after EOpenSslNetTls
```
**Cause**: Corrupted `*.acme.pem`, `*.crt.pem`, or `*.key.pem`

**Recovery**: Delete invalid files, restart server (will regenerate).

### Logging

Enable detailed logging to debug ACME workflow:

```pascal
TSynLog.Family.Level := LOG_VERBOSE;  // sllTrace for all details
```

**Key Log Messages**:
- `sllTrace`: JWS requests/responses, nonce management
- `sllDebug`: Challenge status, certificate renewal results
- `sllWarning`: Invalid domain files (renamed to `.invalid`)
- `sllLastError`: File I/O errors during certificate replacement

---

## 21.Y.8. Advanced Scenarios

### Using External HTTP Server (Nginx)

If port 80 is managed by Nginx, use folder-based challenge:

```pascal
var
  Client: TAcmeClient;
begin
  Client := TAcmeClient.Create(
    TSynLog,
    Cert('x509-es256'),
    ACME_LETSENCRYPT_URL,
    'mailto:admin@synopse.info',
    'synopse.info');
  try
    Client.RegisterAndWaitFolder(
      '/var/www/synopse.info',          // Nginx web root
      'synopse.crt.pem',
      'synopse.key.pem',
      '',                               // No password
      30);                              // 30 seconds timeout
  finally
    Client.Free;
  end;
end;
```

**Nginx Configuration**:
```nginx
server {
  listen 80;
  server_name synopse.info;

  location /.well-known/acme-challenge/ {
    root /var/www/synopse.info;
  }
}
```

### Multiple HTTPS Servers

Share ACME management across multiple TLS servers:

```pascal
var
  Acme: TAcmeLetsEncrypt;
  Server1, Server2: THttpAsyncServer;
begin
  Acme := TAcmeLetsEncrypt.Create(
    TSynLog,
    'C:\certs\',
    ACME_LETSENCRYPT_URL,
    'x509-es256',
    '');

  Acme.LoadFromKeyStoreFolder;

  // Both servers use same SNI callback
  Server1.SetTlsServerNameCallback(Acme.OnNetTlsAcceptServerName);
  Server2.SetTlsServerNameCallback(Acme.OnNetTlsAcceptServerName);

  Acme.CheckCertificatesBackground;
end;
```

### Custom Challenge Callback

Integrate with external systems (e.g., cloud storage):

```pascal
procedure UploadToCloudStorage(Sender: TObject;
  const Domain, Key, Token: RawUtf8);
begin
  if Key <> '' then
    CloudAPI.UploadFile(
      Domain,
      '/.well-known/acme-challenge/' + Token,
      Key)
  else
    CloudAPI.DeleteFile(
      Domain,
      '/.well-known/acme-challenge/' + Token);
end;

// Usage
Client.OnChallenges := UploadToCloudStorage;
```

---

## 21.Y.9. Security Considerations

### Private Key Protection

**Encryption**:
```pascal
Acme := TAcmeLetsEncrypt.Create(
  TSynLog,
  'C:\certs\',
  ACME_LETSENCRYPT_URL,
  'x509-es256',
  'strong-password-here');  // Encrypts *.key.pem files
```

**File Permissions**:
- Restrict `KeyStoreFolder` to server process user only
- On Linux: `chmod 700 /etc/mormot-certs/`
- On Windows: Use NTFS ACLs to deny read access to other users

### Rate Limit Mitigation

**Best Practices**:
1. **Use staging for development**: `ACME_LETSENCRYPT_DEBUG_URL`
2. **Batch renewals**: Process multiple domains in single `CheckCertificates()` call
3. **Monitor expiration**: Don't wait until last minute (30-day buffer)
4. **Cache certificates**: Don't delete/regenerate unnecessarily

### Challenge Security

**HTTP-01 Limitations**:
- Requires port 80 open to internet (attack surface)
- Validates domain only (not organization identity)
- No wildcard certificate support (use DNS-01 instead)

**Mitigations**:
- Use `hsoBan40xIP` to block DoS attacks
- `HeaderRetrieveAbortDelay := 200` for slow header attacks
- Only publish challenges during `fClientsRenewing = true`

---

## 21.Y.10. Performance Characteristics

### Certificate Renewal Overhead

**Typical Let's Encrypt Flow**:
- **Account creation**: ~500ms
- **Order creation**: ~300ms
- **Challenge validation**: 5-15 seconds (ACME server fetches HTTP-01)
- **CSR submission**: ~500ms
- **Certificate download**: ~300ms

**Total**: ~10-20 seconds per domain

### Memory Usage

**Per-Domain Overhead**:
- `TAcmeLetsEncryptClient`: ~4 KB
- `PSSL_CTX`: ~80 KB (OpenSSL context)
- Certificate chain: ~4 KB

**100 domains**: ~8.8 MB

### HTTP Server Performance

**Port 80 Server**:
- Single-threaded (`THttpServer`) scales to thousands of requests/second
- Most requests are instant redirects (no I/O)
- Challenge responses are rare (only during renewal)

**Benchmark** (simple redirect):
- ~20,000 req/s on modern CPU
- ~0.05ms average latency

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Chapter 21: Network Services](mORMot2-SAD-Chapter-21.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 22: Advanced Topics](mORMot2-SAD-Chapter-22.md) |
