# 21.14. Hardware Security Modules (PKCS#11)

*Secure cryptographic operations with hardware tokens*

## Overview

mORMot 2 provides comprehensive support for **PKCS#11** (Cryptoki), the industry-standard API for interfacing with **Hardware Security Modules (HSMs)**, smart cards, USB security tokens (YubiKey, Nitrokey), and other cryptographic hardware devices. This support enables applications to leverage hardware-based key storage and cryptographic operations while maintaining private keys securely within tamper-resistant devices.

The framework offers two complementary layers:

- **Low-level bindings** (`mormot.lib.pkcs11.pas`) - Complete PKCS#11 v3.0 API definitions with proper Pascal types
- **High-level integration** (`mormot.crypt.pkcs11.pas`) - Integration with mORMot's `ICryptCert` and `TCryptAsym` abstractions

**Key benefits**:

- **Hardware key protection** - Private keys never leave the secure hardware
- **Platform abstraction** - Unified API across Windows, Linux, and other POSIX systems
- **Type safety** - Strongly-typed Pascal enumerations instead of raw constants
- **Framework integration** - Seamless use with existing X.509 and JWT code
- **Device compatibility** - Works with any PKCS#11-compliant device

## Architecture

### PKCS#11 Concepts

PKCS#11 defines a hierarchical model for cryptographic devices:

```
Library (DLL/SO)
  ├─ Slot 0 (Reader/Interface)
  │    └─ Token (Device, optional)
  │         ├─ Certificates (CKO_CERTIFICATE)
  │         ├─ Public Keys (CKO_PUBLIC_KEY)
  │         └─ Private Keys (CKO_PRIVATE_KEY, PIN-protected)
  ├─ Slot 1
  │    └─ Token
  └─ Slot N
```

**Terminology**:

- **Slot** - Physical or logical reader/interface
- **Token** - Actual cryptographic device (may be removable)
- **Object** - Certificate, key, or data stored on the token
- **Session** - Temporary connection to a slot for operations
- **PIN** - Password protecting private key access

### mORMot Integration Layers

```
Application Code
      │
      ├─── ICryptCert / ICryptCertPkcs11 ──┐
      │                                     │
      └─── TCryptAsym (Sign/Verify)        │
                                            ▼
      ┌────────────────────────────────────────────────┐
      │  mormot.crypt.pkcs11.pas                       │
      │  - TCryptCertAlgoPkcs11 (factory)              │
      │  - TCryptCertPkcs11 (certificate wrapper)      │
      │  - Automatic certificate discovery             │
      └────────────────────────────────────────────────┘
                            ▼
      ┌────────────────────────────────────────────────┐
      │  mormot.lib.pkcs11.pas                         │
      │  - TPkcs11 (library wrapper)                   │
      │  - CK_* types (PKCS#11 v3.0 bindings)          │
      │  - Cross-platform struct handling              │
      └────────────────────────────────────────────────┘
                            ▼
            PKCS#11 Library (opensc-pkcs11.dll/so)
                            ▼
                  Hardware Device (YubiKey, etc.)
```

## Low-Level PKCS#11 Bindings

### TPkcs11 Class

The `TPkcs11` class in `mormot.lib.pkcs11.pas` provides direct access to PKCS#11 operations.

**Basic usage pattern**:

```pascal
uses
  mormot.lib.pkcs11;

var
  pk: TPkcs11;
begin
  pk := TPkcs11.Create;
  try
    // Load library
    if pk.Load('/usr/lib/opensc-pkcs11.so') then
    begin
      // Discover devices
      pk.RetrieveConfig;

      // Open session
      pk.Open(pk.SlotIDs[0], rw);
      try
        // Perform operations
      finally
        pk.Close;
      end;
    end;
  finally
    pk.Free;
  end;
end;
```

### Key Methods

**Library management**:

```pascal
function Load(const aLibraryName: TFileName): boolean;
procedure UnLoad;
function Loaded: boolean;
```

**Device discovery**:

```pascal
// Retrieve all slots and tokens (can take several seconds)
procedure RetrieveConfig(IncludeVoidSlots: boolean = false;
  IncludeMechanisms: boolean = false);

// Wait for token insertion/removal
function WaitForSlotEvent(NotBlocking: boolean = false): TPkcs11SlotID;

// Search helpers
function SlotByID(SlotID: TPkcs11SlotID; AddNew: boolean = false): PPkcs11Slot;
function TokenByName(const TokenName: RawUtf8;
  CaseInsensitive: boolean = false): PPkcs11Token;
```

**Session management**:

```pascal
// Public session (read-only by default)
procedure Open(slot: TPkcs11SlotID; rw: boolean = false); overload;

// User session (requires PIN)
procedure Open(slot: TPkcs11SlotID; const pin: SpiUtf8;
  rw: boolean = false; so: boolean = false); overload;

// Close current session
procedure Close;
```

**Object operations**:

```pascal
// Find objects on token
function GetObjects(ObjClass: CK_OBJECT_CLASS;
  const StorageID: TPkcs11ObjectID;
  Values: PRawByteStringDynArray): TPkcs11ObjectDynArray;

// Retrieve single object
function GetObject(ObjClass: CK_OBJECT_CLASS;
  const StorageLabel: RawUtf8;
  const StorageID: RawByteString): CK_OBJECT_HANDLE;

// Create new object
function SessionCreateObject(const Attr: CK_ATTRIBUTES): CK_OBJECT_HANDLE;

// Delete object
procedure SessionDestroyObject(var obj: CK_OBJECT_HANDLE);
```

**Cryptographic operations**:

```pascal
// Sign data with private key
function Sign(Data: pointer; Len: PtrInt; obj: CK_OBJECT_HANDLE;
  const Mech: CK_MECHANISM): RawByteString;

// Verify signature
function Verify(Data: pointer; Len: PtrInt;
  const Signature: RawByteString; obj: CK_OBJECT_HANDLE;
  const Mech: CK_MECHANISM): boolean;

// Encrypt/decrypt
function Encrypt(Data: pointer; Len: PtrInt; obj: CK_OBJECT_HANDLE;
  const Mech: CK_MECHANISM): RawByteString;
function Decrypt(Data: pointer; Len: PtrInt; obj: CK_OBJECT_HANDLE;
  const Mech: CK_MECHANISM): RawByteString;
```

### Type System

The bindings provide strongly-typed enumerations for PKCS#11 constants:

**Object classes**:

```pascal
CK_OBJECT_CLASS = (
  CKO_DATA,
  CKO_CERTIFICATE,
  CKO_PUBLIC_KEY,
  CKO_PRIVATE_KEY,
  CKO_SECRET_KEY,
  CKO_HW_FEATURE,
  CKO_DOMAIN_PARAMETERS,
  CKO_MECHANISM,
  CKO_OTP_KEY,
  CKO_PROFILE,
  CKO_VENDOR_DEFINED
);
```

**Key types**:

```pascal
CK_KEY_TYPE = (
  CKK_none,
  CKK_RSA,
  CKK_EC,
  CKK_EC_EDWARDS,  // EdDSA
  CKK_AES,
  // ... 60+ types
);
```

**Mechanisms** (cryptographic algorithms):

```pascal
CK_MECHANISM_TYPE = (
  CKM_NONE,
  CKM_RSA_PKCS,
  CKM_RSA_PKCS_PSS,
  CKM_ECDSA,
  CKM_EDDSA,
  CKM_AES_GCM,
  // ... 450+ mechanisms
);
```

**Conversion helpers**:

```pascal
// Convert to/from CK_ULONG storage format
function ToULONG(cko: CK_OBJECT_CLASS): CK_ULONG;
function ToCKO(uu: CK_ULONG): CK_OBJECT_CLASS;

// Human-readable names
function ToText(cko: CK_OBJECT_CLASS): PShortString;
function ToText(ckr: CK_RV): PShortString;  // Return values
```

### Cross-Platform Considerations

The bindings handle platform-specific differences:

**Windows vs. POSIX**:

```pascal
{$ifdef OSWINDOWS}
  CK_ULONG = cardinal;        // 32-bit on Windows
  {$A1}                       // Packed structs
{$else}
  CK_ULONG = PtrUInt;         // 64-bit on POSIX x86_64
  // Natural alignment
{$endif}
```

**Common library paths**:

- **Windows**: `opensc-pkcs11.dll`, `cryptoki.dll`
- **Linux**: `/usr/lib/opensc-pkcs11.so`, `/usr/lib/x86_64-linux-gnu/opensc-pkcs11.so`
- **macOS**: `/usr/local/lib/opensc-pkcs11.dylib`

## High-Level ICryptCert Integration

### TCryptCertAlgoPkcs11 Factory

The `TCryptCertAlgoPkcs11` class integrates PKCS#11 devices into mORMot's certificate framework.

**Initialization**:

```pascal
uses
  mormot.crypt.pkcs11;

var
  pkcs: TCryptCertAlgoPkcs11;
begin
  // Asynchronous loading (background thread)
  pkcs := TCryptCertAlgoPkcs11.Create('/usr/lib/opensc-pkcs11.so');
  try
    // Wait for background discovery to complete
    Sleep(100);

    // Access discovered certificates
    for cert in pkcs.Cert do
      WriteLn(cert.GetSubject);
  finally
    pkcs.Free;
  end;
end;
```

**Key properties**:

```pascal
property Engine: TPkcs11;                    // Underlying TPkcs11 instance
property LoadingConfigRetrieved: boolean;    // Background loading complete?
property LoadingError: string;               // Error during background load
function Cert: ICryptCertPkcs11s;            // All discovered certificates
```

**Certificate discovery**:

```pascal
// Find by serial number, subject, etc.
function Find(const Value: RawByteString;
  Method: TCryptCertComparer = ccmSerialNumber;
  MaxCount: integer = 0): ICryptCertPkcs11s;

// Find first match
function FindOne(const Value: RawByteString;
  Method: TCryptCertComparer = ccmSerialNumber): ICryptCertPkcs11;

// Find by token label
function FindByLabel(const Value: RawUtf8): ICryptCertPkcs11;

// Find by CKA_ID (hexadecimal)
function FindByID(const Value: TPkcs11ObjectID): ICryptCertPkcs11;
```

**Certificate import**:

```pascal
// Import certificate with private key to token
function Import(const CertWithPrivKey: ICryptCert;
  Slot: TPkcs11SlotID; const ID: RawUtf8;
  const SoPinCode: SpiUtf8): ICryptCertPkcs11;
```

### ICryptCertPkcs11 Interface

Extends `ICryptCert` with PKCS#11-specific functionality.

**Additional methods**:

```pascal
// Set PIN to access private key
function SetPin(const PinCode: SpiUtf8): boolean;

// Change asymmetric algorithm (e.g., RS256 to RS384)
procedure SetAsymAlgo(caa: TCryptAsymAlgo);

// Device information
function Engine: TPkcs11;           // PKCS#11 library instance
function SlotID: TPkcs11SlotID;     // Slot number
function TokenName: RawUtf8;        // Device name
function StorageID: TPkcs11ObjectID; // Hexadecimal CKA_ID
function StorageLabel: RawUtf8;     // Object label
function Storage: RawUtf8;          // 'SlotID-StorageID' format
function Slot: TPkcs11Slot;         // Slot details
function Token: TPkcs11Token;       // Token details

// Type information
function IsX509: boolean;           // True if real X.509 cert
                                    // (false if generated from public key)
```

### Certificate Types

PKCS#11 tokens store three types of certificate-related objects:

**1. Full X.509 certificates** (CKO_CERTIFICATE):

```pascal
// Loaded directly from DER binary
cert := pkcs.FindByLabel('My Certificate');
if cert.IsX509 then
  WriteLn('Real X.509: ', cert.GetIssuer);
```

**2. Public keys only** (CKO_PUBLIC_KEY):

```pascal
// Framework creates "fake" X.509 for compatibility
cert := pkcs.FindByLabel('Orphan Public Key');
if not cert.IsX509 then
  WriteLn('Synthetic X.509 from public key');
```

**3. Private keys** (CKO_PRIVATE_KEY, PIN-protected):

```pascal
// Accessed via SetPin() - never exported
cert.SetPin('123456');
signature := cert.Sign(data, cuDigitalSignature);
```

## Practical Examples

### Example 1: Enumerate Devices

```pascal
uses
  mormot.lib.pkcs11;

procedure ListDevices(const LibPath: TFileName);
var
  pk: TPkcs11;
  i: PtrInt;
  slot: PPkcs11Slot;
  token: PPkcs11Token;
begin
  pk := TPkcs11.Create;
  try
    if not pk.Load(LibPath) then
    begin
      WriteLn('Failed to load library');
      Exit;
    end;

    WriteLn('Library: ', pk.Api, ' v', pk.Version);
    WriteLn('Manufacturer: ', pk.Manufacturer);
    WriteLn;

    pk.RetrieveConfig;

    for i := 0 to High(pk.Slots) do
    begin
      slot := @pk.Slots[i];
      WriteLn('Slot #', slot.Slot, ': ', slot.Description);
      WriteLn('  Hardware: ', slot.HardwareVersion);
      WriteLn('  Firmware: ', slot.FirmwareVersion);

      if slot.Flags * [CKF_TOKEN_PRESENT] <> [] then
      begin
        token := pk.TokenByID(slot.Slot);
        if token <> nil then
        begin
          WriteLn('  Token: ', token.Name);
          WriteLn('    Serial: ', token.Serial);
          WriteLn('    Manufacturer: ', token.Manufacturer);
          WriteLn('    Model: ', token.Model);
          WriteLn('    Free memory: ', token.FreePublic, ' bytes');
        end;
      end
      else
        WriteLn('  (no token present)');
      WriteLn;
    end;
  finally
    pk.Free;
  end;
end;
```

### Example 2: Sign with YubiKey

```pascal
uses
  mormot.crypt.pkcs11,
  mormot.crypt.jwt;

function SignJwtWithYubiKey(const Payload: RawUtf8;
  const Pin: SpiUtf8): RawUtf8;
var
  pkcs: TCryptCertAlgoPkcs11;
  cert: ICryptCertPkcs11;
  jwt: TJwtAbstract;
begin
  Result := '';

  // Load PKCS#11 library for YubiKey
  pkcs := TCryptCertAlgoPkcs11.Create('libykcs11.so');
  try
    // Wait for background device discovery
    while not pkcs.LoadingConfigRetrieved do
      Sleep(10);

    if pkcs.LoadingError <> '' then
      raise ECryptCert.Create(pkcs.LoadingError);

    // Find certificate by label
    cert := pkcs.FindByLabel('YubiKey PIV Authentication');
    if cert = nil then
      raise ECryptCert.Create('Certificate not found on YubiKey');

    // Set PIN to unlock private key
    if not cert.SetPin(Pin) then
      raise ECryptCert.Create('Invalid PIN');

    // Create and sign JWT
    jwt := TJwtES256.Create(cert, 0, [], Payload, '');
    try
      Result := jwt.Compute(['aud', 'https://example.com']);
    finally
      jwt.Free;
    end;
  finally
    pkcs.Free;
  end;
end;
```

### Example 3: Verify Signature with Nitrokey

```pascal
uses
  mormot.crypt.pkcs11;

function VerifyWithNitrokey(const Data, Signature: RawByteString;
  const CertLabel: RawUtf8): boolean;
var
  pkcs: TCryptCertAlgoPkcs11;
  cert: ICryptCertPkcs11;
begin
  Result := False;

  pkcs := TCryptCertAlgoPkcs11.Create('/usr/lib/opensc-pkcs11.so');
  try
    // Wait for discovery
    while not pkcs.LoadingConfigRetrieved do
      Sleep(10);

    // Find certificate (public key verification doesn't need PIN)
    cert := pkcs.FindByLabel(CertLabel);
    if cert = nil then
      Exit;

    // Verify signature
    Result := cert.Verify(Data, Signature);
  finally
    pkcs.Free;
  end;
end;
```

### Example 4: Import Certificate to Token

```pascal
uses
  mormot.crypt.pkcs11,
  mormot.crypt.x509;

procedure ImportToToken(const PemFile: TFileName;
  const Pin: SpiUtf8);
var
  pkcs: TCryptCertAlgoPkcs11;
  cert: ICryptCert;
  imported: ICryptCertPkcs11;
  pem: RawUtf8;
begin
  // Load certificate with private key from PEM file
  pem := StringFromFile(PemFile);
  cert := CryptCertX509[caaRS256].Load(pem, cccCertWithPrivateKey, '');
  if not cert.HasPrivateSecret then
    raise ECryptCert.Create('No private key in PEM file');

  // Load PKCS#11 library
  pkcs := TCryptCertAlgoPkcs11.Create('/usr/lib/opensc-pkcs11.so');
  try
    while not pkcs.LoadingConfigRetrieved do
      Sleep(10);

    // Import to slot 0 with ID '01' and SO PIN
    imported := pkcs.Import(cert, 0, '01', Pin);
    if imported <> nil then
      WriteLn('Imported: ', imported.Storage)
    else
      WriteLn('Import failed');
  finally
    pkcs.Free;
  end;
end;
```

### Example 5: Low-Level Signing

```pascal
uses
  mormot.lib.pkcs11,
  mormot.crypt.secure;

function SignDataLowLevel(const Data: RawByteString;
  const Pin: SpiUtf8): RawByteString;
var
  pk: TPkcs11;
  obj: CK_OBJECT_HANDLE;
  mech: CK_MECHANISM;
  hash: TSha256Digest;
begin
  Result := '';
  pk := TPkcs11.Create;
  try
    if not pk.Load('/usr/lib/opensc-pkcs11.so') then
      Exit;

    pk.RetrieveConfig;

    // Open user session with PIN
    pk.Open(pk.SlotIDs[0], Pin);
    try
      // Find private key object by label
      obj := pk.GetObject(CKO_PRIVATE_KEY, 'My Key', '');
      if obj = CK_INVALID_HANDLE then
        Exit;

      // Prepare mechanism for RSA-PKCS#1 v1.5 with SHA-256
      mech.mechanism := ToULONG(CKM_RSA_PKCS);
      mech.pParameter := nil;
      mech.ulParameterLen := 0;

      // Hash data (SW side)
      hash := Sha256Digest(Data);

      // Sign hash (HW side)
      Result := pk.Sign(@hash, SizeOf(hash), obj, mech);
    finally
      pk.Close;
    end;
  finally
    pk.Free;
  end;
end;
```

### Example 6: Wait for Token Insertion

```pascal
uses
  mormot.lib.pkcs11;

procedure WaitForToken(const LibPath: TFileName);
var
  pk: TPkcs11;
  slot: TPkcs11SlotID;
  token: PPkcs11Token;
begin
  pk := TPkcs11.Create;
  try
    if not pk.Load(LibPath) then
      Exit;

    WriteLn('Waiting for token insertion...');

    // Blocking wait for slot state change
    slot := pk.WaitForSlotEvent(NotBlocking := False);

    // UpdateConfig() already called by WaitForSlotEvent()
    token := pk.TokenByID(slot);
    if token <> nil then
      WriteLn('Token inserted: ', token.Name, ' (serial: ', token.Serial, ')');
  finally
    pk.Free;
  end;
end;
```

## Algorithm Support

### RSA Algorithms

```pascal
// Supported TCryptAsymAlgo values
caaRS256  // RSA-PKCS#1 v1.5 with SHA-256 → CKM_RSA_PKCS
caaRS384  // RSA-PKCS#1 v1.5 with SHA-384 → CKM_RSA_PKCS
caaRS512  // RSA-PKCS#1 v1.5 with SHA-512 → CKM_RSA_PKCS
caaPS256  // RSA-PSS with SHA-256 → CKM_RSA_PKCS_PSS
caaPS384  // RSA-PSS with SHA-384 → CKM_RSA_PKCS_PSS
caaPS512  // RSA-PSS with SHA-512 → CKM_RSA_PKCS_PSS
```

**Note**: Hash computation is performed in software; only the signature operation uses the hardware.

### ECC Algorithms

```pascal
caaES256  // ECDSA P-256 (secp256r1) → CKM_ECDSA
caaES384  // ECDSA P-384 (secp384r1) → CKM_ECDSA
caaES512  // ECDSA P-521 (secp521r1) → CKM_ECDSA
caaES256K // ECDSA secp256k1 → CKM_ECDSA
```

**Curve parameters** (CKA_EC_PARAMS, DER-encoded OIDs):

- P-256: `06 08 2a 86 48 ce 3d 03 01 07` (1.2.840.10045.3.1.7)
- P-384: `06 05 2b 81 04 00 22` (1.3.132.0.34)
- P-521: `06 05 2b 81 04 00 23` (1.3.132.0.35)

### EdDSA Algorithm

```pascal
caaEdDSA  // Ed25519 → CKM_EDDSA (CKK_EC_EDWARDS)
```

## Platform Notes

### Windows

**Common libraries**:

- OpenSC: `C:\Program Files\OpenSC Project\OpenSC\pkcs11\opensc-pkcs11.dll`
- SoftHSM: `C:\SoftHSM2\lib\softhsm2-x64.dll`
- YubiKey: `C:\Program Files\Yubico\Yubico PIV Tool\bin\libykcs11.dll`

**Installation**:

```bash
# OpenSC installer
https://github.com/OpenSC/OpenSC/releases

# YubiKey tools
https://developers.yubico.com/yubico-piv-tool/Releases/
```

### Linux

**Common libraries**:

- OpenSC: `/usr/lib/x86_64-linux-gnu/opensc-pkcs11.so`
- SoftHSM: `/usr/lib/softhsm/libsofthsm2.so`
- YubiKey: `/usr/lib/x86_64-linux-gnu/libykcs11.so`

**Installation**:

```bash
# Debian/Ubuntu
sudo apt install opensc libengine-pkcs11-openssl

# YubiKey support
sudo apt install ykcs11 yubikey-manager
```

**Permissions**: Add user to `scard` group for non-root access:

```bash
sudo usermod -a -G scard $USER
```

### macOS

**Common libraries**:

- OpenSC: `/usr/local/lib/opensc-pkcs11.so`
- YubiKey: `/usr/local/lib/libykcs11.dylib`

**Installation**:

```bash
# Homebrew
brew install opensc yubico-piv-tool
```

## Security Considerations

### PIN Protection

```pascal
// CRITICAL: Wrong PIN may lock the device after 3-15 attempts
if not cert.SetPin(UserPin) then
begin
  WriteLn('Invalid PIN - attempts remaining: ?');
  // No API to query remaining attempts in PKCS#11
  Exit;
end;
```

**Best practices**:

- Store PINs using `SpiUtf8` (secure string, auto-zeroed)
- Never log or persist PINs
- Use SO PIN (Security Officer) only for administrative tasks
- Implement retry limits in application logic

### Anti-Forensic Measures

The framework includes built-in anti-forensic features:

```pascal
// PIN stored encrypted in memory
fPin := fPinSecret.EncryptPkcs7(PinCode, {ivatbeg=}true);

// Automatic zeroing on destroy
destructor TCryptCertPkcs11.Destroy;
begin
  inherited Destroy;
  fPinSecret.Free;
  FillZero(fPin); // Paranoid: already encrypted
end;
```

### Private Key Isolation

```pascal
// Private keys NEVER leave the device
function ToDer: RawByteString; override;
begin
  Result := ''; // Unsupported by design
end;

function SetPrivateKey(const saved: RawByteString): boolean; override;
begin
  Result := False; // Cannot import raw private key
end;
```

**Implication**: Hardware-based certificates cannot be backed up or migrated without re-importing from external source.

## Limitations

### Unsupported Operations

```pascal
// Not implemented (returns nil/empty/'')
function New: ICryptCert;  // Cannot generate keys on device (yet)
function Generate(...): ICryptCert;  // No key generation
function Open(const Message: RawByteString; ...): RawByteString;  // No decryption (yet)
function SharedSecret(const PeerKey: ICryptPublicKey): RawByteString;  // No ECDH (yet)
```

### Session Model

- **Single session per TPkcs11 instance** - Use separate instances for concurrent access
- **No session pooling** - Application must manage Open/Close lifecycle
- **Thread safety** - Use `Safe.Lock/UnLock` when accessing outside a session

### Performance

- **RetrieveConfig() is slow** (2-10 seconds) - Queries all slots and tokens
- **Background loading** - `TCryptCertAlgoPkcs11` uses async thread to mitigate
- **PIN verification overhead** - Each `Sign()` may validate PIN (device-dependent)

## Troubleshooting

### Common Errors

**CKR_CRYPTOKI_NOT_INITIALIZED**:

```pascal
// Ensure Load() succeeded before operations
if not pk.Loaded then
  raise EPkcs11.Create('Library not loaded');
```

**CKR_SESSION_HANDLE_INVALID**:

```pascal
// Always use try..finally with Open/Close
pk.Open(slot, pin);
try
  // Operations
finally
  pk.Close;
end;
```

**CKR_PIN_INCORRECT**:

```pascal
// Handle gracefully - device may lock after N attempts
if not cert.SetPin(pin) then
begin
  WriteLn('Authentication failed');
  Exit; // Do NOT retry in loop without user confirmation
end;
```

**CKR_TOKEN_NOT_PRESENT**:

```pascal
// Check token presence before Open()
slot := pk.SlotByID(slotid);
if slot.Flags * [CKF_TOKEN_PRESENT] = [] then
  raise EPkcs11.Create('No token in slot');
```

### Debugging

Enable logging to see PKCS#11 calls:

```pascal
uses
  mormot.core.log;

var
  pkcs: TCryptCertAlgoPkcs11;
begin
  // Pass TSynLog class for detailed logging
  pkcs := TCryptCertAlgoPkcs11.Create(LibPath, TSynLog);
  // Logs will include OpenPrivateKey, Sign, etc.
end;
```

### Vendor-Specific Issues

**YubiKey PIV**:

- Slot 9a (Authentication) - CKA_ID: `02`
- Slot 9c (Digital Signature) - CKA_ID: `00`
- Default PIN: `123456`, PUK: `12345678`
- Management key required for import operations

**Nitrokey**:

- User PIN required for signatures
- Admin PIN for key generation
- Factory reset erases all keys (irreversible)

**SoftHSM** (testing):

```bash
# Initialize token
softhsm2-util --init-token --slot 0 --label "Test Token"

# Library path varies by distro
/usr/lib/softhsm/libsofthsm2.so
```

## References

### Specifications

- [PKCS #11 v3.0](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/pkcs11-base-v3.0.html) - OASIS standard
- [PKCS #11 v2.40](http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/pkcs11-base-v2.40.html) - Most common version
- [RFC 7512](https://www.rfc-editor.org/rfc/rfc7512) - PKCS #11 URI Scheme

### Related mORMot Documentation

- **Section 21.8** - X.509 Certificates (`ICryptCert`)
- **Section 21.9** - JWT Signing (`TJwtAbstract`)
- **Section 21.6** - Asymmetric Cryptography (`TCryptAsym`)

### External Resources

- [OpenSC Project](https://github.com/OpenSC/OpenSC) - Open-source PKCS#11 middleware
- [SoftHSM](https://www.opendnssec.org/softhsm/) - Software HSM for testing
- [YubiKey PIV](https://developers.yubico.com/PIV/) - YubiKey PKCS#11 support
- [Nitrokey Documentation](https://docs.nitrokey.com/) - Nitrokey usage guides

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Section 21.13: Certificate Authority](21.13-CA.md) | [Index](mORMot2-SAD-Index.md) | [Section 21.15: OAuth 2.0 and OpenID Connect](21.15-OAuth.md) |
