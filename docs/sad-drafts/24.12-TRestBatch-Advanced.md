# 24.12. Advanced TRestBatch Options

*Fine-tuning the Unit of Work Pattern*

## Overview

While `TRestBatch` provides the foundation for efficient bulk operations, its advanced options enable fine-grained control over transaction behavior, error handling, JSON encoding, and cache management. Understanding these options is essential for production deployments where reliability and performance are critical.

## TRestBatchOptions Enumeration

The `TRestBatchOptions` set defines behavior through nine distinct flags:

```pascal
type
  TRestBatchOption = (
    boInsertOrIgnore,      // INSERT OR IGNORE for duplicate key tolerance
    boInsertOrReplace,     // REPLACE/UPSERT semantics
    boExtendedJson,        // Unquoted JSON column names
    boPostNoSimpleFields,  // Force full field names (compatibility)
    boPutNoCacheFlush,     // Skip cache invalidation
    boRollbackOnError,     // Abort entire batch on first error
    boNoModelEncoding,     // mORMot 1 compatibility mode
    boOnlyObjects,         // Raw JSON objects (no BATCH metadata)
    boMayHaveBlob);        // Disable optimizations for BLOB data

  TRestBatchOptions = set of TRestBatchOption;
```

## Database-Level Options

### boInsertOrIgnore: Duplicate Key Tolerance

Converts `INSERT` statements to `INSERT OR IGNORE`, allowing operations to continue when unique constraints are violated.

**Supported Databases**: SQLite3, MySQL/MariaDB

**Use Case**: Idempotent bulk imports where re-execution should not fail.

```pascal
Batch := TRestBatch.Create(Rest, TOrmProduct, 1000, [boInsertOrIgnore]);
try
  for Product in ImportList do
    Batch.Add(Product, true);  // Silently skip duplicates
  Rest.BatchSend(Batch, Results);
finally
  Batch.Free;
end;
```

**SQL Generation**:
```sql
-- SQLite3:
INSERT OR IGNORE INTO Product (Name,Price) VALUES (?,?);

-- MySQL/MariaDB:
INSERT IGNORE INTO Product (Name,Price) VALUES (?,?);
```

### boInsertOrReplace: UPSERT Semantics

Converts `INSERT` to `REPLACE` (SQLite3/MySQL) or `UPDATE OR INSERT` (Firebird), enabling upsert behavior.

**Supported Databases**: SQLite3, MySQL/MariaDB, Firebird

**Use Case**: Sync operations where records should be created or updated atomically.

```pascal
Batch := TRestBatch.Create(Rest, TOrmCache, 1000, [boInsertOrReplace]);
try
  for Item in SyncData do
  begin
    Item.ID := ComputeStableID(Item);  // Deterministic ID
    Batch.Add(Item, true, true);       // ForceID = true
  end;
  Rest.BatchSend(Batch, Results);
finally
  Batch.Free;
end;
```

**SQL Generation**:
```sql
-- SQLite3/MySQL:
REPLACE INTO Cache (ID,Key,Value) VALUES (?,?,?);

-- Firebird:
UPDATE OR INSERT INTO Cache (ID,Key,Value) VALUES (?,?,?);
```

> **Note**: `REPLACE` semantics delete the old row and insert a new one. Foreign key constraints and triggers may behave differently than plain `UPDATE`.

## JSON Encoding Options

### boExtendedJson: Unquoted Column Names

Forces extended JSON syntax (`col1:val,...`) instead of standard JSON (`"col1":val,...`).

**Use Case**: Bandwidth optimization for large batches (reduces payload size by ~15-20%).

```pascal
// Standard JSON (default):
// {"Name":"Alice","Age":30}

// Extended JSON (boExtendedJson):
// {Name:"Alice",Age:30}

Batch := TRestBatch.Create(Rest, TOrmUser, 10000, [boExtendedJson]);
```

**Default Behavior**: `[boExtendedJson]` is the default for all modern `BatchStart()` calls.

### boPostNoSimpleFields: Disable SIMPLE Encoding

Forces full field name transmission instead of compact "SIMPLE" array encoding.

**Use Case**: Compatibility with very old mORMot 1 servers (pre-2015).

```pascal
// SIMPLE encoding (default, more efficient):
// ["SIMPLE",[1,"Alice",30]]

// Full encoding (boPostNoSimpleFields):
// ["POST",{"ID":1,"Name":"Alice","Age":30}]

Batch := TRestBatch.Create(Rest, TOrmUser, 1000,
  [boExtendedJson, boPostNoSimpleFields]);
```

> **Warning**: Only use `boPostNoSimpleFields` when interfacing with legacy systems. Modern deployments should rely on compact encodings.

### boNoModelEncoding: mORMot 1 Compatibility

Forces verbose "POST"/"PUT"/"DELETE" verbs in JSON instead of compact table-based encoding.

**Use Case**: Client and server `TOrmModel` table order or field names do not match.

```pascal
// Modern encoding (default):
// {"User":["SIMPLE",[...]]}

// mORMot 1 encoding (boNoModelEncoding):
// [["POST@User",{...}]]

Batch := TRestBatch.Create(Rest, TOrmUser, 1000, [boNoModelEncoding]);
```

### boOnlyObjects: Raw JSON Array

Generates a plain JSON array of objects without BATCH metadata or verbs.

**Use Case**: Exporting data for non-mORMot consumers (REST APIs, analytics tools).

```pascal
Batch := TRestBatch.CreateNoRest(Model, TOrmLog, 0, [boOnlyObjects]);
try
  for Log in Logs do
    Batch.Add(Log, true);
  Batch.PrepareForSending(JsonData);  // Pure JSON array
  SendToExternalAPI(JsonData);
finally
  Batch.Free;
end;

// Output:
// [{"ID":1,"Message":"Start"},{"ID":2,"Message":"End"}]
```

## Transaction and Error Handling

### boRollbackOnError: All-or-Nothing Transactions

Aborts the entire batch and rolls back the transaction if any single operation fails.

**Default Behavior**: Continue processing, set `Results[i] := 0` for failures.

**With boRollbackOnError**: First error raises `EOrmBatchException` and triggers rollback.

```pascal
Batch := TRestBatch.Create(Rest, TOrmInvoice, 1000,
  [boExtendedJson, boRollbackOnError]);
try
  for Invoice in CriticalInvoices do
    Batch.Add(Invoice, true);

  if Rest.BatchSend(Batch, Results) <> HTTP_SUCCESS then
    raise EOrmException.Create('Invoice batch failed - all rolled back');
finally
  Batch.Free;
end;
```

**Error Handling Without boRollbackOnError**:
```pascal
Rest.BatchSend(Batch, Results);
for i := 0 to High(Results) do
  if Results[i] = 0 then
    Log.Error('Failed to insert record #%', [i]);
  // Successful operations are NOT rolled back
```

**When to Use**:
- **Financial transactions**: Invoices, payments, accounting entries
- **Referential integrity chains**: Parent-child record batches
- **Atomic migrations**: Schema changes requiring all-or-nothing semantics

**When to Avoid**:
- **Logging systems**: Partial success is acceptable
- **Bulk imports**: Retry logic handles individual failures
- **Idempotent operations**: Can safely re-execute failed items

## Cache and Performance Options

### boPutNoCacheFlush: Skip Cache Invalidation

Prevents automatic cache flushing for `Update` operations in the batch.

**Default Behavior**: Every `PUT` operation flushes the corresponding `TOrmCache` entry.

**With boPutNoCacheFlush**: Cache remains stale; caller must manually invalidate.

```pascal
Batch := TRestBatch.Create(Rest, TOrmProduct, 1000,
  [boExtendedJson, boPutNoCacheFlush]);
try
  for Product in BulkPriceUpdate do
    Batch.Update(Product);

  Rest.BatchSend(Batch, Results);

  // Manual cache invalidation after batch completion
  Rest.Cache.Flush(TOrmProduct);
finally
  Batch.Free;
end;
```

**Use Case**: Bulk updates where cache coherency can be deferred until batch completion.

**Risk**: Reading from cache between `BatchSend()` and `Cache.Flush()` returns stale data.

### boMayHaveBlob: Disable Array Binding Optimizations

Signals that BLOB fields may be present, disabling certain database engine optimizations.

**Effect**: Some SQL engines (PostgreSQL, Oracle) disable array binding when BLOBs are detected.

```pascal
Batch := TRestBatch.Create(Rest, TOrmDocument, 100,
  [boExtendedJson, boMayHaveBlob]);
try
  for Doc in Documents do
    Batch.Add(Doc, true, false, ALL_FIELDS);  // Include BLOB fields
  Rest.BatchSend(Batch, Results);
finally
  Batch.Free;
end;
```

> **Note**: By default, `TRestBatch.Add()` excludes BLOB fields. Use `ALL_FIELDS` or explicit `CustomFields` to include them.

## CustomFields: Field-Level Control

The `CustomFields: TFieldBits` parameter on `Add()` and `Update()` overrides which fields are transmitted.

### Add with CustomFields

```pascal
var
  CustomFields: TFieldBits;
begin
  // Compute fields to send
  Props := TOrmProduct.OrmProps;
  Props.FieldBitsFromCsv('Name,Price,Category', CustomFields);

  // Or programmatically
  CustomFields := [];
  FieldBitsSet(CustomFields, Props.Fields.IndexByName('Name'));
  FieldBitsSet(CustomFields, Props.Fields.IndexByName('Price'));

  // Send only specified fields
  Batch.Add(Product, true, false, CustomFields);
end;
```

### Update with CustomFields

```pascal
// Update only the Price field
Props.FieldBitsFromCsv('Price', PriceField);
Batch.Update(Product, PriceField);

// Update fields from FillPrepare mapping
Product.FillPrepare(Rest, 'Name,Stock');
Batch.Update(Product);  // Only Name and Stock are sent
```

### ALL_FIELDS Constant

Forces transmission of all fields, including BLOBs:

```pascal
Batch.Add(Document, true, false, ALL_FIELDS);  // Include BLOB content
```

## OnWrite Event Hook

The `TRestBatch.OnWrite` event intercepts every `Add/Update/Delete` operation before JSON encoding.

```pascal
type
  TOnBatchWrite = procedure(Sender: TRestBatch; Event: TOrmOccasion;
    Table: TOrmClass; const ID: TID; Value: TOrm;
    const ValueFields: TFieldBits) of object;
```

### Use Cases

**Audit Logging**:
```pascal
procedure LogBatchWrite(Sender: TRestBatch; Event: TOrmOccasion;
  Table: TOrmClass; const ID: TID; Value: TOrm;
  const ValueFields: TFieldBits);
begin
  case Event of
    ooInsert: Log.Info('Batch INSERT: % #%', [Table, ID]);
    ooUpdate: Log.Info('Batch UPDATE: % #%', [Table, ID]);
    ooDelete: Log.Info('Batch DELETE: % #%', [Table, ID]);
  end;
end;

Batch := TRestBatch.Create(Rest, TOrmOrder, 1000);
Batch.OnWrite := LogBatchWrite;
```

**Data Transformation**:
```pascal
procedure NormalizeBeforeBatch(Sender: TRestBatch; Event: TOrmOccasion;
  Table: TOrmClass; const ID: TID; Value: TOrm;
  const ValueFields: TFieldBits);
var
  Product: TOrmProduct absolute Value;
begin
  if Event in [ooInsert, ooUpdate] then
    Product.Name := Trim(UpperCase(Product.Name));  // Normalize name
end;
```

**Validation**:
```pascal
procedure ValidateBatchData(Sender: TRestBatch; Event: TOrmOccasion;
  Table: TOrmClass; const ID: TID; Value: TOrm;
  const ValueFields: TFieldBits);
var
  Invoice: TOrmInvoice absolute Value;
begin
  if (Event = ooInsert) and (Invoice.Total < 0) then
    raise EOrmBatchException.CreateUtf8('Invalid invoice total: %', [Invoice.Total]);
end;
```

## Thread-Safe Batch Operations

### TRestBatchLocked: Built-in Synchronization

For multi-threaded scenarios, use `TRestBatchLocked` instead of `TRestBatch`:

```pascal
var
  Batch: TRestBatchLocked;
begin
  Batch := TRestBatchLocked.CreateNoRest(Model, TOrmLog, 1000);
  try
    // Producer threads
    TThread.CreateAnonymousThread(procedure
      begin
        Batch.Safe.Lock;
        try
          Batch.Add(CreateLog('Thread 1'), true);
        finally
          Batch.Safe.UnLock;
        end;
      end).Start;

    // Consumer thread
    TThread.CreateAnonymousThread(procedure
      var
        Data: RawUtf8;
      begin
        Sleep(1000);  // Wait for producers
        Batch.Safe.Lock;
        try
          if Batch.Count > 0 then
          begin
            Batch.PrepareForSending(Data);
            SendToRemoteLog(Data);
            Batch.Reset(TOrmLog, 1000);  // Reuse instance
          end;
        finally
          Batch.Safe.UnLock;
        end;
      end).Start;
  finally
    Batch.Free;
  end;
end;
```

### AsyncBatch Background Processing

For fire-and-forget bulk operations, use `AsyncBatchStart()`:

```pascal
// Start background batch (thread-safe)
Rest.AsyncBatchStart(TOrmMetrics, 5, 1000, 10000, [boExtendedJson]);

// Multiple threads can safely append
for i := 1 to 10000 do
  Rest.AsyncBatchAdd(CreateMetric(i), true);  // Thread-safe

// Batch is automatically sent every 5 seconds OR when 1000 rows accumulate
// Automatic transactions every 10000 rows
Rest.AsyncBatchStop(TOrmMetrics);  // Flush remaining data
```

**Parameters**:
- `SendSeconds`: Flush interval (5 = every 5 seconds)
- `PendingRowThreshold`: Row count trigger (1000 = send when 1000 rows accumulated)
- `AutomaticTransactionPerRow`: Transaction size (10000 = commit every 10K rows)

## Best Practices

### Option Combinations

**High-Performance Bulk Insert**:
```pascal
[boExtendedJson]  // Default, optimal for most scenarios
```

**Idempotent Import**:
```pascal
[boExtendedJson, boInsertOrIgnore]
```

**Critical Transaction**:
```pascal
[boExtendedJson, boRollbackOnError]
```

**Legacy Compatibility**:
```pascal
[boPostNoSimpleFields, boNoModelEncoding]
```

**Export to External System**:
```pascal
[boOnlyObjects]
```

### AutomaticTransactionPerRow Tuning

The `AutomaticTransactionPerRow` parameter controls transaction granularity:

```pascal
// Small transactions (safer, slower)
Batch := TRestBatch.Create(Rest, TOrmLog, 1000);  // Commit every 1000 rows

// Large transactions (faster, higher rollback cost)
Batch := TRestBatch.Create(Rest, TOrmLog, 100000);  // Commit every 100K rows

// Manual transaction control
Batch := TRestBatch.Create(Rest, TOrmLog, 0);  // No automatic transactions
Rest.TransactionBegin(TOrmLog);
try
  Rest.BatchSend(Batch, Results);
  Rest.Commit;
except
  Rest.RollBack;
  raise;
end;
```

**Tuning Guide**:
- **OLTP systems**: 1,000-10,000 rows/transaction
- **Batch imports**: 10,000-100,000 rows/transaction
- **SQLite3**: Higher values (100K+) due to lock overhead
- **PostgreSQL/MySQL**: Lower values (10K) for better concurrency

### Error Handling Strategies

**Continue on Error (Default)**:
```pascal
Rest.BatchSend(Batch, Results);
SuccessCount := 0;
for i := 0 to High(Results) do
  if Results[i] > 0 then
    Inc(SuccessCount)
  else
    Log.Warning('Failed row %: %', [i, GetLastError]);
Log.Info('Imported % of % records', [SuccessCount, Length(Results)]);
```

**Abort on Error**:
```pascal
Batch.Options := Batch.Options + [boRollbackOnError];
try
  Rest.BatchSend(Batch, Results);
except
  on E: EOrmBatchException do
    Log.Error('Batch aborted: %', [E.Message]);
end;
```

**Hybrid Approach**:
```pascal
// Validate first in dry-run mode
for Item in Data do
  if not ValidateItem(Item) then
    raise EValidationError.Create('Invalid data');

// Execute with confidence
Batch.Options := Batch.Options + [boRollbackOnError];
Rest.BatchSend(Batch, Results);
```

## Client-Side vs Server-Side Options

### Client-Side Only Options

These options control JSON encoding but are not transmitted to the server:

- `boExtendedJson`
- `boPostNoSimpleFields`
- `boNoModelEncoding`
- `boOnlyObjects`

**Constant**:
```pascal
const
  BATCH_OPTIONS_CLIENTONLY = [boExtendedJson, boPostNoSimpleFields,
                              boNoModelEncoding, boOnlyObjects];
```

### Server-Side Options

These options affect server execution:

- `boInsertOrIgnore`
- `boInsertOrReplace`
- `boRollbackOnError`
- `boPutNoCacheFlush`
- `boMayHaveBlob`

## Performance Comparison

**Batch Options Impact** (10,000 row insert, SQLite3):

| Options | Time (ms) | Payload (KB) | Notes |
|---------|-----------|--------------|-------|
| `[boExtendedJson]` | 450 | 1,250 | Default, optimal |
| `[boExtendedJson, boInsertOrIgnore]` | 480 | 1,250 | +7% for conflict handling |
| `[boPostNoSimpleFields]` | 520 | 1,850 | +48% payload size |
| `[boNoModelEncoding]` | 550 | 1,900 | Legacy compatibility |
| `[boOnlyObjects]` | 430 | 1,200 | No BATCH metadata |

**Recommendation**: Use default `[boExtendedJson]` unless specific compatibility or error handling requirements dictate otherwise.

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [24.11. Batch Operations Performance](24.11-Batch-Performance.md) | [Index](mORMot2-SAD-Index.md) | [24.13. Transaction Management Strategies](24.13-Transaction-Strategies.md) |
