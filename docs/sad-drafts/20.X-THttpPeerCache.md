# 20.X. Peer-to-Peer HTTP Cache

*Local Caching, Global Efficiency*

## Overview

`THttpPeerCache` implements a production-ready peer-to-peer content distribution network (P2P CDN) for local networks, combining UDP-based peer discovery with HTTP/HTTPS content delivery. Instead of multiple machines downloading the same resource from a remote server, peers automatically share cached files with each other, dramatically reducing bandwidth usage and download times.

**Key capabilities:**

- **Automatic peer discovery** via UDP broadcasting
- **Progressive downloads** with partial file serving during downloads
- **AES-256-GCM encryption** for all UDP frames and HTTP bearer tokens
- **Bandwidth control** with configurable per-peer limits
- **Two-tier caching** (temporary with TTL, permanent storage)
- **Zero configuration** for clients (automatic network interface detection)
- **Fallback resilience** (transparent fallback to origin server)
- **DoS protection** with IP banning and connection limits

**Architecture:**

```
┌──────────────────────────────────────────────────────────────┐
│                     THttpPeerCache                           │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐ │
│  │ UDP Discovery  │  │ HTTP Server    │  │ Cache Manager  │ │
│  │ (Port 8099)    │  │ (Port 8099)    │  │ Temp + Perm    │ │
│  │                │  │                │  │                │ │
│  │ • Broadcast    │  │ • GET cached   │  │ • Hash-based   │ │
│  │ • AES-GCM auth │  │ • Partial file │  │ • Cleanup TTL  │ │
│  │ • Peer list    │  │ • Bearer auth  │  │ • Size limits  │ │
│  └────────────────┘  └────────────────┘  └────────────────┘ │
└──────────────────────────────────────────────────────────────┘
             │                    ▲                    │
             │ UDP Broadcast      │ HTTP GET           │ Cache hit
             ▼                    │                    ▼
      ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
      │  Peer A     │◄────►│  Peer B     │◄────►│  Peer C     │
      │  192.168.1.2│      │  192.168.1.3│      │  192.168.1.4│
      └─────────────┘      └─────────────┘      └─────────────┘
```

## 20.X.1. UDP Discovery Protocol

### Frame Structure

All UDP frames are encrypted with **AES-256-GCM** using a shared secret:

```pascal
THttpPeerCacheMessageEncoded = packed record
  iv: THash128;                        // AES initialization vector
  msg: THttpPeerCacheMessage;          // 192 bytes (padded)
  padding, mac: THash128;              // GCM authentication tag
  crc: cardinal;                       // Quick anti-fuzzing checksum
end;
// Total: 212 bytes per UDP frame
```

**Plaintext message content** (before encryption):

```pascal
THttpPeerCacheMessage = packed record
  Kind: THttpPeerCacheMessageKind;     // pcfPing, pcfPong, pcfRequest, etc.
  Seq: cardinal;                       // Sequence number (anti-replay)
  Uuid: TGuid;                         // Sender UUID (from SMBios or custom)
  Os: TOperatingSystemVersion;         // OS fingerprint
  IP4: cardinal;                       // Sender IPv4 (e.g. 192.168.1.2)
  DestIP4: cardinal;                   // Destination IPv4 (0 = broadcast)
  MaskIP4: cardinal;                   // Network mask (255.255.255.0)
  BroadcastIP4: cardinal;              // Broadcast address
  Speed: cardinal;                     // Link speed (Mbits/sec)
  Hardware: TMacAddressKind;           // makEthernet, makWifi, etc.
  Timestamp: TUnixTimeMinimal;         // UTC timestamp
  Connections: word;                   // Active background connections
  Hash: THashDigest;                   // SHA-256/512 of file content
  Size: Int64;                         // Full file size
  RangeStart, RangeEnd: Int64;         // Byte range (for partial requests)
  Opaque: QWord;                       // Internal state
  PaddingVersion: byte;                // Future extensibility
  Padding: array[0..41] of byte;       // Random padding (anti-fingerprinting)
end;
```

### Message Types

```pascal
THttpPeerCacheMessageKind = (
  pcfPing,                     // Health check / peer discovery
  pcfPong,                     // Ping response
  pcfRequest,                  // Request file by hash
  pcfResponseNone,             // "I don't have this file"
  pcfResponseOverloaded,       // "I'm busy (too many connections)"
  pcfResponsePartial,          // "I have partial file (downloading)"
  pcfResponseFull,             // "I have complete file"
  pcfBearer,                   // HTTP bearer token for authentication
  pcfBearerDirect,             // Direct HTTP proxy mode
  pcfBearerDirectPermanent     // Direct mode for permanent cache
);
```

### Discovery Workflow

**Client broadcasts request:**

```
1. Client needs file with SHA-256 hash H
2. Build pcfRequest message with Hash=H, Size=S
3. Encrypt with AES-GCM (shared secret)
4. Broadcast to 192.168.1.255:8099 (or network broadcast)
5. Wait BroadcastTimeoutMS (default: 10ms)
```

**Peers respond:**

```
Each peer receives broadcast, decrypts message:
  - If hash H not in cache → send pcfResponseNone
  - If hash H in cache but Connections >= LimitClientCount → pcfResponseOverloaded
  - If hash H downloading (.part file) → pcfResponsePartial
  - If hash H fully cached → pcfResponseFull

Response includes:
  - Peer IP4, Speed, Connections (for ranking)
  - Bearer token (AES-GCM encrypted metadata)
```

**Client selects best peer:**

```
Ranking criteria:
  1. pcfResponseFull > pcfResponsePartial > pcfResponseNone
  2. Lower Connections count (less loaded)
  3. Higher Speed (faster network interface)
  4. Same subnet (MaskIP4 & IP4 match)

Options:
  - pcoUseFirstResponse: Use first positive response (low latency)
  - pcoTryLastPeer: Try last successful peer first (batched downloads)
  - pcoTryAllPeers: Try best 10 peers before fallback to origin
```

### Security Features

**Anti-fuzzing checksum:**

```pascal
// Quick validation before AES decryption
if aFrame^.crc <> crc32c(0, @aFrame^.iv, PEER_CACHE_AESLEN) then
  exit; // Reject invalid frame (DoS protection)
```

**Sequence number anti-replay:**

```pascal
// Monotonic counter prevents replay attacks
if aMsg.Seq <= fFrameSeqLow then
  exit; // Reject old/replayed frames
```

**IP banishment:**

```pascal
// Invalid frames trigger temporary IP ban
// Default: 4 minutes TTL (RejectInstablePeersMin)
if InvalidFrame(ip4) then
  fInstable.BanIP(ip4);
```

## 20.X.2. HTTP Content Delivery

### HTTP Server Endpoints

`THttpPeerCache` binds an HTTP/HTTPS server to the same port as UDP (default: 8099):

**Endpoint patterns:**

```
GET /SHA256_HASH?bearer=TOKEN            # Cached file by hash
GET /SHA256_HASH?bearer=TOKEN&range=0-   # Partial/progressive download
GET /https/example.com/file?bearer=TOKEN # Direct proxy mode (pcoHttpDirect)
```

**Bearer token authentication:**

```pascal
// All HTTP requests require valid bearer token
// Token = Base64(AES-GCM(THttpPeerCacheMessage))
// Contains: Hash, Size, RangeStart, RangeEnd, Opaque

function OnBeforeBody(var aBearerToken: RawUtf8): cardinal;
begin
  if BearerDecode(aBearerToken, pcfBearer, aMsg) <> mdOk then
    exit(HTTP_FORBIDDEN); // Invalid/expired token
  // ... verify hash, check cache, serve file
end;
```

### Progressive Download

**Problem:** Large files take time to download. Peers waiting for the same file waste time.

**Solution:** Serve **partial files during download** (`.part` files):

```
1. Peer A starts downloading file.bin (1 GB) from origin server
2. Peer A registers partial file via OnDownloading()
3. Peer B broadcasts request for same hash
4. Peer A responds pcfResponsePartial
5. Peer B starts downloading from Peer A (byte range 0-500MB)
6. Meanwhile, Peer A continues downloading from origin
7. When Peer A reaches byte 500MB, Peer B switches to byte range 500MB-1GB
```

**Implementation:**

```pascal
// Register partial file (client side)
function THttpPeerCache.OnDownloading(
  const Params: THttpClientSocketWGet;
  const Partial: TFileName;
  ExpectedFullSize: Int64): THttpPartialID;

// Serve partial file (server side)
function THttpPeerCache.OnRequest(Ctxt: THttpServerRequestAbstract): cardinal;
begin
  // Check if file is .part (downloading)
  if PartialFileName(aMessage, aHttp, @aFileName, @aSize) = HTTP_SUCCESS then
  begin
    // Serve partial content with rfProgressiveStatic flag
    Ctxt.RespStatus := HTTP_PARTIALCONTENT;
    Ctxt.OutContentType := STATICFILE_CONTENT_TYPE;
    // THttpPartials.ProcessBody streams .part file chunks
  end;
end;
```

### Bandwidth Limiting

Per-peer bandwidth control to prevent network saturation:

```pascal
THttpPeerCacheSettings = class(TSynPersistent)
published
  // Limit each peer to 10 MB/s (default)
  // = ~80-100 Mbps (considering protocol overhead)
  property LimitMBPerSec: integer read fLimitMBPerSec write fLimitMBPerSec;

  // Max concurrent peer downloads (default: 32)
  property LimitClientCount: integer read fLimitClientCount;
end;

// Applied to each download stream
OutStream.LimitPerSecond := Settings.LimitMBPerSec * 1024 * 1024;
```

### DoS Protection

**Connection limiting:**

```pascal
// Reject new requests if too many active connections
if CurrentConnections >= Settings.LimitClientCount then
begin
  // Send pcfResponseOverloaded in UDP
  // Or HTTP_UNAVAILABLE (503) in HTTP
end;
```

**IP banishment:**

```pascal
// Ban IPs sending invalid UDP frames or HTTP requests
// Uses THttpAcceptBan with per-minute resolution
if InvalidRequest(ip4) then
  fInstable.BanIP(ip4); // Banned for RejectInstablePeersMin (default: 4 min)
```

## 20.X.3. Cache Management

### Two-Tier Cache Architecture

**Temporary cache** (CacheTempPath):

- Files cached during downloads
- Subject to size limits (CacheTempMaxMB, default: 1 GB)
- Automatic TTL cleanup (CacheTempMaxMin, default: 60 minutes)
- Removed when disk space needed

**Permanent cache** (CachePermPath):

- Explicitly cached files (waoPermanentCache option)
- Never auto-deleted
- Survives reboots and cache purges

### Hash-Based Storage

Files stored by content hash (SHA-256/512):

```
CacheTempPath/
  abc123def456...789.cache      # SHA-256 hash (lowercase hex)
  fedcba987654...321.cache

CachePermPath/
  abc123def456...789.cache      # Permanent storage
```

**Optional sub-folder partitioning** (pcoCacheTempSubFolders):

```
CacheTempPath/
  0/abc0...cache                # First hex nibble = 0
  1/abc1...cache                # First hex nibble = 1
  ...
  f/abcf...cache                # First hex nibble = f
```

Reduces filesystem fragmentation on large caches.

### Cache Cleanup

**Triggered when:**

- `fTempCurrentSize > fTempFilesMaxSize` (CacheTempMaxMB exceeded)
- Periodic check every minute (via `OnIdle()`)

**Cleanup strategy:**

```pascal
1. Sort cached files by LastAccess timestamp
2. Remove oldest files first
3. Stop when size < CacheTempMaxMB * 0.9 (90% threshold)
4. Skip files accessed within CacheTempMaxMin (default: 60 min)
```

**Metadata persistence:**

```pascal
// THttpCacheFiles stores 32-byte records per file
THttpCached = packed record
  Hash: THash160;                // 160-bit hash (truncated from SHA-256/512)
  FirstAccess: TUnixTimeMinimal; // Creation time
  LastAccess: TUnixTimeMinimal;  // Last served time
  Padding: array[1..6] of byte;  // Future extensibility
end;

// Stored as 4KB pages (128 entries per page)
// Updated in real-time on disk
```

## 20.X.4. Integration with WGet

### IWGetAlternate Interface

`THttpPeerCache` implements `IWGetAlternate` for seamless integration with `THttpClientSocket.WGet()`:

```pascal
THttpClientSocketWGet = record
  Alternate: IWGetAlternate;          // Optional peer cache
  AlternateOptions: TWGetAlternateOptions;
  // ... other WGet settings
end;

// WGet workflow with peer cache:
// 1. HEAD request to origin (verify file exists, get size)
// 2. Call Alternate.OnDownload() to check peer cache
// 3. If peer cache hit → download from peer
// 4. If peer cache miss → fallback to origin server
// 5. Call Alternate.OnDownloaded() to cache new file
```

### Download Workflow

**Typical usage:**

```pascal
var
  params: THttpClientSocketWGet;
  peer: THttpPeerCache;
  client: THttpClientSocket;
begin
  // Initialize peer cache (once per application)
  peer := THttpPeerCache.Create(nil, 'shared-secret-key');

  // Configure WGet with peer cache
  params.Clear;
  params.Alternate := peer; // IWGetAlternate interface
  params.Hasher := TStreamRedirectSha256; // Required for hash-based lookup
  params.AlternateOptions := [waoPermanentCache]; // Optional

  // Download file (automatic peer cache)
  client := THttpClientSocket.Create;
  client.WGet('https://example.com/bigfile.iso', 'bigfile.iso', params);
end;
```

**Behind the scenes:**

```
1. WGet calls HEAD https://example.com/bigfile.iso
   → Gets Size=4GB, ETag="abc123"
   → Computes Hash=SHA256(URI + ETag)

2. WGet calls Alternate.OnDownload(Hash, Size)
   → peer.Broadcast(pcfRequest with Hash)
   → Peer responds pcfResponseFull (has file)
   → Download from peer instead of origin

3. If peer cache miss:
   → Fallback to GET https://example.com/bigfile.iso
   → Call Alternate.OnDownloaded(file) to cache locally

4. Next time same file is requested:
   → Instant cache hit from local or peer cache
```

### Alternate Options

```pascal
TWGetAlternateOption = (
  waoPermanentCache,               // Store in CachePermPath (never deleted)
  waoNoHeadFirst,                  // Skip HEAD, try OnDownload() immediately
  waoNoMinimalSize,                // Allow peer cache for small files
  waoTryLastPeer,                  // Try last successful peer first
  waoTryAllPeers,                  // Try best 10 peers before origin fallback
  waoBroadcastNotAlone,            // Disable broadcast if no peers found
  waoNoProgressiveDownloading      // Disable pcfResponsePartial requests
);
```

## 20.X.5. Advanced Features

### Direct HTTP Proxy Mode (pcoHttpDirect)

**Problem:** Clients need to download files but want to leverage peer cache transparently.

**Solution:** Encode remote URI into local HTTP request:

```pascal
// Server generates direct URI + bearer token
var
  directUri, bearer: RawUtf8;
begin
  THttpPeerCache.HttpDirectUri(
    'shared-secret',
    'https://example.com/file.zip',  // Remote URI
    'sha256-abc123',                  // Expected hash
    directUri,                        // → 'http://192.168.1.5:8099/https/example.com/file.zip'
    bearer                            // → 'Authorization: Bearer ...'
  );

  // Client downloads from local peer cache:
  HTTP.Get(directUri, bearer);
  // If cache miss → peer fetches from https://example.com/file.zip
  // If cache hit → instant response
end;
```

**URI encoding:**

```
Original: https://example.com/file.zip
Encoded:  http://192.168.1.5:8099/https/example.com/file.zip?bearer=...
          └──────┬──────────────┘ └────────┬───────────────┘
            Peer cache IP:Port     Reconstructed URI
```

**Use cases:**

- Web browsers downloading via peer proxy
- Package managers (apt, npm, docker) with HTTP proxy support
- Corporate environments with shared cache appliance

### TLS/HTTPS Support

**Server-side TLS:**

```pascal
var
  peer: THttpPeerCache;
  tls: TNetTlsContext;
begin
  tls.Enabled := true;
  tls.CertificateFile := 'peer-cert.pem';
  tls.PrivateKeyFile := 'peer-key.pem';

  peer := THttpPeerCache.Create(nil, 'secret', nil, 2, nil, @tls, nil);
  // HTTPS server on port 8099
end;
```

**Client-side TLS validation:**

```pascal
var
  tls: TNetTlsContext;
begin
  tls.Enabled := true;
  tls.OnPeerValidate := MyCustomCertValidation;

  peer := THttpPeerCache.Create(nil, 'secret', nil, 2, nil, nil, @tls);
  // Validate peer certificates during downloads
end;
```

**Self-signed certificates** (pcoSelfSignedHttps):

```pascal
// Enable on all peers for local trust
Settings.Options := [pcoSelfSignedHttps];
// Disables strict certificate validation for peer-to-peer
```

### Network Interface Detection

**Automatic selection:**

```pascal
// Picks best interface with broadcast support
// Priority: makEthernet > makWifi > makOther
peer := THttpPeerCache.Create(nil, 'secret');
// → Binds to 192.168.1.5:8099 (auto-detected)
```

**Manual selection:**

```pascal
Settings.InterfaceName := 'eth0';          // Linux interface name
Settings.InterfaceName := '192.168.1.5';   // Explicit IP
Settings.InterfaceName := '192.168.1.255'; // IP pattern match
```

**Interface change detection:**

```pascal
// Useful for laptops switching between WiFi/Ethernet
if peer.NetworkInterfaceChanged then
begin
  peer.Free;
  peer := THttpPeerCache.Create(Settings, 'secret'); // Rebind to new interface
end;
```

## 20.X.6. Performance Characteristics

### Latency

**UDP broadcast overhead:**

```
BroadcastTimeoutMS = 10 ms (default)
├─ Frame encryption: ~0.1 ms (AES-GCM)
├─ UDP send/receive: ~1-5 ms (local network)
├─ Peer processing: ~0.5 ms (hash lookup)
└─ Response decode: ~0.1 ms (AES-GCM)

Total overhead: ~10-15 ms per cache lookup
```

**Cache hit vs miss:**

```
Cache hit:  10 ms (UDP) + 5 ms (HTTP connect) = 15 ms to first byte
Cache miss: 10 ms (UDP) + 200 ms (Internet) = 210 ms to first byte

Speedup: ~14x faster for cached content
```

### Bandwidth Savings

**Example: 10 machines downloading 1 GB file**

**Without peer cache:**

```
10 machines × 1 GB = 10 GB downloaded from Internet
Time: 10 × (1 GB / 10 MB/s) = 100 seconds
```

**With peer cache:**

```
Machine 1: 1 GB from Internet (100 seconds)
Machines 2-10: 1 GB from Machine 1 (progressive)
  ├─ Start downloading from Machine 1 after ~10s (10% cached)
  ├─ Progressive download while Machine 1 continues
  └─ Parallel downloads from multiple peers

Total Internet: 1 GB (only first machine)
Time: ~110 seconds (slight overhead for first machine)

Bandwidth savings: 90% (9 GB saved)
```

### Scalability

**Tested scenarios:**

- **Small office:** 10-20 peers, 100 Mbps network → Excellent performance
- **Enterprise floor:** 50-100 peers, 1 Gbps network → Good performance
- **Data center:** 500+ peers, 10 Gbps network → Requires tuning

**Tuning for large deployments:**

```pascal
Settings.BroadcastMaxResponses := 48;    // Handle more peer responses
Settings.LimitClientCount := 64;         // More concurrent connections
Settings.BroadcastTimeoutMS := 20;       // Wait longer for responses
Settings.TryAllPeersCount := 20;         // Try more peers before fallback
```

## 20.X.7. Deployment Patterns

### Pattern 1: Desktop Application Auto-Update

```pascal
// Each client runs embedded peer cache
procedure TMyApp.AutoUpdate;
var
  peer: THttpPeerCache;
  params: THttpClientSocketWGet;
begin
  peer := THttpPeerCache.Create(nil, 'myapp-secret-v1');
  try
    params.Clear;
    params.Alternate := peer;
    params.Hasher := TStreamRedirectSha256;
    params.AlternateOptions := [waoPermanentCache]; // Keep updates cached

    WGet('https://cdn.example.com/myapp-v2.0.exe', 'myapp-v2.0.exe', params);
    // First machine downloads from Internet
    // Subsequent machines download from peers
  finally
    peer.Free;
  end;
end;
```

**Benefits:**

- 90%+ bandwidth savings during mass updates
- No server infrastructure changes needed
- Automatic peer discovery on corporate LANs

### Pattern 2: Build Server Cache

```pascal
// Shared cache for CI/CD pipeline
var
  peer: THttpPeerCache;
  settings: THttpPeerCacheSettings;
begin
  settings := THttpPeerCacheSettings.Create;
  settings.CachePermPath := '/var/cache/build-artifacts';
  settings.CachePermMinBytes := 1024; // Cache everything >= 1 KB
  settings.LimitMBPerSec := 100; // 100 MB/s = ~800 Mbps
  settings.LimitClientCount := 128; // Handle many concurrent builds
  settings.Options := [pcoHttpDirect]; // Proxy mode for build tools

  peer := THttpPeerCache.Create(settings, 'build-cache-secret');
  // Keep running as system service
end;
```

**Usage from build servers:**

```bash
# Configure build tools to use peer cache as HTTP proxy
export http_proxy=http://192.168.1.100:8099
export https_proxy=http://192.168.1.100:8099

# Downloads automatically cached and shared
npm install       # Node.js dependencies
cargo build       # Rust crates
docker pull       # Container images (via pcoHttpDirect)
```

### Pattern 3: Edge CDN Appliance

```pascal
// Dedicated cache appliance for remote office
var
  peer: THttpPeerCache;
  settings: THttpPeerCacheSettings;
begin
  settings := THttpPeerCacheSettings.Create;
  settings.CacheTempPath := '/cache/temp';      // 100 GB SSD
  settings.CachePermPath := '/cache/permanent';  // 1 TB HDD
  settings.CacheTempMaxMB := 100 * 1024;        // 100 GB temp cache
  settings.LimitMBPerSec := 0; // Unlimited (dedicated appliance)
  settings.Options := [pcoHttpDirect, pcoCacheTempSubFolders];
  settings.InterfaceName := 'eth0'; // Dedicated network interface

  peer := THttpPeerCache.Create(settings, 'office-cache-secret',
    THttpAsyncServer, 32); // Async server for high concurrency
end;
```

**Network topology:**

```
Internet ──► [Router/Firewall] ──► [Peer Cache Appliance] ──► LAN clients
                                      192.168.1.100:8099
                                      ├─ 100 GB temp cache
                                      └─ 1 TB permanent cache
```

### Pattern 4: Kubernetes Pod Cache

```pascal
// DaemonSet on each K8s node
var
  peer: THttpPeerCache;
begin
  peer := THttpPeerCache.Create(nil, GetEnv('PEER_CACHE_SECRET'));
  // Runs as sidecar container
  // Shares cache with pods on same node
  // UDP broadcasts within pod network
end;
```

**Benefits:**

- Container image layers cached per-node
- Faster pod startup times
- Reduced egress bandwidth costs

## 20.X.8. Configuration Reference

### THttpPeerCacheSettings

```pascal
constructor Create; override;
// Defaults:
//   Port = 8099
//   LimitMBPerSec = 10 (10 MB/s)
//   LimitClientCount = 32
//   RejectInstablePeersMin = 4 (4 minutes IP ban TTL)
//   CacheTempMaxMB = 1000 (1 GB)
//   CacheTempMaxMin = 60 (1 hour TTL)
//   CacheTempMinBytes = 2048 (2 KB minimum)
//   CachePermMinBytes = 2048
//   BroadCastDirectMinBytes = 65536 (64 KB)
//   BroadcastTimeoutMS = 10 (10 ms)
//   BroadcastMaxResponses = 24
//   HttpTimeoutMS = 500 (500 ms for peer HTTP)
```

### THttpPeerCacheOptions

```pascal
THttpPeerCacheOption = (
  pcoCacheTempSubFolders,       // 16 sub-folders (0-f) for large caches
  pcoCacheTempNoCheckSize,      // Skip CacheTempMaxMB disk space check
  pcoUseFirstResponse,          // Accept first UDP response (low latency)
  pcoTryLastPeer,               // Try last successful peer first (batching)
  pcoTryAllPeers,               // Try best 10 peers before origin fallback
  pcoBroadcastNotAlone,         // Disable broadcast if no peers found
  pcoNoServer,                  // Client-only mode (no UDP/HTTP server)
  pcoNoBanIP,                   // Disable HTTP-level IP banning
  pcoSelfSignedHttps,           // Allow self-signed TLS certificates
  pcoVerboseLog,                // Log all UDP frames and HTTP requests
  pcoHttpDirect,                // Enable direct HTTP proxy mode
  pcoHttpDirectNoBroadcast,     // Disable UDP broadcast for pcoHttpDirect
  pcoHttpDirectTryLastPeer,     // Try last peer for pcoHttpDirect
  pcoHttpReprDigest             // Include 'Repr-Digest:' header (RFC 9530)
);
```

## 20.X.9. Troubleshooting

### Common Issues

**"No peers found" during broadcast:**

```
Cause: Firewall blocking UDP port 8099
Fix:   Allow UDP broadcast on port 8099

       # Linux
       sudo ufw allow 8099/udp

       # Windows
       netsh advfirewall firewall add rule name="PeerCache UDP" ^
         protocol=UDP dir=in localport=8099 action=allow
```

**"Cache miss on local file":**

```
Cause: Hash mismatch (different hash algorithm or URI)
Fix:   Ensure same Hasher on all peers:

       params.Hasher := TStreamRedirectSha256; // Use SHA-256
```

**"Slow downloads from peers":**

```
Cause: LimitMBPerSec throttling
Fix:   Increase bandwidth limit:

       Settings.LimitMBPerSec := 100; // 100 MB/s = ~800 Mbps
       Settings.LimitMBPerSec := 0;   // Unlimited
```

**"HTTP 503 (Service Unavailable)":**

```
Cause: LimitClientCount exceeded
Fix:   Increase concurrent connection limit:

       Settings.LimitClientCount := 64; // Default: 32
```

### Debug Logging

**Enable verbose logging:**

```pascal
Settings.Options := [pcoVerboseLog];
peer := THttpPeerCache.Create(Settings, 'secret', nil, 2, TSynLog);

// Logs every UDP frame, HTTP request, cache lookup
```

**Sample log output:**

```
20241220 12:34:56.123 trace OnFrameReceived len=212 from 192.168.1.5:8099
  pcfRequest Seq=12345 UUID={abc-def-123} Hash=sha256:abc123... Size=1048576
20241220 12:34:56.125 trace Broadcast pcfResponseFull Connections=2 Speed=1000
20241220 12:34:56.130 debug OnDownload from 192.168.1.5 cached=true partial=false
```

## 20.X.10. Security Considerations

### Threat Model

**Assumptions:**

- Local network is trusted (e.g. corporate LAN, home WiFi)
- Shared secret is pre-distributed securely
- Physical network access is controlled

**Mitigations:**

```
Threat: Malicious peer sends forged UDP frames
├─ Mitigation: AES-GCM authentication (rejects invalid frames)
├─ Mitigation: IP banishment (RejectInstablePeersMin)
└─ Mitigation: Sequence number anti-replay

Threat: Peer sends corrupted file
├─ Mitigation: Hash verification (SHA-256/512)
├─ Mitigation: OnDownloadFailed() removes bad cache entry
└─ Mitigation: Automatic fallback to origin server

Threat: Eavesdropping on UDP broadcasts
├─ Mitigation: AES-256-GCM encryption (confidentiality)
└─ Mitigation: Random padding (anti-fingerprinting)

Threat: DoS via broadcast flooding
├─ Mitigation: IP banishment (THttpAcceptBan)
├─ Mitigation: CRC checksum (quick rejection)
└─ Mitigation: Connection limits (LimitClientCount)
```

### Best Practices

**1. Rotate shared secrets periodically:**

```pascal
// Generate strong shared secret
var
  secret: RawByteString;
begin
  secret := TAesPrng.Main.FillRandom(32); // 256-bit random key
  peer := THttpPeerCache.Create(nil, secret);
end;
```

**2. Use HTTPS for sensitive content:**

```pascal
Settings.Options := [pcoSelfSignedHttps]; // Or proper TLS certificates
peer := THttpPeerCache.Create(Settings, secret, nil, 2, nil, @tlsServer, @tlsClient);
```

**3. Isolate peer cache network:**

```pascal
// Bind to specific VLAN/subnet
Settings.InterfaceName := '10.0.1.255'; // Isolated cache network
```

**4. Monitor for anomalies:**

```pascal
// Check Instable.Rejected for frequent bans
if peer.Instable.Rejected > 100 then
  LogWarning('High peer rejection rate: possible attack');
```

---

## Summary

`THttpPeerCache` provides a production-ready P2P CDN with:

- **10-15 ms cache lookup latency** via UDP broadcasting
- **90%+ bandwidth savings** for repeated downloads
- **AES-256-GCM encryption** for all peer communication
- **Progressive downloads** with partial file serving
- **Zero-configuration** automatic peer discovery
- **DoS protection** via IP banning and connection limits

**Typical performance:**

- **Small files (< 1 MB):** 15-50 ms cache hit (vs 200+ ms Internet)
- **Large files (> 100 MB):** 90% bandwidth savings (9/10 peers use cache)
- **Concurrent downloads:** 32-128 peers supported per cache node

**Use cases:**

- Enterprise software distribution (updates, installers)
- CI/CD build artifact caching
- Container image registry mirrors
- Remote office edge caching
- Desktop application auto-update

**Next:** Chapter 21 covers HTTP/2 and HTTP/3 support in mORMot2.

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Chapter 20: HTTP Server](mORMot2-SAD-Chapter-20.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 21: HTTP/2 Support](mORMot2-SAD-Chapter-21.md) |
