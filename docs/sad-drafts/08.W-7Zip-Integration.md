# 8.W. 7-Zip Integration

*Powerful archive handling through native Pascal wrappers*

The `mormot.lib.win7zip` unit provides high-level Pascal wrappers around the 7-Zip compression library (7z.dll) on Windows, offering seamless access to compression and decompression capabilities across 60+ archive formats.

## 8.W.1. Overview

### Purpose

This unit abstracts the complex 7-Zip C++ API (which spans 10,000+ lines in raw form) into clean, easy-to-use Pascal interfaces. The wrapper eliminates the complexity of direct DLL interaction while providing full access to 7-Zip's powerful features.

### Key Features

- **High-level interfaces**: `I7zReader` for decompression, `I7zWriter` for compression
- **60+ archive formats**: zip, 7z, tar, gzip, bzip2, rar, iso, and many more
- **Password protection**: Built-in support for encrypted archives
- **Stream-based I/O**: Work with files, memory buffers, or custom streams
- **Progress callbacks**: Monitor compression/decompression operations
- **Metadata access**: Read/write file timestamps, attributes, CRC values

> **Note**: This unit is Windows-only and requires 7z.dll to be available at runtime.

---

## 8.W.2. Archive Reading (I7zReader)

### Interface Definition

```pascal
I7zReader = interface(I7zArchive)
  ['{9C0C0C8C-883A-49ED-B608-A6D66D36D53A}']
  // Opening archives
  procedure OpenFile(const name: TFileName);
  procedure OpenStream(stream: IInStream);
  procedure Close;

  // Property access
  function GetProp(item: cardinal; prop: TPropID): T7zVariant;

  // Extraction methods
  procedure Extract(item: cardinal; Stream: TStream); overload;
  procedure Extract(item: cardinal; const path: TFileName;
    nosubfolder: boolean); overload;
  function Extract(const zipname: RawUtf8; Stream: TStream): boolean; overload;
  function Extract(const zipname: RawUtf8): RawByteString; overload;
  function Extract(const zipname: RawUtf8; const path: TFileName;
    nosubfolder: boolean): boolean; overload;
  function Extract(const zipnames: array of RawUtf8; const path: TFileName;
    nosubfolder: boolean): TRawUtf8DynArray; overload;
  procedure Extract(const items: array of integer;
    const callback: T7zGetStreamCallBack); overload;
  procedure ExtractAll(const path: TFileName);

  // Testing
  function TestAll: boolean;

  // Low-level access
  function InArchive: IInArchive;
end;
```

### Common Operations

**Reading archive contents**:

```pascal
var
  reader: I7zReader;
  i: integer;
begin
  reader := New7zReader('archive.zip');
  try
    for i := 0 to reader.Count - 1 do
      WriteLn(reader.ZipName[i], ' (', reader.Size[i], ' bytes)');
  finally
    reader := nil; // Auto-cleanup via interface reference counting
  end;
end;
```

**Extracting specific files**:

```pascal
var
  reader: I7zReader;
  data: RawByteString;
begin
  reader := New7zReader('archive.7z');
  // Extract to memory
  data := reader.Extract('readme.txt');

  // Extract to disk
  reader.Extract('config.ini', 'C:\temp', false);

  // Extract multiple files
  reader.Extract(['file1.txt', 'file2.dat'], 'C:\output', false);
end;
```

**Password-protected archives**:

```pascal
reader := New7zReader('encrypted.zip', fhUndefined, '', 'mypassword');
// Or set password via callback
reader.SetPasswordCallback(
  function(const sender: I7zArchive; var password: RawUtf8): boolean
  begin
    password := 'secret';
    Result := true; // Continue execution
  end);
```

---

## 8.W.3. Archive Writing (I7zWriter)

### Interface Definition

```pascal
I7zWriter = interface(I7zArchive)
  ['{9C0C0C8C-883A-49ED-B608-A6D66D36D53B}']
  // Adding content
  function AddFile(const Filename: TFileName; const ZipName: RawUtf8): boolean;
  function AddFiles(const Dir, Path, Wildcard: TFileName;
    recurse: boolean): TFileNameDynArray;
  procedure AddBuffer(const ZipName: RawUtf8; const Data: RawByteString);
  procedure AddDirectory(const ZipName: RawUtf8);
  procedure AddStream(Stream: TStream; Ownership: TStreamOwnership;
    Attributes: cardinal; CreationTime, LastWriteTime: TUnixTime;
    const Path: RawUtf8; IsFolder, IsAnti: boolean);

  // Removing content
  procedure Remove(index: cardinal); overload;
  procedure Remove(const zipname: RawUtf8); overload;
  procedure ClearBatch;

  // Saving
  procedure SaveToFile(const FileName: TFileName);
  procedure SaveToStream(stream: IOutStream);

  // Configuration
  procedure SetCompressionLevel(level: cardinal);
  procedure SetCompressionMethod(method: T7zCompressionMethod);
  procedure SetDictionnarySize(size: cardinal);
  procedure SetMemorySize(size: cardinal);
  procedure SetDeflateNumPasses(pass: cardinal);
  procedure SetNumFastBytes(fb: cardinal);
  procedure SetNumMatchFinderCycles(mc: cardinal);
  procedure SetNumThreads(count: cardinal);
  procedure BindToItem(index: integer);
  procedure SetEncryptionMethod(method: T7zEncryptionMethod);
  procedure SetSolidSettings(solid: boolean);
  procedure SetMultiThreading(multithread: boolean);
  procedure VolumeMode7z(mode: boolean);

  // Low-level access
  function OutArchive: IOutArchive;
end;
```

### Common Operations

**Creating a new archive**:

```pascal
var
  writer: I7zWriter;
begin
  writer := New7zWriter(fh7z);
  writer.AddFile('C:\data\file1.txt', 'file1.txt');
  writer.AddFile('C:\data\file2.dat', 'subfolder\file2.dat');
  writer.SetCompressionLevel(9); // Maximum compression
  writer.SaveToFile('output.7z');
end;
```

**Adding multiple files**:

```pascal
writer := New7zWriter(fhZip);
// Add all .txt files from a directory recursively
writer.AddFiles('C:\docs', '', '*.txt', true);
writer.SaveToFile('documents.zip');
```

**Adding from memory**:

```pascal
var
  data: RawByteString;
begin
  data := 'This is file content';
  writer := New7zWriter(fhZip);
  writer.AddBuffer('readme.txt', data);
  writer.SaveToFile('archive.zip');
end;
```

**Password protection**:

```pascal
writer := New7zWriter(fh7z);
writer.SetPassword('secret123');
writer.SetEncryptionMethod(emAes256);
writer.AddFile('sensitive.doc', 'sensitive.doc');
writer.SaveToFile('encrypted.7z');
```

**Compression settings**:

```pascal
writer := New7zWriter(fh7z);
writer.SetCompressionMethod(m7Lzma2); // LZMA2 algorithm
writer.SetCompressionLevel(9);        // Maximum
writer.SetDictionnarySize(64 * 1024 * 1024); // 64 MB dictionary
writer.SetNumThreads(4);              // Multi-threaded compression
writer.AddFiles('C:\project', '', '*.*', true);
writer.SaveToFile('backup.7z');
```

---

## 8.W.4. Supported Formats

The wrapper supports 60+ archive formats through the `T7zFormatHandler` enumeration:

### Common Formats

| Format | Constant | Description |
|--------|----------|-------------|
| ZIP | `fhZip` | Standard ZIP archives |
| 7z | `fh7z` | 7-Zip native format |
| TAR | `fhTar` | Unix tape archive |
| GZIP | `fhGZip` | GNU zip compression |
| BZIP2 | `fhBZip2` | bzip2 compression |
| RAR | `fhRar` | RAR archives (read-only) |
| RAR5 | `fhRar5` | RAR 5.x format (read-only) |
| ISO | `fhIso` | ISO disk images |
| CAB | `fhCab` | Microsoft Cabinet |

### Archive Formats

| Format | Constant | Description |
|--------|----------|-------------|
| LZMA | `fhlzma` | LZMA compressed |
| XZ | `fhxz` | XZ Utils format |
| ARJ | `fhArj` | ARJ archives |
| LZH | `fhLzh` | LHA/LZH format |
| NSIS | `fhNsis` | Nullsoft installers |
| WIM | `fhWim` | Windows imaging |
| CHM | `fhChm` | Compiled HTML Help |
| CPIO | `fhCpio` | Unix CPIO |
| RPM | `fhRpm` | RedHat packages |
| DEB | `fhDeb` | Debian packages |

### Disk Image Formats

| Format | Constant | Description |
|--------|----------|-------------|
| VHD | `fhVhd` | Virtual hard disk |
| VHDX | `fhVhdx` | Hyper-V VHDX |
| VMDK | `fhVMDK` | VMware disk |
| VDI | `fhVDI` | VirtualBox disk |
| QCOW | `fhQcow` | QEMU disk image |
| DMG | `fhDmg` | Apple disk image |
| HFS | `fhHfs` | Mac HFS/HFS+ |
| APFS | `fhAPFS` | Apple File System |

### Filesystem Formats

| Format | Constant | Description |
|--------|----------|-------------|
| NTFS | `fhNtfs` | NTFS filesystem |
| FAT | `fhFat` | FAT filesystem |
| EXT | `fhExt` | Linux ext2/3/4 |
| UDF | `fhUdf` | Universal Disk Format |
| SquashFS | `fhSquashFS` | Embedded Linux FS |
| CramFS | `fhCramFS` | Compressed ROM FS |

### Executable Formats

| Format | Constant | Description |
|--------|----------|-------------|
| PE | `fhPe` | Windows executables |
| ELF | `fhElf` | Unix executables |
| Mach-O | `fhMachO` | macOS executables |
| COFF | `fhCOFF` | Common Object Format |

### Specialized Formats

| Format | Constant | Description |
|--------|----------|-------------|
| XAR | `fhXar` | eXtensible ARchive |
| Compound | `fhCompound` | MS Compound files |
| MBR | `fhMbr` | Master boot record |
| GPT | `fhGPT` | GUID partition table |
| Base64 | `fhBase64` | Base64 encoded |
| Split | `fhSplit` | Split archives |

---

## 8.W.5. Common Interfaces

### I7zArchive (Base Interface)

Both `I7zReader` and `I7zWriter` inherit from `I7zArchive`, which provides common functionality:

```pascal
I7zArchive = interface
  ['{9C0C0C8C-883A-49ED-B608-A6D66D36D530}']
  // Format information
  function FileName: TFileName;
  function Format: T7zFormatHandler;
  function FormatExt: string;
  function FormatExts: string;
  function ClassId: TGuid;

  // Callbacks
  procedure SetProgressCallback(const callback: T7zProgressCallback);
  procedure SetPasswordCallback(const callback: T7zPasswordCallback);
  procedure SetPassword(const password: RawUtf8);

  // Archive content
  function Count: integer;
  function NameToIndex(const zipname: RawUtf8): integer;

  // File properties (indexed access)
  property ZipName[index: integer]: RawUtf8 read GetZipName;
  property FullName[index: integer]: RawUtf8 read GetName;
  property Size[index: integer]: Int64 read GetSize;
  property PackSize[index: integer]: Int64 read GetPackSize;
  property Crc[index: integer]: cardinal read GetCrc;
  property Method[index: integer]: RawUtf8 read GetMethod;
  property Comment[index: integer]: RawUtf8 read GetComment;
  property IsFolder[index: integer]: boolean read GetIsFolder;
  property ModDate[index: integer]: TDateTime read GetModDate;
  property CreateDate[index: integer]: TDateTime read GetCreateDate;
  property Attributes[index: integer]: cardinal read GetAttributes;
end;
```

### Callback Types

**Progress monitoring**:

```pascal
T7zProgressCallback = function(const sender: I7zArchive;
  current, total: Int64): HRESULT of object;

// Usage
writer.SetProgressCallback(
  function(const sender: I7zArchive; current, total: Int64): HRESULT
  begin
    WriteLn(Format('Progress: %d%%', [(current * 100) div total]));
    Result := S_OK; // Continue
  end);
```

**Password handling**:

```pascal
T7zPasswordCallback = function(const sender: I7zArchive;
  var password: RawUtf8): boolean of object;

// Usage
reader.SetPasswordCallback(
  function(const sender: I7zArchive; var password: RawUtf8): boolean
  begin
    Write('Enter password: ');
    ReadLn(password);
    Result := true; // Continue
  end);
```

**Custom extraction**:

```pascal
T7zGetStreamCallBack = function(const sender: I7zArchive; index: cardinal;
  var outStream: ISequentialOutStream): HRESULT of object;

// Usage - extract to custom destinations
reader.Extract([0, 1, 2],
  function(const sender: I7zArchive; index: cardinal;
    var outStream: ISequentialOutStream): HRESULT
  begin
    outStream := TOutFileStream.Create('custom_' + IntToStr(index) + '.dat');
    Result := S_OK;
  end);
```

---

## 8.W.6. Factory and Library Management

### I7zLib Interface

The `I7zLib` interface manages the 7z.dll lifecycle and provides factory methods:

```pascal
I7zLib = interface
  function FileName: TFileName;
  function NewReader(fmt: T7zFormatHandler): I7zReader; overload;
  function NewReader(const name: TFileName;
    fmt: T7zFormatHandler = fhUndefined;
    const pw: RawUtf8 = ''): I7zReader; overload;
  function NewWriter(fmt: T7zFormatHandler): I7zWriter; overload;
  function NewWriter(const name: TFileName;
    fmt: T7zFormatHandler = fhUndefined): I7zWriter; overload;
end;
```

**Explicit library management**:

```pascal
var
  lib: I7zLib;
  reader: I7zReader;
begin
  // Load 7z.dll explicitly
  lib := T7zLib.Create('C:\Tools\7z.dll');
  try
    reader := lib.NewReader('archive.zip');
    // Use reader...
  finally
    lib := nil; // Unload DLL
  end;
end;
```

### Global Factory Functions

**Simplified reader creation**:

```pascal
function New7zReader(const name: TFileName;
  fmt: T7zFormatHandler = fhUndefined;
  const lib: TFileName = '';
  const pw: RawUtf8 = ''): I7zReader;

// Usage
reader := New7zReader('archive.zip'); // Auto-detect format
reader := New7zReader('data.tar.gz', fhGZip, '', 'password');
```

**Simplified writer creation**:

```pascal
function New7zWriter(fmt: T7zFormatHandler;
  const lib: TFileName = ''): I7zWriter; overload;

function New7zWriter(const name: TFileName;
  fmt: T7zFormatHandler = fhUndefined;
  const lib: TFileName = ''): I7zWriter; overload;

// Usage
writer := New7zWriter(fh7z); // Create new 7z archive
writer := New7zWriter('existing.zip'); // Update existing ZIP
```

### Format Detection

```pascal
class function T7zLib.FormatDetect(const FileName: TFileName;
  OnlyFileName: boolean = false): T7zFormatHandler;

// Usage
var
  fmt: T7zFormatHandler;
begin
  fmt := T7zLib.FormatDetect('unknown.dat'); // Reads file header
  WriteLn('Detected format: ', T7zLib.FormatFileExtension(fmt));
end;
```

---

## 8.W.7. Licensing Considerations

### 7-Zip Library License

The 7-Zip library (7z.dll) is licensed under the **GNU LGPL** license. When using 7z.dll in your application, you must:

1. **Specify in documentation** that you used parts of the 7-Zip program
2. **State the license**: "7-Zip is licensed under the GNU LGPL license"
3. **Provide a link**: Include www.7-zip.org where source code can be found

### mORMot Wrapper License

The `mormot.lib.win7zip` wrapper code is licensed under mORMot 2's **MPL/GPL/LGPL tri-license** (see LICENSE.md).

### Third-Party Attribution

The wrapper interfaces were inspired by MPL 2.0 licensed code from:
- https://github.com/PascalVault/Lazarus_7zip

### Commercial Usage

**Can I use 7z.dll in commercial applications?**

Yes, the GNU LGPL license permits commercial use, provided you:
- Comply with the documentation requirements above
- Allow users to replace the 7z.dll with a different LGPL-compatible version
- Do not statically link the library (dynamic loading via DLL is acceptable)

The mORMot wrapper provides dynamic loading, making commercial usage straightforward.

---

## 8.W.8. Platform Limitations

> **Important**: This unit is **Windows-only**. On POSIX systems (Linux, macOS), the unit compiles as a do-nothing unit.

**Platform check**:

```pascal
{$ifdef OSPOSIX}
// Unit does nothing on non-Windows systems
implementation
{$else}
// Full Windows implementation
{$endif}
```

**Alternative for cross-platform projects**:
- Use mORMot's built-in compression (`mormot.core.zip`, `mormot.core.buffers`)
- Use external tools (command-line 7z) via `mormot.core.os.RunCommand`
- Use platform-specific libraries (libarchive on Linux/macOS)

---

## 8.W.9. Practical Examples

### Example 1: Archive Browser

```pascal
procedure BrowseArchive(const FileName: TFileName);
var
  reader: I7zReader;
  i: integer;
begin
  reader := New7zReader(FileName);
  WriteLn('Archive: ', reader.FileName);
  WriteLn('Format: ', reader.FormatExt);
  WriteLn('Files: ', reader.Count);
  WriteLn;

  for i := 0 to reader.Count - 1 do
  begin
    WriteLn(Format('%-40s  %10d bytes  %s', [
      reader.ZipName[i],
      reader.Size[i],
      DateTimeToStr(reader.ModDate[i])
    ]));
  end;
end;
```

### Example 2: Batch Compression

```pascal
procedure CompressDirectory(const SourceDir, TargetArchive: TFileName);
var
  writer: I7zWriter;
  failed: TFileNameDynArray;
begin
  writer := New7zWriter(fh7z);
  writer.SetCompressionLevel(5); // Balanced compression
  writer.SetNumThreads(4);       // Use 4 CPU cores

  failed := writer.AddFiles(SourceDir, '', '*.*', true);

  if Length(failed) > 0 then
    WriteLn('Warning: ', Length(failed), ' files could not be added');

  writer.SaveToFile(TargetArchive);
  WriteLn('Created: ', TargetArchive);
end;
```

### Example 3: Extract with Progress

```pascal
procedure ExtractWithProgress(const ArchiveName, DestPath: TFileName);
var
  reader: I7zReader;
begin
  reader := New7zReader(ArchiveName);

  reader.SetProgressCallback(
    function(const sender: I7zArchive; current, total: Int64): HRESULT
    var
      pct: integer;
    begin
      if total > 0 then
      begin
        pct := (current * 100) div total;
        Write(#13'Extracting... ', pct, '%');
      end;
      Result := S_OK; // Continue
    end);

  reader.ExtractAll(DestPath);
  WriteLn(#13'Extraction complete!');
end;
```

### Example 4: Selective Extraction

```pascal
function ExtractTextFiles(const ArchiveName: TFileName): TRawUtf8DynArray;
var
  reader: I7zReader;
  i: integer;
  textFiles: TRawUtf8DynArray;
  count: integer;
begin
  reader := New7zReader(ArchiveName);
  SetLength(textFiles, reader.Count);
  count := 0;

  // Find all .txt files
  for i := 0 to reader.Count - 1 do
    if IdemPropNameU(ExtractFileExt(reader.ZipName[i]), '.txt') then
    begin
      textFiles[count] := reader.ZipName[i];
      Inc(count);
    end;

  SetLength(textFiles, count);

  // Extract to temp directory
  Result := reader.Extract(textFiles, GetTempPath, false);
end;
```

---

## 8.W.10. Best Practices

### Resource Management

**Use interface reference counting**:

```pascal
var
  reader: I7zReader;
begin
  reader := New7zReader('archive.zip');
  try
    // Use reader
  finally
    reader := nil; // Explicit cleanup (or let it go out of scope)
  end;
end;
```

### Error Handling

**Exceptions are raised via `E7Zip`**:

```pascal
try
  reader := New7zReader('corrupted.zip');
  reader.ExtractAll('C:\output');
except
  on E: E7Zip do
    WriteLn('Archive error: ', E.Message);
  on E: Exception do
    WriteLn('General error: ', E.Message);
end;
```

### Performance Optimization

**Multi-threaded compression**:

```pascal
writer := New7zWriter(fh7z);
writer.SetNumThreads(CPUCount); // Use all available cores
writer.SetDictionnarySize(128 * 1024 * 1024); // Large dictionary for big files
```

**Balanced settings**:

```pascal
// Fast compression (level 1)
writer.SetCompressionLevel(1);
writer.SetCompressionMethod(m7Copy); // Store only

// Normal compression (level 5)
writer.SetCompressionLevel(5);
writer.SetCompressionMethod(m7Lzma);

// Maximum compression (level 9)
writer.SetCompressionLevel(9);
writer.SetCompressionMethod(mzLzma2);
writer.SetDictionnarySize(64 * 1024 * 1024);
```

### Memory Management

**Stream ownership**:

```pascal
var
  stream: TMemoryStream;
begin
  stream := TMemoryStream.Create;
  writer.AddStream(stream, soOwned, 0, 0, 0, 'file.dat', false, false);
  // Stream is now owned by writer - don't free it manually
end;
```

---

*Next: Chapter 9 - Framework Organization*
