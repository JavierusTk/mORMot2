# 20.Y. Firewall Traversal

*Breaking Through Barriers*

## 20.Y.1. WebSockets Relay Architecture

### Purpose and Design

The mORMot 2 relay system provides **secured tunneling over WebSockets** to enable remote client connections to servers behind corporate firewalls without requiring firewall reconfiguration or DMZ deployment.

**Core Architecture**:

```
REMOTE USERS                    CORPORATE FIREWALL

┌──────────┐                                            ┌──────────┐
│ Client 1 │                                            │ Client 3 │
└────┬─────┘                                            └────┬─────┘
     │                                                       │
     │         PUBLIC RELAY          PRIVATE RELAY          │
     │      ┌────────────────┐     ┌─────────────────────────────┐
     └──────►                │     │                         │    │
            │ Encapsulation  │◄────┤ Decapsulation           │    │
┌──────────┐│                │     │                         ▼    │
│ Client 2 ││ WebSocket      │     │            ┌─────────────────┤
└────┬─────┘│ Server         │     │            │  mORMot Server  │
     │      │                │     │            │  ORM/SOA/REST   │
     └──────►                │     │            │  Local Database │
            │                │     │            └─────────────────┤
            └────────────────┘     │                         ▲    │
                                   └─────────────────────────┼────┘
                 Internet                 Corporate LAN      │
                                                        ┌──────────┐
                                                        │ Client 4 │
                                                        └──────────┘
```

### Key Components

**TPublicRelay** - Public relay server process:
- Accepts client connections on one port
- Accepts Private Relay connection on another port
- Encapsulates client frames with connection ID
- Relays bidirectional traffic between endpoints
- Minimal resource usage (simple pass-through)
- Optional JWT authentication for Private Relay

**TPrivateRelay** - Private relay client process:
- Single connection to Public Relay server
- Creates multiple local connections to backend server
- Decapsulates frames and routes to appropriate local connection
- Can run in-process with the main application server
- No firewall modifications required

**Protocol Classes**:

| Class | Direction | Purpose |
|-------|-----------|---------|
| `TSynopseServerProtocol` | Public→Client | Implements mORMot WebSocket protocols (synopsejson/synopsebin/synopsebinary) |
| `TRelayServerProtocol` | Public→Private | Encapsulates frames with connection ID |
| `TRelayClientProtocol` | Private→Public | Decapsulates frames, routes to local server |
| `TSynopseClientProtocol` | Private→Server | Forwards raw frames to local backend |

### Wire Protocol

**Frame Encapsulation** (`TRelayFrame`):

```pascal
TRelayFrame = packed record
  revision: word;                     // RELAYFRAME_VER = $aa00
  opcode: TWebSocketFrameOpCode;      // focBinary, focText, etc.
  content: TWebSocketFramePayloads;   // Frame metadata flags
  connection: THttpServerConnectionID; // Unique client connection ID
  payload: RawByteString;             // Actual frame data
end;
```

**Frame Processing**:
1. Original WebSocket frame received from client
2. Public Relay encapsulates with `TRelayFrame` structure
3. Compressed with SynLZ (optional, threshold-based)
4. Encrypted if relay key provided (via `SetEncryptKey`)
5. Transmitted as `focBinary` frame to Private Relay
6. Private Relay decrypts, decompresses, validates
7. Extracts connection ID and original frame
8. Routes to appropriate local server connection

**REST Frame Support** (`TRelayFrameRestPayload`):

For HTTP/REST requests that don't use WebSockets:

```pascal
TRelayFrameRestPayload = packed record
  status: integer;           // HTTP status code
  url, method: RawUtf8;      // Request URL and HTTP method
  headers: RawUtf8;          // HTTP headers (purged)
  contenttype: RawUtf8;      // Content-Type header
  content: RawByteString;    // Request/response body
end;
```

Opcode `focRestPayload` (= `focReservedF`) indicates REST frame.

## 20.Y.2. NAT Traversal and DMZ Deployment

### Firewall-Friendly Design

**No Inbound Firewall Rules Required**:
- Private Relay initiates outbound WebSocket connection
- All communication flows through single HTTPS upgrade
- Corporate firewall sees normal outbound HTTPS traffic
- No port forwarding or DMZ configuration needed

**Connection Flow**:

```
1. Private Relay → Public Relay
   - Outbound WebSocket connection
   - Optional bearer token for JWT authentication
   - Optional encryption key for relay traffic

2. Client → Public Relay
   - Standard mORMot WebSocket client connection
   - Uses synopsejson/synopsebin protocols
   - Receives unique connection ID

3. Bidirectional Relay
   Public Relay:
     Client frames → encapsulate(connectionID) → Private Relay
     Private Relay → decapsulate(connectionID) → Client frames

   Private Relay:
     Encapsulated frame → extract connectionID → route to local server
     Local server response → encapsulate → Public Relay
```

### DMZ Deployment Patterns

**Pattern 1: Internet-Facing Public Relay**

```
Internet ──► [Public Relay] ◄── Corporate Network [Private Relay + Server]
              (Linux VPS)                            (Behind Firewall)
              Port 8080 (clients)
              Port 8090 (relay)
```

**Advantages**:
- Minimal public infrastructure (single small VPS)
- No corporate firewall changes
- Private Relay in-process with backend server
- Zero corporate IT involvement

**Pattern 2: DMZ Public Relay**

```
Internet ──► [DMZ: Public Relay] ──► [Internal: Private Relay + Server]
              Corp Network Edge           Secure Internal Zone
```

**Advantages**:
- Public Relay within corporate control
- Additional network segmentation
- Corporate security policies enforced
- Can leverage existing DMZ infrastructure

### Connection Management

**Client Connection Lifecycle**:

```
1. Client connects to Public Relay
   → TSynopseServerProtocol.ProcessIncomingFrame(focContinuation)
   → Encapsulate with new connectionID
   → Transmit to Private Relay

2. Private Relay receives connection
   → TRelayClientProtocol.ProcessIncomingFrame(focContinuation)
   → Create new TServerClient
   → Connect to local backend server
   → Store mapping: connectionID ↔ local connection

3. Data exchange
   Client → Public → Private → Server
   Server → Private → Public → Client

4. Client disconnects
   → focConnectionClose frame sent
   → TServerClient removed from Private Relay
   → Local server connection closed
```

**Failure Handling**:
- If Public Relay goes down: all connections notified with `focConnectionClose`
- If Private Relay disconnects: clients receive connection close
- If local server unavailable: Private Relay rejects new connections
- No dangling sockets on any failure scenario

## 20.Y.3. Security Architecture

### Encryption Layers

**Layer 1: WebSocket Protocol Encryption** (Client ↔ Backend Server):

```pascal
// Client-side configuration
Client.WebSocketsUpgrade('ws://publicrelay:8080',
  TWebSocketProtocolBinaryEncrypted.Create('MyEncryptionKey'));

// Server sees encrypted frames regardless of relay
```

**Benefits**:
- End-to-end encryption between client and backend
- Public Relay cannot decrypt business data
- Uses `TWebSocketProtocolBinary` built-in AES encryption
- No certificates or PKI required for basic setup

**Layer 2: Relay Link Encryption** (Public ↔ Private Relay):

```pascal
// Private Relay side
TPrivateRelay.Create(aLog,
  'publicrelay.com', '8090',  // Public Relay address
  'RelaySecretKey',            // Symmetric encryption key
  'BearerTokenForAuth',        // JWT authentication
  'localhost', '8888',         // Local server address
  '');                         // No remote IP header
```

**Implementation**:
- `TRelayServerProtocol.SetEncryptKey(aServerKey)` on Public side
- `TRelayClientProtocol.SetEncryptKey(aRelayKey)` on Private side
- Uses `TWebSocketProtocol.Encryption` (AES-CFB/OFB)
- Encrypts entire `TRelayFrame` payload after serialization

**Layer 3: JWT Authentication** (Private Relay → Public Relay):

```pascal
// Public Relay side
fServerJwt := TJwtHS256.Create('SecretJWTKey', 0, [], []);
PublicRelay := TPublicRelay.Create(aLog,
  '8080',        // Client port
  '8090',        // Relay port
  'RelayKey',    // Encryption key
  fServerJwt);   // JWT validator
```

**OnBeforeBody Validation**:
```pascal
function TPublicRelay.OnServerBeforeBody(...; aBearerToken: RawUtf8): cardinal;
begin
  res := fServerJwt.Verify(aBearerToken);
  if res = jwtValid then
    result := HTTP_SUCCESS
  else
    result := HTTP_FORBIDDEN; // 403
end;
```

**Benefits**:
- Prevents unauthorized Private Relay connections
- Token-based authentication (no password transmission)
- Can integrate with existing JWT infrastructure
- Configurable token expiration and claims

### Attack Surface Mitigation

**Frame Validation**:

```pascal
function TAbstractRelay.Decapsulate(Protocol: TWebSocketProtocol;
  var Frame: TWebSocketFrame): THttpServerConnectionID;
begin
  // 1. Decrypt if encrypted
  if Protocol.Encrypted then
    Protocol.Encryption.Decrypt(Frame.payload, plain);

  // 2. Decompress and validate structure
  if AlgoSynLZ.TryDecompress(plain, Frame.payload) and
     (length(Frame.payload) > 8) and
     (PRelayFrame(Frame.payload)^.revision = RELAYFRAME_VER) and
     (PRelayFrame(Frame.payload)^.opcode in [focContinuation,
       focConnectionClose, focBinary, focText, focRestPayload]) then
  begin
    // 3. Deserialize and validate
    if RecordLoad(encapsulated, Frame.payload, TypeInfo(TRelayFrame)) then
    begin
      inc(fValid);
      result := encapsulated.connection;
    end
  else
    inc(fInvalid); // Reject malformed frames
end;
```

**Protection Against**:
- **Frame Injection**: Validates revision number, opcode, structure
- **Replay Attacks**: Connection ID must exist in active list
- **Amplification**: Frame size limited, compression threshold enforced
- **Resource Exhaustion**: Single Private Relay instance enforced
- **Fuzzing**: Strict type validation, safe deserialization

**Connection Isolation**:
- Each client gets unique `THttpServerConnectionID`
- No cross-connection data leakage
- Connection mapping only in Private Relay (not exposed)
- Public Relay is stateless relay (no business logic)

### Important Security Considerations

**⚠️ Incompatibility with rsoPerConnectionNonce**:

```pascal
// DO NOT USE with relay
Server.Options := [rsoPerConnectionNonce]; // INCOMPATIBLE

// Relay requires consistent session encryption across connection hops
```

**Reason**: Per-connection nonces break frame routing when connection ID changes.

**Certificate-Based Mutual Authentication**:

While relay supports TLS/certificates at WebSocket level, relay-specific encryption is symmetric. For production deployments with strict security requirements:

1. Use TLS for Public Relay client connections
2. Use relay encryption key for Public↔Private link
3. Use JWT for Private Relay authentication
4. Implement client certificate validation if needed

**Audit and Monitoring**:

```pascal
property Frames: integer read fFrames;      // Total frames relayed
property Valid: integer read fValid;        // Valid frames
property Invalid: integer read fInvalid;    // Rejected frames
property Rejected: integer read fRejected;  // Auth failures
property RestFrames: integer read fRestFrames; // REST requests
```

Monitor these metrics for:
- Unusual invalid/rejected frame ratios (potential attack)
- REST frame latency (potential bottleneck)
- Connection count anomalies (DoS attempts)

### Production Deployment Checklist

**Public Relay Server**:
- [ ] Deploy on minimal infrastructure (256MB RAM sufficient)
- [ ] Configure JWT with strong secret key
- [ ] Set relay encryption key (different from JWT secret)
- [ ] Enable logging for security audit trail
- [ ] Implement rate limiting at network layer
- [ ] Monitor `/STAT` endpoint for health metrics
- [ ] Restrict relay port (8090) to known Private Relay IPs

**Private Relay Client**:
- [ ] Use strong relay encryption key (matches Public)
- [ ] Configure JWT bearer token (matches Public's secret)
- [ ] Set appropriate backend server address
- [ ] Configure `ServerRemoteIPHeader` if needed (`X-Real-IP`)
- [ ] Implement reconnection logic for Public Relay failures
- [ ] Test failover scenarios

**Network Configuration**:
- [ ] No inbound firewall rules needed (outbound only)
- [ ] Allow outbound HTTPS from Private Relay to Public Relay
- [ ] Optional: whitelist Public Relay IP for additional security

---

## Navigation

| Previous | Index | Next |
|----------|-------|------|
| [Chapter 20.X: Previous Section](mORMot2-SAD-Chapter-20.X.md) | [Index](mORMot2-SAD-Index.md) | [Chapter 21: Next Chapter](mORMot2-SAD-Chapter-21.md) |
