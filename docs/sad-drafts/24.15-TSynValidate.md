# 24.15. Domain Validation

*Data Integrity Through Declarative Rules*

The mORMot 2 framework provides a comprehensive validation and filtering system through `TSynValidate` and `TSynFilter` classes. This system enables declarative data integrity rules that can be applied to both standalone DTOs and ORM entities, ensuring data quality at the model layer rather than scattering validation logic throughout application code.

---

## Architecture Overview

### Core Design

The validation framework consists of three main class hierarchies:

```
TSynFilterOrValidate (abstract base)
    │
    ├─► TSynValidate (validation rules)
    │       │
    │       ├─► TSynValidateIPAddress
    │       ├─► TSynValidateEmail
    │       ├─► TSynValidatePattern / TSynValidatePatternI
    │       ├─► TSynValidateNonVoidText
    │       ├─► TSynValidateText
    │       ├─► TSynValidatePassWord
    │       └─► TSynValidateRest (ORM-specific)
    │               ├─► TSynValidateUniqueField
    │               └─► TSynValidateUniqueFields
    │
    └─► TSynFilter (transformation rules)
            ├─► TSynFilterUpperCase / TSynFilterUpperCaseU
            ├─► TSynFilterLowerCase / TSynFilterLowerCaseU
            ├─► TSynFilterTrim
            └─► TSynFilterTruncate
```

**Key principles**:
- **Declarative**: Rules declared as class instances with JSON parameters
- **Composable**: Multiple validators/filters can be chained per field
- **Reusable**: Same rule instance can apply to multiple fields
- **Extensible**: Custom validators via simple class inheritance

---

## TSynValidate Hierarchy

### Base Class: TSynValidate

All validation rules inherit from `TSynValidate` and implement the `Process` method:

```pascal
TSynValidate = class(TSynFilterOrValidate)
public
  function Process(aFieldIndex: integer; const Value: RawUtf8;
    var ErrorMsg: string): boolean; virtual; abstract;
  class function Execute(const aParameters, aValue: RawUtf8): string;
end;
```

**Usage pattern**:
- `Process()` returns `true` if validation passes, `false` otherwise
- On failure, `ErrorMsg` contains user-facing error description
- `Execute()` provides one-shot validation without instantiation

### Built-in Validators

#### Network Validators

**TSynValidateIPAddress** - IP v4 address validation:

```pascal
// No parameters required
validator := TSynValidateIPAddress.Create;
result := validator.Process(0, '192.168.1.1', errMsg); // true
result := validator.Process(0, '999.999.999.999', errMsg); // false
```

**TSynValidateEmail** - RFC 822 email validation with TLD filtering:

```pascal
// JSON parameters: AllowedTLD, ForbiddenTLD, AnyTLD, ForbiddenDomains
validator := TSynValidateEmail.Create('{"AllowedTLD":"com,org,net"}');
result := validator.Process(0, 'user@example.com', errMsg); // true
result := validator.Process(0, 'user@example.fr', errMsg);  // false (TLD not allowed)

// Allow any TLD but forbid temporary email domains
validator := TSynValidateEmail.Create(
  '{"AnyTLD":true,"ForbiddenDomains":"mailinator.com,yopmail.com"}');
```

**Properties**:
- `AllowedTLD`: CSV list of allowed top-level domains (e.g., `'com,org,net'`)
- `ForbiddenTLD`: CSV list of forbidden TLDs (e.g., `'fr'`)
- `ForbiddenDomains`: CSV list of forbidden full domains (e.g., `'mailinator.com'`)
- `AnyTLD`: Allow any TLD (boolean) - useful given 1,300+ new gTLDs

#### Pattern Validators

**TSynValidatePattern** - Glob pattern matching (case-sensitive):

```pascal
// Pattern syntax: ?, *, [abc], [^abc], [a-z]
validator := TSynValidatePattern.Create('[0-9][0-9]:[0-9][0-9]:[0-9][0-9]');
result := validator.Process(0, '14:35:22', errMsg); // true
result := validator.Process(0, '14:3:22', errMsg);  // false

// Complex pattern
validator := TSynValidatePattern.Create('ma?ch.*');
result := validator.Process(0, 'match.exe', errMsg); // true
result := validator.Process(0, 'mavch.dat', errMsg); // true
```

**Pattern syntax**:
- `?` - Matches any single character
- `*` - Matches any contiguous characters
- `[abc]` - Matches a, b, or c at position
- `[^abc]` or `[!abc]` - Matches anything but a, b, c
- `[a-e]` - Matches a through e at position

**TSynValidatePatternI** - Case-insensitive variant (same API)

#### Text Validators

**TSynValidateNonVoidText** - Ensures text is not empty:

```pascal
validator := TSynValidateNonVoidText.Create;
result := validator.Process(0, 'some text', errMsg); // true
result := validator.Process(0, '', errMsg);          // false
```

**TSynValidateText** - Comprehensive text constraint validation:

```pascal
// JSON parameters specify character composition requirements
validator := TSynValidateText.Create(
  '{"MinLength":5,"MaxLength":20,' +
  '"MinAlphaCount":1,"MinDigitCount":1,' +
  '"MinPunctCount":1,"MinLowerCount":1,"MinUpperCount":1}');
```

**Available properties** (all `cardinal`, defaults shown):

| Property | Default | Description |
|----------|---------|-------------|
| `MinLength` | 1 | Minimum UTF-16 codepoint count |
| `MaxLength` | maxInt | Maximum UTF-16 codepoint count |
| `MinAlphaCount` | 0 | Minimum alphabetical chars [a-zA-Z] |
| `MaxAlphaCount` | maxInt | Maximum alphabetical chars |
| `MinDigitCount` | 0 | Minimum digit chars [0-9] |
| `MaxDigitCount` | maxInt | Maximum digit chars |
| `MinPunctCount` | 0 | Minimum punctuation [_!;.,/:?%$="#@(){}+-*] |
| `MaxPunctCount` | maxInt | Maximum punctuation |
| `MinLowerCount` | 0 | Minimum lowercase chars [a-z] |
| `MaxLowerCount` | maxInt | Maximum lowercase chars |
| `MinUpperCount` | 0 | Minimum uppercase chars [A-Z] |
| `MaxUpperCount` | maxInt | Maximum uppercase chars |
| `MinSpaceCount` | 0 | Minimum space count |
| `MaxSpaceCount` | maxInt | Maximum space count |
| `MaxLeftTrimCount` | maxInt | Maximum leading spaces allowed |
| `MaxRightTrimCount` | maxInt | Maximum trailing spaces allowed |
| `Utf8Length` | false | Use UTF-8 byte count instead of UTF-16 codepoints |

**Example - Username validation**:

```pascal
// 3-20 chars, alphanumeric only, at least one letter
validator := TSynValidateText.Create(
  '{"MinLength":3,"MaxLength":20,' +
  '"MinAlphaCount":1,"MaxPunctCount":0,"MaxSpaceCount":0}');
```

**TSynValidatePassWord** - Preconfigured strong password validation:

```pascal
// Default parameters (can be overridden via JSON):
// MinLength=5, MaxLength=20,
// MinAlphaCount=1, MinDigitCount=1, MinPunctCount=1,
// MinLowerCount=1, MinUpperCount=1, MaxSpaceCount=0
validator := TSynValidatePassWord.Create;
result := validator.Process(0, 'Weak', errMsg);      // false
result := validator.Process(0, 'Str0ng!P@ss', errMsg); // true

// Custom password policy
validator := TSynValidatePassWord.Create(
  '{"MinLength":8,"MaxLength":32,"MinDigitCount":2}');
```

---

## TSynFilter Hierarchy

### Base Class: TSynFilter

Filters transform data (unlike validators which only check):

```pascal
TSynFilter = class(TSynFilterOrValidate)
public
  procedure Process(aFieldIndex: integer; var Value: RawUtf8); virtual; abstract;
  class procedure Execute(const aParameters: RawUtf8; var aValue: RawUtf8);
end;
```

**Key difference**: `Process()` modifies `Value` in-place (var parameter)

### Built-in Filters

#### Case Conversion Filters

**TSynFilterUpperCase** - ASCII-7 uppercase conversion:

```pascal
filter := TSynFilterUpperCase.Create;
value := 'hello WORLD';
filter.Process(0, value);
// value = 'HELLO WORLD'
```

**TSynFilterUpperCaseU** - WinAnsi uppercase (handles accented characters):

```pascal
filter := TSynFilterUpperCaseU.Create;
value := 'café';
filter.Process(0, value);
// value = 'CAFÉ' (é → É)
```

**TSynFilterLowerCase** / **TSynFilterLowerCaseU** - Lowercase equivalents

#### Text Manipulation Filters

**TSynFilterTrim** - Remove leading/trailing whitespace:

```pascal
filter := TSynFilterTrim.Create;
value := '  trimmed  ';
filter.Process(0, value);
// value = 'trimmed'
```

**TSynFilterTruncate** - Limit text length:

```pascal
// JSON parameters: MaxLength, Utf8Length
filter := TSynFilterTruncate.Create('{"MaxLength":10}');
value := 'This is a very long text';
filter.Process(0, value);
// value = 'This is a ' (UTF-16 codepoints, may truncate mid-character)

// UTF-8 byte-based truncation
filter := TSynFilterTruncate.Create('{"MaxLength":10,"Utf8Length":true}');
```

**Properties**:
- `MaxLength`: Maximum length (default 0 = no limit)
- `Utf8Length`: Use UTF-8 byte count (default false = UTF-16 codepoints)

---

## TRttiFilter: Rule Registry

`TRttiFilter` manages validation/filter rules for a class or record type:

```pascal
type
  TCustomer = class(TPersistent)
  published
    property Email: RawUtf8 read fEmail write fEmail;
    property UserName: RawUtf8 read fUserName write fUserName;
    property Password: RawUtf8 read fPassword write fPassword;
  end;

var
  filter: TRttiFilter;
  customer: TCustomer;
  errMsg: string;
begin
  // Initialize filter for class
  filter := TRttiFilter.Create(TCustomer);
  try
    // Add rules to fields
    filter.Add('Email', [TSynValidateEmail.Create]);
    filter.Add('UserName', [
      TSynFilterTrim.Create,
      TSynFilterLowerCase.Create,
      TSynValidateText.Create('{"MinLength":3,"MaxLength":20}')
    ]);
    filter.Add('Password', [TSynValidatePassWord.Create]);

    // Apply to instance
    customer := TCustomer.Create;
    try
      customer.Email := 'user@example.com';
      customer.UserName := '  JohnDoe  ';
      customer.Password := 'weak';

      // Filter transforms data
      filter.Filter(customer);
      // customer.UserName = 'johndoe' (trimmed and lowercased)

      // Validate checks constraints
      errMsg := filter.Validate(customer);
      if errMsg <> '' then
        ShowMessage(errMsg); // 'Password validation failed...'
    finally
      customer.Free;
    end;
  finally
    filter.Free;
  end;
end;
```

### TRttiFilter Methods

**Constructor variants**:

```pascal
// For classes
constructor Create(aClass: TClass);

// For records (via RTTI)
constructor Create(aRtti: PRttiInfo);
```

**Rule management**:

```pascal
// Add existing rule instances
procedure Add(const aFieldName: RawUtf8;
  const aRules: array of TSynFilterOrValidate);

// Create and add rule instances by class
procedure AddClass(const aFieldName: RawUtf8;
  const aRules: array of TSynFilterOrValidateClass);

// Retrieve rules for a field
function GetRules(const aFieldName: RawUtf8): TSynFilterOrValidateObjArray;

// Clear all rules
procedure Clear;
```

**Application**:

```pascal
// Apply only filters (transformations)
procedure Filter(aData: pointer);

// Apply only validators (returns '' on success, error message on failure)
function Validate(aData: pointer): string;

// Apply filters then validators
function Apply(aData: pointer;
  aClass: TSynFilterOrValidateClass = nil): string;

// Apply with exception on validation failure
procedure ApplyOrRaise(aData: pointer);
```

---

## ORM Integration

### TOrm Validation Methods

`TOrm` classes integrate validation seamlessly:

```pascal
type
  TOrmCustomer = class(TOrm)
  published
    property Email: RawUtf8 index 250 read fEmail write fEmail;
    property UserName: RawUtf8 index 50 read fUserName write fUserName;
  end;

class procedure TOrmCustomer.InternalRegisterCustomProperties(Props: TOrmProperties);
begin
  // Register validators at class level
  Props.AddFilterOrValidate('Email', TSynValidateEmail.Create);
  Props.AddFilterOrValidate('UserName', [
    TSynFilterTrim.Create,
    TSynValidateText.Create('{"MinLength":3,"MaxLength":50}')
  ]);
end;
```

**Instance validation**:

```pascal
var
  customer: TOrmCustomer;
  errMsg: string;
begin
  customer := TOrmCustomer.Create;
  try
    customer.Email := 'invalid@';
    customer.UserName := 'ab'; // Too short

    // Validate all fields
    if not customer.FilterAndValidate(Server.Orm, errMsg) then
      ShowMessage(errMsg); // First validation error encountered
  finally
    customer.Free;
  end;
end;
```

### TSynValidateRest: ORM-Specific Validators

For validations requiring database access (e.g., uniqueness checks):

```pascal
TSynValidateRest = class(TSynValidate)
protected
  fProcessRest: IRestOrm;  // Access to ORM operations
  fProcessRec: TOrm;       // Current record being validated
  function DoValidate(aFieldIndex: integer; const Value: RawUtf8;
    var ErrorMsg: string; const aProcessRest: IRestOrm;
    aProcessRec: TOrm): boolean; virtual; abstract;
end;
```

**Built-in ORM validators**:

**TSynValidateUniqueField** - Ensure field value is unique:

```pascal
class procedure TOrmUser.InternalRegisterCustomProperties(Props: TOrmProperties);
begin
  // Ensure UserName is unique across table
  Props.AddFilterOrValidate('UserName', TSynValidateUniqueField.Create);
end;
```

**Automatic behavior**:
- Checks field is not empty
- Queries database to ensure value doesn't exist in other records
- Excludes current record (if updating via ID)

**TSynValidateUniqueFields** - Multi-field uniqueness:

```pascal
// Ensure combination of FirstName + LastName is unique
Props.AddFilterOrValidate('FirstName',
  TSynValidateUniqueFields.Create('{"FieldNames":"FirstName,LastName"}'));
```

**Implementation notes**:
- Only handles text fields (not numeric)
- Requires `IRestOrm` instance (automatically provided by `TOrm.FilterAndValidate`)
- Error messages use resourcestrings (`sValidationFieldVoid`, `sValidationFieldDuplicate`)

---

## Custom Validators

### Creating a Custom Validator

Inherit from `TSynValidate` and implement `Process`:

```pascal
type
  TSynValidatePhoneNumber = class(TSynValidate)
  private
    fCountryCode: RawUtf8;
  protected
    procedure SetParameters(const Value: RawUtf8); override;
  public
    function Process(aFieldIndex: integer; const Value: RawUtf8;
      var ErrorMsg: string): boolean; override;
  end;

procedure TSynValidatePhoneNumber.SetParameters(const Value: RawUtf8);
var
  doc: TDocVariantData;
begin
  inherited;
  doc.InitJson(Value, JSON_FAST_EXTENDED);
  fCountryCode := doc.U['CountryCode']; // Extract JSON parameter
end;

function TSynValidatePhoneNumber.Process(aFieldIndex: integer;
  const Value: RawUtf8; var ErrorMsg: string): boolean;
begin
  result := false;

  // Custom validation logic
  if Length(Value) < 10 then
  begin
    ErrorMsg := 'Phone number too short';
    exit;
  end;

  if (fCountryCode = '+1') and (Length(Value) <> 10) then
  begin
    ErrorMsg := 'US phone numbers must be 10 digits';
    exit;
  end;

  // Add more validation...
  result := true;
end;
```

**Usage**:

```pascal
Props.AddFilterOrValidate('Phone',
  TSynValidatePhoneNumber.Create('{"CountryCode":"+1"}'));
```

### Creating a Custom Filter

Inherit from `TSynFilter` and implement `Process`:

```pascal
type
  TSynFilterRemoveSpaces = class(TSynFilter)
  public
    procedure Process(aFieldIndex: integer; var Value: RawUtf8); override;
  end;

procedure TSynFilterRemoveSpaces.Process(aFieldIndex: integer; var Value: RawUtf8);
var
  i, j: PtrInt;
  tmp: RawUtf8;
begin
  SetLength(tmp, Length(Value));
  j := 0;
  for i := 1 to Length(Value) do
    if Value[i] <> ' ' then
    begin
      inc(j);
      tmp[j] := Value[i];
    end;
  SetLength(tmp, j);
  Value := tmp;
end;
```

### Custom ORM Validator

For database-dependent validation:

```pascal
type
  TSynValidateManagerExists = class(TSynValidateRest)
  protected
    function DoValidate(aFieldIndex: integer; const Value: RawUtf8;
      var ErrorMsg: string; const aProcessRest: IRestOrm;
      aProcessRec: TOrm): boolean; override;
  end;

function TSynValidateManagerExists.DoValidate(aFieldIndex: integer;
  const Value: RawUtf8; var ErrorMsg: string; const aProcessRest: IRestOrm;
  aProcessRec: TOrm): boolean;
var
  managerID: TID;
  manager: TOrmUser;
begin
  result := false;
  managerID := GetInt64(pointer(Value));

  if managerID = 0 then
  begin
    ErrorMsg := 'Manager ID required';
    exit;
  end;

  // Query database using provided ORM instance
  manager := TOrmUser.Create(aProcessRest.Orm, managerID);
  try
    if manager.ID = 0 then
    begin
      ErrorMsg := 'Manager does not exist';
      exit;
    end;

    if manager.Role <> 'Manager' then
    begin
      ErrorMsg := 'Specified user is not a manager';
      exit;
    end;

    result := true;
  finally
    manager.Free;
  end;
end;
```

---

## Best Practices

### Rule Declaration

**Prefer class-level registration**:

```pascal
// GOOD: Centralized, reusable, self-documenting
class procedure TOrmProduct.InternalRegisterCustomProperties(Props: TOrmProperties);
begin
  Props.AddFilterOrValidate('SKU', [
    TSynFilterUpperCase.Create,
    TSynValidatePattern.Create('[A-Z][A-Z][A-Z]-[0-9][0-9][0-9][0-9]')
  ]);
end;

// AVOID: Scattered validation logic in business code
if not IsValidSKU(Product.SKU) then
  raise Exception.Create('Invalid SKU');
```

### Filter Ordering

Filters execute in declaration order - place transformations before validations:

```pascal
// GOOD: Trim then validate length
Props.AddFilterOrValidate('UserName', [
  TSynFilterTrim.Create,              // 1. Remove spaces
  TSynFilterLowerCase.Create,         // 2. Normalize case
  TSynValidateText.Create('{"MinLength":3}') // 3. Validate
]);

// PROBLEMATIC: Validate before trim
Props.AddFilterOrValidate('UserName', [
  TSynValidateText.Create('{"MinLength":3}'), // Might fail on '  ab  '
  TSynFilterTrim.Create                       // Too late
]);
```

### Error Messages

Provide context in custom validators:

```pascal
// GOOD: Specific, actionable error
ErrorMsg := FormatUtf8('Email domain "%" is not allowed. Use @company.com',
  [ExtractDomain(Value)]);

// POOR: Generic, unhelpful
ErrorMsg := 'Validation failed';

// GOOD: Leave empty for auto-generated message from class name
ErrorMsg := ''; // Will produce: '"Validate email" rule failed'
```

### Validation Strategy

**Client-side** (DTO/ViewModels):

```pascal
// Lightweight, no database access
filter := TRttiFilter.Create(TCustomerViewModel);
filter.Add('Email', [TSynValidateEmail.Create]);
// Apply in UI layer before submission
```

**Server-side** (ORM entities):

```pascal
// Full validation with database checks
class procedure TOrmCustomer.InternalRegisterCustomProperties(Props: TOrmProperties);
begin
  Props.AddFilterOrValidate('Email', [
    TSynValidateEmail.Create,
    TSynValidateUniqueField.Create // Database check
  ]);
end;
```

### Performance Considerations

**Reuse rule instances** when possible:

```pascal
// GOOD: Shared instance
var
  EmailValidator: TSynValidateEmail;
begin
  EmailValidator := TSynValidateEmail.Create;
  Props.AddFilterOrValidate('Email', EmailValidator);
  Props.AddFilterOrValidate('AlternateEmail', EmailValidator);
  // Instance will be freed by Props
end;

// WASTEFUL: Duplicate instances
Props.AddFilterOrValidate('Email', TSynValidateEmail.Create);
Props.AddFilterOrValidate('AlternateEmail', TSynValidateEmail.Create);
```

**Avoid expensive validators in loops**:

```pascal
// POOR: Validator created repeatedly
for i := 0 to 1000 do
begin
  validator := TSynValidateEmail.Create;
  try
    if not validator.Process(0, emails[i], err) then
      Log(err);
  finally
    validator.Free;
  end;
end;

// GOOD: Create once, reuse
validator := TSynValidateEmail.Create;
try
  for i := 0 to 1000 do
    if not validator.Process(0, emails[i], err) then
      Log(err);
finally
  validator.Free;
end;

// BEST: Use static Execute() method for one-shot validation
for i := 0 to 1000 do
begin
  err := TSynValidateEmail.Execute('', emails[i]);
  if err <> '' then
    Log(err);
end;
```

---

## Summary

The `TSynValidate`/`TSynFilter` framework provides:

- **Declarative validation** - Rules as data, not scattered procedural checks
- **Separation of concerns** - Data integrity lives with data models
- **Reusability** - Same validators across client/server, DTO/ORM
- **Extensibility** - Custom validators via simple inheritance
- **ORM integration** - Database-aware validation (uniqueness, referential checks)
- **Composability** - Chain multiple rules per field
- **Internationalization** - Error messages via resourcestrings

**Key classes**:
- `TSynValidate` - Base for validation rules
- `TSynFilter` - Base for transformation rules
- `TRttiFilter` - Rule registry for classes/records
- `TSynValidateRest` - ORM-aware validators
- `TOrm.FilterAndValidate()` - ORM integration point

**Common validators**:
- `TSynValidateEmail`, `TSynValidateIPAddress` - Format validation
- `TSynValidatePattern` - Glob pattern matching
- `TSynValidateText` - Character composition constraints
- `TSynValidatePassWord` - Strong password requirements
- `TSynValidateUniqueField` - Database uniqueness

**Common filters**:
- `TSynFilterUpperCase`, `TSynFilterLowerCase` - Case normalization
- `TSynFilterTrim` - Whitespace removal
- `TSynFilterTruncate` - Length limiting

This system ensures data quality at the model layer, enabling fail-fast validation, clear error reporting, and maintainable domain rules.
